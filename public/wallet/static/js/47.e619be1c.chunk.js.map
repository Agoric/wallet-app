{"version":3,"file":"static/js/47.e619be1c.chunk.js","mappings":"iMAQO,MAAMA,EAAoB,yBAgBpBC,EAAQC,GAAM,IAAIC,SAAQC,GAAWC,WAAWD,EAASF,KAMzDI,EAAgB,SAACC,GAAuB,IAAhBC,EAAgB,uDAAVD,EACzC,OAAOE,KAAKC,SAAWD,KAAKE,IAAIH,EAAKD,EACtC,EAOYK,EAAqB,WAA6C,IAA5CC,EAA4C,uDAAlC,EAAGC,EAA+B,uDAAxB,IAAON,EAAiB,uDAAX,IAClE,OAAOF,EAAc,GAAKO,EAAUC,EAAMN,EAC3C,EAQYO,EAAiBC,IAC5B,MAAMC,EAASX,EAAcY,KAE7B,OADAC,QAAQC,MAAO,aAAYJ,QAAYP,KAAKY,KAAKJ,QAC1ChB,EAAMgB,EAAb,EAWWK,EAAyB,SAACN,EAAOO,GAAqB,IAAhBV,EAAgB,uDAAN,EAC3D,MAAMW,EAAUZ,EAAmBC,GAKnC,OAJAM,QAAQM,IACL,YAAWT,QAAYP,KAAKY,KAAKG,uBAA6BX,IAC/DU,GAEKtB,EAAMuB,EACd,EAOYE,EAAuB,IAClCzB,EAAMK,EAAcqB,MAAuCC,MAAK,KAAM,IAE3DC,EAAuB,IAM3BC,QAAOC,IACZ,IACE,OAAOD,OAAOE,KAAKC,MAAMF,GAG1B,CAFC,MAAOG,GACP,MAAM,IAAIC,MAAO,+BAA8BD,EAAME,aAAaL,IACnE,KASQM,EAA4B,KACvC,MAAMC,EAAqB,YAErBC,EAAO,IAAIC,IAajB,OAAOC,EAAAA,EAAAA,IAAI,uBAAwB,CACjCC,aAAaC,EAAAA,EAAAA,SAAYC,GAbT,CAACC,EAAMC,KAEvB,GAAIP,EAAKQ,IAAIF,GACX,OAAON,EAAKS,IAAIH,GAEG,kBAAVC,GAAsBA,EAAMG,WAAWX,KAChDQ,EAAQA,EAAMI,MAAMZ,EAAmBa,SAEzC,MAAMC,GAAMX,EAAAA,EAAAA,IAAK,YAA4BK,IAAS,CAAC,GAEvD,OADAP,EAAKc,IAAIR,EAAMO,GACRA,CAAP,IAG+CV,aADjD,EC5GWY,EAAUC,IACrB,IAAK,IAAIC,EAAID,EAAEJ,OAAS,EAAGK,EAAI,EAAGA,GAAK,EAAG,CACxC,MAAMC,EAAIhD,KAAKiD,MAAMjD,KAAKC,UAAY8C,EAAI,IACpCG,EAAIJ,EAAEC,GACZD,EAAEC,GAAKD,EAAEE,GACTF,EAAEE,GAAKE,CACR,GCJUC,EAA4BC,UACvC,MAAM,YAAEC,EAAcpC,SAA+BqC,EAAAA,EAAAA,GAAEC,GAAQC,aAEzDC,GAAWzB,EAAAA,EAAAA,IAAI,mCAAoC,CACvD,CAAC0B,OAAOC,eAAgB,KAEtB,IAAIC,EACJ,OAAO5B,EAAAA,EAAAA,IAAI,mCAAoC,CAC7C6B,KAAMT,UACCQ,IACHA,EAAkBP,EAAY,2BAA2BlC,MACvD2C,GACMA,GACKR,EAAAA,EAAAA,GAAEC,GACN/C,OAAO,2BACPW,MAAK,IAAM2C,IAETA,KAIb,MAAMC,QAAkBH,EACxBA,OAAkBzB,EAClB,MAAM6B,EAAS3C,OAAO,CAEpB4C,OAAQ,KAEV,OAAO5C,OAAO,CACZ6C,MAAOF,EACPG,MAAOJ,GAFT,GApBJ,IA6BJ,OAAO/B,EAAAA,EAAAA,IAAI,0BAA2B,CACpCoC,kBAAmBhB,SAAYK,EAC/BY,gBAAiBjB,SAAYK,EAC7Ba,mBAAoBlB,UAClB,MAAM1B,MAAM,8CAAZ,GAJJ,GCrCM6C,QAASC,GAAMC,OAOVC,EAA6B,CAACC,EAAUC,KACnDH,OAAOI,MAAMC,QAAQH,GAAWH,CAAE,YAAWG,sBAW7C,OChBkC,SAACI,GAAkC,IAAvBH,EAAuB,uDAAP,CAAC,EAC/D,MAAM,cAAEI,EAAgBnE,EAAlB,OAA0CL,EAASF,GACvDsE,EAIF/B,EAAQkC,GAER,IAEIE,EAFAC,EAA8B,EAC9BC,EAAc,EAIlB,MAAM5B,GAASvB,EAAAA,EAAAA,IAAI,qBAAsB,CACvCwB,WAAY,IAAMoB,EAClBpE,OAAQ4C,SAAe5C,GAAUA,EAAOD,GACxC6E,MAAOhC,MAAO7C,EAAOO,EAAKV,KACxB,GAAI4E,EACF,OAAOA,EAAczE,EAAOO,EAAKV,GAEnC,MAAMU,CAAN,EAGFuE,aAAcC,GAAiBC,EAM/BC,aAAcpC,MAAO7C,EAAOkF,KAC1BlF,EAAS,GAAEA,4BAED,IAAIb,SAAQ,CAACC,EAAS+F,KAC9B,IAAIC,EAAgBT,EAEpB,MAAME,EAAQtE,IACZ,IAAKmE,EAAU,CACb,MAAM7E,EAAU+E,EAChBF,GAAW3B,EAAAA,EAAAA,GAAEC,GACV6B,MAAM7E,EAAOO,EAAKV,GAClBe,MAAK,KACJwE,GAAiBA,EAAgB,GAAKZ,EAAUrC,OAChDuC,EAAW,IAAX,GAEL,CAEDA,EACG9D,MAAK,IAAMX,GAAUA,EAAOD,KAE5BY,KAAKyE,EAAUF,GAClBP,GAAe,CAAf,EAGIS,EAAW,KACflG,QAAQC,UACLwB,MAAK,IAAMsE,EAASV,EAAUY,MAC9BxE,MAAK0E,IACJlG,EAAQ0B,OAAO,CAACwE,KAChBX,EAA8BS,EAC9BR,EAAc,CAAd,GACCC,EANL,EAWFQ,GAAU,OAMVL,EAAwBpC,EAA0BI,GACxD,OAAOA,CACR,CDzDQuC,CATUnB,EAASoB,KAAIC,IAC5BvB,OAAOwB,OAAOD,EAAS,SAAUxB,CAAE,WAAUwB,sBAKtCA,EAAQE,SAAS,OAASF,EAAW,UAASA,OAGjBpB,EAAtC,EAOWuB,EAA8B,SAACC,GAA+B,IAAjBC,EAAiB,uDAAP,CAAC,EACnE,MAAM,cAAErB,EAAgBnE,EAAlB,OAA0CL,EAASF,GACvD+F,EAEIjB,EAAQhC,MAAO7C,EAAOO,EAAKV,KAC/B,GAAI4E,EACF,OAAOA,EAAczE,EAAOO,EAAKV,GAEnC,MAAMU,CAAN,EAEF,IAAIV,EAAU,EACd,MAAMG,EAAQ,wBACd,OAAO,IAAIb,SAAQ,CAACC,EAAS+F,KAC3B,MAAMY,EAAalD,UACjB,MAAMmD,QAAiBC,MAAMJ,EAAc,CACzCK,QAAS,CAAEC,OAAQ,uBAEf,SAAE/B,SAAmB4B,EAASI,OAGpC,OADAvG,EAAU,EACHsE,EAA2BC,EAAU0B,EAA5C,EAEIO,EAAcxD,UAClBgC,EAAM7E,EAAOO,EAAKV,GACfe,MAAK,IAAMX,EAAOD,KAClBY,MAAK,IAAMmF,IAAanF,KAAKxB,EAASiH,KACtCC,MAAMnB,GACTtF,GAAW,CAAX,EAEFkG,IAAanF,KAAKxB,EAASiH,EAA3B,GAEH,EAOYN,EAAa,WAA4C,IAA3CQ,EAA2C,uDAA/BvH,EAAmB8G,EAAY,uCACpE,OAAIS,EAAUZ,SAAS,kBACdC,EAA4BW,EAAWT,GAEzC3B,EAA2B,CAACoC,GAAYT,EAChD,EErEYU,EAAuBC,IAClCC,EAAAA,EAAAA,KAAa3D,EAAAA,EAAAA,GAAE0D,GAAUE,gCA4BdC,EAA2BC,GACtC/F,OAAO,CACL,CAACqC,OAAOC,eAAgB,KACtB0D,OAtB2BC,GAuBzBhE,EAAAA,EAAAA,GAAE8D,GAAcG,oCApBfvF,EAAAA,EAAAA,IAAI,uBAAwB,CACjC6B,KAAMT,UACJ,MAAMoE,EAAUlE,EAAAA,EAAAA,IAAMgE,GAAOG,KAE7B,OADAH,EAAQhE,EAAAA,EAAAA,IAAMgE,GAAOI,KACdF,CAAP,IAP2BF,KAoBxB,IAcIK,EAAmB,CAAClE,EAAUmE,IACzCxE,kBACE,UAAW,MAAMc,KAAST,QAClBmE,EAAU1D,EAEnB,CACM2D,GA6BIC,EAAc,CAACC,EAAU1B,KAEpCrE,EAAAA,EAAAA,IAAI,uBAAwB,CAE1B,CAAC0B,OAAOC,eAAgB,KACtB,MAAMqE,GAAe1E,EAAAA,EAAAA,GAAEyE,GAAU1D,gBAAgBgC,GAC3C4B,GAAW3E,EAAAA,EAAAA,GAAE0E,GAActE,OAAOC,iBACxC,OAAO3B,EAAAA,EAAAA,IAAI,uBAAwB,CACjC6B,KAAM,KAAMP,EAAAA,EAAAA,GAAE2E,GAAUpE,QAD1B,I,mECzFN,MAAM,QAAEqE,GAAYC,EAYdC,EAAsB,IAAIC,WAAW,GACrCC,EAAoB,IAAIC,WAAW,CAAC,IAOpCC,EAA4B,SAACC,GAAwC,IAA3BC,EAA2B,uDAAf,WAC1D,MAAMC,EAAQF,EAAcA,EAAYG,MAAM,KAAO,GAC/CC,EAAMX,EAAS,GAAES,EAAMjG,UAAU+F,KACvC,OAAOpH,OAAO,CACZqH,YACAI,YAAaD,EAAI9C,KAAIgD,GAAMA,IAAMX,EAAsB,EAAIW,IAC3DC,gBAAiBV,GAEpB,EAOYW,EAAyB5H,OAAO,CAC3C,YA9BgCoH,GAChCpH,OAAO,CACLqH,UAAW,WACXI,YAAaZ,EAAS,iBAAgBO,OA4BxC,UAAWD,EACX,IARoCA,IA6BhCU,EAAK,IAAIC,YAMFC,EAA4BC,IACvC,MAAM,UAAEX,EAAF,YAAaI,EAAb,gBAA0BE,EAA1B,aAA2C5B,EAA3C,SAAyDJ,GAC7DqC,EACF,GAAIjC,GAAgBJ,EAClB,OAAO3F,OAAO,CACZ+F,eACAJ,aAGJ,IAAIsC,EAASR,EACc,kBAAhBA,IACTQ,EAASJ,EAAGK,OAAOT,IAErB,IAAIU,EAAaR,EAIjB,MAH+B,kBAApBA,IACTQ,EAAaN,EAAGK,OAAOP,IAElB3H,OAAO,CACZqH,YACAI,YAAaQ,EACbN,gBAAiBQ,GAHnB,EAsBWC,EAAkBrG,UAC7B,MAAMsG,QAAaC,EACnB,GAAoB,kBAATD,EACT,MA9DqCE,KACvCnF,OAAOwB,OAAO2D,EAAY,UAC1B,MAAMC,EAAQD,EAAWC,MAAM,kBAC/BpF,OACEoF,EACC,eAAcD,6CAEjB,MAAME,EAAOD,EAAM,GACbE,EAAYF,EAAM,GAClBG,EAAYf,EAAuBa,GAEzC,OADArF,OAAOuF,EAAY,oBAAmBF,KAC/BE,EAAUD,EAAjB,EAmDSE,CAA0BP,GAGnC,MAAM,UAAEhB,EAAF,aAAatB,EAAb,SAA2BJ,GAAa0C,EAC9C,OAAIhB,GAAatB,GAAgBJ,EACxBoC,EAA0BM,IAE/BQ,EAAAA,EAAAA,IAAeR,GArBiBtG,WACpC,MAAMiG,QAAgB/F,EAAAA,EAAAA,GAAE6G,GAASC,cACjC,OAAOhB,EAA0BC,EAAjC,EAoBSgB,CAAuBX,QAEhCjF,OAAO6F,KAAM,eAAcZ,oCAA3B,GC/GI,YAAEa,GAAgBC,GAClB,mBAAEC,GAAuBC,GACvBnG,QAASC,EAAGmG,MAAOC,GAAMnG,OAC3BoG,EAAc,IAAIC,YAclBC,EAAeC,GACnBA,GACgB,kBAATA,GACPnG,MAAMC,QAAQkG,EAAK/G,SACS,kBAArB+G,EAAKC,aACZ,oBAAoBC,KAAKF,EAAKC,aAM1BE,EAAa,CAACrI,EAAGiG,KACrB,GAAIjG,EAAEJ,SAAWqG,EAAErG,OACjB,OAAO,EAET,IAAK,IAAIK,EAAI,EAAGA,EAAID,EAAEJ,OAAQK,GAAK,EACjC,GAAID,EAAEC,KAAOgG,EAAEhG,GACb,OAAO,EAGX,OAAO,CAAP,EAGIqI,EAAyB,IAAI7C,WAO7B8C,EAAgBpH,IAEpB,MAAMwD,EAAO,GACb,IAAI6D,EAAQ,EACZ,IAAK,MAAMpH,KAASD,EAClBqH,GAAS,EACK,IAAVA,EACF7D,EAAK8D,KAAKrH,GAEVO,OAAO6F,KAAM,uCAAsCgB,KAKvD,OADA7G,OAAO+G,MAAM/D,EAAK/E,OAAQ,EAAG,yBACtB+E,EAAK,EAAZ,EAIIgE,EAAS,CAAC,SAAU,OAAQ,cCjBrBC,EAAetI,MAAOuI,EAAOC,EAAevF,KACvD,MAAMqD,QAAaD,EAAgBkC,IAC7B,UAAEjD,GAAcgB,EACtB,OAAIhB,EDuB4B,SAChCiB,GAGG,IAFHiC,EAEG,uDAFaC,EAChBxF,EACG,uDADO,CAAC,EAEX,MAAM,OACJyF,EAAS1K,IADL,aAEJ2K,EAAenK,IAFX,MAGJoK,EAAQ,aAHJ,QAIJC,EAAU,MACR5F,EAKE6F,EAAQpL,IAMZ,MALImL,IACF3I,EAAAA,EAAAA,GAAE2I,GACCC,MAAO,gDAAgDpL,GACvD+F,OAAMsF,GAAK1H,OAAO6F,KAAK9F,CAAE,6BAA4B2H,OAEpDrL,CAAN,EAGF2D,OAAOgH,EAAOvF,SAAS8F,GAAQxH,CAAE,oCAAmCwH,KAEpE,MAAMzL,EAAQ,kBACR6L,EAAe3C,EAAgBE,GAE/BpG,EACqB,oBAAlBqI,EAA+BA,IAAkBA,EAEpDS,EAAqB,IAAItK,IAKzBuK,EAA0BC,IAC9B,IAAIC,EAAUH,EAAmB9J,IAAIgK,GAKrC,OAJKC,IACHA,EAAU/B,EAAmBgC,QAAQF,GACrCF,EAAmBzJ,IAAI2J,EAAUC,IAE5BA,CAAP,EAGIE,EAAiBtJ,UACrB,MAAMa,QAAeX,EAAAA,EAAAA,GAAEC,GAAQiC,aAAajF,GAAO6C,UACjD,MAAMuJ,QAAeL,EAAwBC,GACvCK,QAAaD,EAAOE,YACpB,gBAAEC,GAAoBF,EAE5B,OADAnI,OAAOwB,OAAO6G,EAAiB,UACxBA,CAAP,IAEF,OAAOzB,EAAcpH,EAArB,EAII8I,EAAwB,IAAIhL,IAK5BiL,EAAqB5J,UACzB,GAAI2J,EAAsBzK,IAAIiK,GAAW,CAEvC,MAAMU,EAAcF,EAAsBxK,IAAIgK,GAE9C,OADA9H,OAAOwI,GACAA,CACR,CAED,MAAMC,QAAkBZ,EAAwBC,GAC1CU,EAAc1C,EAAY4C,eAAeD,GAE/C,OADAH,EAAsBnK,IAAI2J,EAAUU,GAC7BA,CAAP,EAMIG,EAA6BhK,UACjC,MAAM,UACJsF,EADI,YAEJI,EAFI,gBAGJE,EAAkBoC,SACVgB,EAEV3H,OAAOwB,OACLyC,EACA,SACAlE,CAAE,mCAAkCkE,KAEtCjE,OACEqE,EACAtE,CAAE,yCAAwCsE,KAI5C,MAAM7E,QAAeX,EAAAA,EAAAA,GAAEC,GAAQiC,aAAajF,GAAO6C,SACjDiK,EAAmBd,EAAU7D,EAAWI,GAAa3H,MACnDmM,IACS,CAAEA,SAAQ7L,MAAO,SAE1BA,IACS,CAAE6L,OAAQ,KAAM7L,eAKvB,OAAE6L,EAAF,MAAU7L,GAAU4J,EAAcpH,GACxC,GAAc,OAAVxC,EACF,MAAMA,EAIR,OAFAgD,OAAO6I,GAEe,IAAlBA,EAAO5K,OAEF4K,GAIT7I,OACE6I,EAAO5K,QAAUsG,EAAgBtG,OACjC8B,CAAE,oCAAmCwE,KAEvCvE,OACE0G,EAAWmC,EAAOC,SAAS,EAAGvE,EAAgBtG,QAASsG,GACvDxE,CAAE,GAAE8I,oCAAyCtE,KAExCsE,EAAO7K,MAAMuG,EAAgBtG,QAApC,EAOI8K,EAAwBpK,SACrBgK,GACLhK,MAAOmJ,EAAU7D,EAAWI,KAC1B,MAAMmE,QAAoBD,EAAmBT,GAC7C,OAAOjJ,EAAAA,EAAAA,GAAE2J,GAAaQ,cAAc/E,EAAWI,EAAa4E,EAA5D,IAQAC,EAA0BvK,SACvBgK,GACLhK,MAAOmJ,EAAU7D,EAAWI,KAC1B,MAAM6D,QAAeL,EAAwBC,GACvChG,QAAiBoG,EAAOiB,UAAU,CACtCC,KAAO,SAAQnF,QACfoF,KAAMhF,EACN4E,SACAK,OAAO,IAET,GAAsB,IAAlBxH,EAASyH,KACX,MAAM,IAAItM,MAAO,iCAAgC6E,EAASvF,OAE5D,MAAM,MAAEkD,GAAUqC,EAClB,OAAOrC,CAAP,IAQA+J,EAAqB7K,UACzB,GAAc,WAAV4I,EAEF,OAAOwB,EAAsBvC,GAAapE,MAAMqF,GAC3C,GAAc,SAAVF,EAET,OAAO2B,EAAwB1C,GAC1B,GAAc,eAAVe,EAAwB,CACjC,MAAMkC,QAAoBP,EAAwB1C,GAelD,OAZAuC,EAAsBvC,GAAa9J,MAAKgN,IAClChD,EAAWgD,EAAYD,IAG3BhC,EACEzH,OAAOhD,MACL+C,CAAE,iBAAgB0J,yBAAmCC,KAFzD,GAKCjC,GAGIgC,CACR,CAEDzJ,OAAO6F,KACL9F,CAAE,6BAA4BoG,EAC5BoB,iDAFJ,EAUIoC,EAAkBhL,UACtBqB,OAAOwB,OAAOgF,EAAa,UAC3B,IAAK,IAAI7K,EAAU,GAAKA,GAAW,EACjC,IAEE,aAAa6N,EAAmBhD,EAMjC,CALC,MAAOxJ,SAGD6B,EAAAA,EAAAA,GAAEC,GAAQ6B,MAAM7E,EAAOkB,EAAOrB,GACpC,QACD,CACF,EAOGiO,EAAoB,CAACpD,EAAa6C,KACtC,MAAMQ,EAAOzD,EAAYiB,OAAOgC,GAChC,IACE,MAAM9C,EAAOzJ,KAAKC,MAAM8M,GACxB,GAAIvD,EAAaC,GACf,OAAO3J,OAAO,CACZ4J,YAAasD,OAAOvD,EAAKC,aACzBhH,OAAQ+G,EAAK/G,OAAO8B,IAAI+F,IAS7B,CAHC,MAGD,CAMD,OAAOzK,OAAO,CACZ4J,cACAhH,OAAQ,CAAC6H,EAAOwC,KAFlB,EAYIE,EAAqCpL,MACzC0K,EACA7C,EACAwD,KAMO,CAAEvK,YAFP6H,GAAezI,EAAAA,EAAAA,GAAEyI,GAAc9J,YAAY6L,GAAQA,GAErC7C,cAAawD,uBAQ/B,SAAUC,EAAkBC,EAAYF,GACtC,IAAK,MAAMX,KAAQa,EAAW1K,aACtBuK,EACJV,EACAa,EAAW1D,YACXwD,EAGL,CAOD,SAAUG,EAAsBD,EAAYF,GAC1C,IAAK,IAAI1L,EAAI4L,EAAW1K,OAAOvB,OAAS,EAAGK,GAAK,EAAGA,GAAK,QAChDyL,EACJG,EAAW1K,OAAOlB,GAClB4L,EAAW1D,YACXwD,EAGL,CAOD,SAAUI,EAAkBF,EAAYF,GACtC,MAAM,OAAExK,GAAW0K,EACnB,GAAI1K,EAAOvB,OAAS,EAAG,CACrB,MAAMoM,EAAO7K,EAAOA,EAAOvB,OAAS,SAC9B8L,EACJM,EACAH,EAAW1D,YACXwD,EAEH,CACF,CAKDrL,eAAgBgB,IACd,IAAI6G,EACA6C,EACJ,OAAS,CACP,MAAMW,QAA2B/B,IACjC,GAAI+B,IAAuBxD,EAAa,OAGhC3H,EAAAA,EAAAA,GAAEC,GAAQ/C,OAAOD,GACvB,QACD,CAED,MAAMwO,QAAoBX,EAAgBK,GAC1C,GAA2B,IAAvBM,EAAYrM,OAAc,OAGtBY,EAAAA,EAAAA,GAAEC,GAAQ/C,OAAOD,GACvB,QACD,CACD,MAAMyO,EAAoBX,EACxBI,EACAM,GAGF9D,EAAcwD,OAODtM,IAAT2L,GAAsB3C,EAAW2C,EAAMiB,WAMpCF,EAAkBG,EAAmBP,GAC5CX,EAAOiB,EACR,CACF,CAMD3L,eAAgB6L,EAAwBC,GAKtC,IAAIC,EAKJ,IATA1K,OAAOwB,OAAOiJ,EAAmB,YASxB,CAEP,GADAC,QAAmBf,EAAgBc,GACT,IAAtBC,EAAWzM,OAAc,CAC3B,MAAM0M,EAAmBf,EACvBa,EACAC,SAEKT,EAAkBU,EAAkBF,GAC3C,KACD,OAGK5L,EAAAA,EAAAA,GAAEC,GAAQ/C,OAAOD,GACvB2O,QAA0BxC,GAC3B,CAID,OAAS,CACP,MAAM+B,QAA2B/B,IAEjC,GAAI+B,GAAsBS,EAAmB,OAGrC5L,EAAAA,EAAAA,GAAEC,GAAQ/C,OAAOD,GACvB,QACD,CASD,IAAI8O,EAAmBZ,EACnBa,QAAkBlB,EAAgBiB,GACtC,GAAyB,IAArBC,EAAU5M,OAAc,OAGpBY,EAAAA,EAAAA,GAAEC,GAAQ/C,OAAOD,GACvB,QACD,CACD,IAAIgP,EAAkBlB,EAAkBgB,EAAkBC,GAI1D,MAAMP,EAAcO,EACdE,EAAQ,GACd,KAAOH,EAAmBH,GAAmB,CAC3C,GAAIK,EAAgBtE,YAAcoE,EAAkB,CAClD,MAAM,UAAE3G,EAAF,YAAaI,SAAsBsD,EACzC,MAAM,IAAI1K,MACP,4BAA2BgH,eAAuBI,qBAA+BuG,uDAAsEE,EAAgBtE,cAE3K,CACD,MAAMwE,EAAkBF,EAAgBtE,YAAc,EAEtD,GAAIwE,GAAmBP,EACrB,MAEF,MAAMQ,QAAiBtB,EAAgBqB,GAGvC,GAAwB,IAApBC,EAAShN,OACX,MAEF,MAAMiN,EAAiBtB,EAAkBoB,EAAiBC,GASrDvE,EAAWuE,EAAUJ,IACxBE,EAAMjE,KAAKgE,GAIbD,EAAYI,EACZH,EAAkBI,EAClBN,EAAmBI,CACpB,CAUD,IANKtE,EAAWmE,EAAWH,IACzBK,EAAMjE,KAAKgE,KAKJ,CACP,MAAMvE,EAAOwE,EAAMI,MACnB,QAAazN,IAAT6I,EACF,YAEK0D,EAAkB1D,EAAMyD,EAChC,CAGDS,EAAoBT,EACpBU,EAAaJ,CACd,CACF,CAMD3L,eAAgByM,EAA2BX,GAIzC,IAAIC,EACJ,KAAOD,EAAoB,GAAG,CAE5B,GADAC,QAAmBf,EAAgBc,GACT,IAAtBC,EAAWzM,OAEb,OAEF,MAAM0M,EAAmBf,EAAkBa,EAAmBC,SACvDP,EAAsBQ,EAAkBF,GAC/CA,EAAoBE,EAAiBnE,YAAc,CACpD,CACF,CAGD,OAAOjJ,EAAAA,EAAAA,IAAI,iBAAkB,CAC3BoB,kBAAA,SACSgB,IAEThB,wBAAmD,IAA7B,OAAEsK,GAA2B,uDAAJ,CAAC,EAI9C,YAHevL,IAAXuL,IACFA,QAAehB,KAEVuC,EAAwBvB,EAChC,EACDtK,2BAAsD,IAA7B,OAAEsK,GAA2B,uDAAJ,CAAC,EAIjD,YAHevL,IAAXuL,IACFA,QAAehB,KAEVmD,EAA2BnC,EACnC,GAEJ,CCliBUoC,CAAmBpG,EAAMkC,EAAevF,GAjDlBqD,KAC/B,MAAM9B,EAAY1D,GAChB7C,OAAO,CAAE6C,QAAO+G,YAAa8E,IAAKtB,mBAAoBsB,MAiCxD,OA/BiB/N,EAAAA,EAAAA,IAAI,iCAAkC,CACrDoC,kBAAmBhB,UACjB,MAAM,SAAE4D,EAAF,aAAYI,SAAuBsC,EACzC,IAAIsG,EAOJ,OANIhJ,EACFgJ,EAAKjJ,EAAqBC,IAE1BvC,OAAO2C,GACP4I,EAAK7I,EAAyBC,IAEzBO,EAAiBqI,EAAIpI,EAA5B,EAGFvD,gBAAiBjB,UACf,MAAM,SAAE4D,EAAF,aAAYI,SAAuBsC,EACzC,IAAIsG,EAOJ,OANI5I,EACF4I,EAAK7I,EAAyBC,IAE9B3C,OAAOuC,GACPgJ,EAAKjJ,EAAqBC,IAErBW,EAAiBqI,EAAIpI,EAA5B,EAGFtD,mBAAoBlB,UAClB,MAAM1B,MACJ,8DADF,GAKJ,EAgBOuO,CAAyBvG,EAAhC,EC5DWwG,EAAwB,kBAgHxBC,EAAgB/M,UAC3B,MAAM4E,GAAe1E,EAAAA,EAAAA,GAAEyE,GAAUzD,qBAC3B2D,QAAiB3E,EAAAA,EAAAA,GAAE0E,GAActE,OAAOC,iBACxCyM,QAAWnI,EAASpE,OAGtBuM,EAAGjM,OAASiM,EAAGlM,OACjBO,OAAO6F,KAAK4F,EACb,E,uBCzHH,MAAQ3L,QAASC,GAAGmG,MAAOC,IAAMnG,OAa3B4L,GAAYC,GACW,kBAAbA,KAA2BA,EAASzG,MAAM,cAsBpD0G,GAAiB,CAACC,EAAS1G,EAAM2G,IAE7B,GAAE3G,KAD6B,GAAE2G,MAUrCC,GAAU,CAACC,EAAQC,IACXC,OAAOC,KAAKH,GAAQI,KAAKH,GAUjCI,GAAkB,CAACC,EAAQ7O,KAC/B,MAAM0H,EAAO4G,GAAQO,GAAQC,GAAK9O,EAAKI,WAAY,GAAE0O,QAErD,MAAO,CAAEpH,OAAM2G,GADJ3G,EAAOyE,OAAOnM,EAAKK,MAAMqH,EAAKpH,OAAS,IAAMqN,IACxD,EAiCIoB,GAAc,CAACC,EAAOhP,EAAMiP,KAChCD,EAAME,OAAOC,KAAKnP,EAAMiP,GACxBD,EAAMI,MAAMD,KAAKF,EAAKjP,EAAtB,EAmIIqP,GAAsBpP,IAC1B,MAAMqP,EAAW,YAAWrP,EAAMsP,QAAQ,aAAc,MACxD,OAAO3P,EAAAA,EAAAA,IAAI0P,EAAS,CAAC,EAArB,E,2DCvOK,MAAME,GAAwBC,IAEnC,MAAMC,EAAa,IAAI/P,IA2CjBgQ,EAAkBC,IACtB,MAAM,IAAEC,EAAF,SAAOC,GAAaF,EAEtBC,GAAOC,GA5CgB,EAACD,EAAKC,KACjC,MAAMC,EAAW5Q,KAAKC,MAAMyQ,GAC5BxN,OAAOI,MAAMC,QAAQqN,IACrB,MAAOC,EAAKC,EAAQC,EAAOC,GAAiCJ,EACtDK,EAAUjR,KAAKC,MAAM0Q,GAC3B,GAAY,QAARE,IAAkBI,GAAmC,kBAAjBA,EAAQC,KAC9C,OAGF,MAAM9P,EAAM,IACP6P,EACHE,WAAYL,GAERM,EAAUpR,KAAKqR,UAAU,CAACP,EAAQC,IAExC,IAAIO,EAEAC,EACJ,GAAIhB,EAAWxP,IAAIqQ,IAChBE,EAAMC,GAAMhB,EAAWvP,IAAIoQ,IAAYlO,OAAO6F,WAC1C,CAEL,MAAMyI,EAAOC,IACXtS,QAAQC,MAAM,oCAAqCqS,GACnDC,OAAOC,aAAaC,QAClB5R,KAAKqR,UAAU,CAAC,KAAMP,EAAQC,EAAOQ,IACrCvR,KAAKqR,UAAUI,IAEjBF,GAAM,CAAN,EAEIM,EAAW,KAAM9P,EAAAA,EAAAA,GAAEuO,GAAQwB,gBAAgBhB,EAAQA,GACzD3R,QAAQC,MAAM,uBAAwB,CAAE0R,SAAQC,UAChDO,GAAOS,EAAAA,GAAAA,IAAW,QAAOjB,QAAaC,IAASS,EAAMK,GACrDN,EAAK,CACN,CACDhB,EAAWlP,IAAI+P,EAAS,CAACE,EAAMC,EAAK,IACpCpS,QAAQC,MAAM,qCAAsCgC,GACpDkQ,EAAKU,SAAS5Q,GACdsQ,OAAOC,aAAaM,WAAWvB,EAA/B,EAOEwB,CAAqBxB,EAAKC,EAC3B,EAIH,OAFAe,OAAOS,iBAAiB,UAAW3B,GAE5B,KACLkB,OAAOU,oBAAoB,UAAW5B,GACtC,IAAK,MAAOc,EAAMN,KAAQT,EAAW7N,SAEnC4O,EAAKe,MAAMlS,MAAM,+BAClB,CALH,E,qCCvDF,MAAMmS,GAAmB,QAEZC,GAAYC,IAAa,wBACpCC,EAAAA,GAAAA,GAAU,CAACH,GAAkBE,WADO,QACY,EADZ,ECMzBE,GAAiBF,IAC5B,MAAMG,EAAQ,IAAInS,KACZ,SAAEiF,EAAF,QAAYmN,IAAYC,EAAAA,EAAAA,MACxBC,EAAmB,IAAMF,EAAQG,YAAY,IAAIJ,EAAMjQ,WAEvDsQ,EAAaC,IACjBN,EAAMtR,IAAI4R,EAAKnC,OAAQmC,GDTD,EAACT,EAAeS,KAAU,IAAD,EACjD,MAAM,OAAEnC,EAAF,OAAUoC,EAAV,QAAkBC,GAAYF,EAE9BN,EAAK,UAAGJ,GAAUC,UAAb,QAA+B,IAC1CY,EAAAA,GAAAA,GACE,CAACd,GAAkBE,GACnB,IACKG,EAAMU,QAAOC,GAAKA,EAAExC,SAAWA,IAClC,CAAEA,SAAQoC,SAAQC,UAASjE,GAAI4B,EAAQyC,KAAM,CAAErE,GAAI4B,KAJvD,ECME0C,CAAOhB,EAAeS,GACtBH,GAAkB,EAGdW,EAAa3C,IACjB6B,EAAMe,OAAO5C,GDFS,EAAC0B,EAAe1B,KAAY,IAAD,EACnD,MAAM6B,EAAK,UAAGJ,GAAUC,UAAb,QAA+B,IAC1CY,EAAAA,GAAAA,GACE,CAACd,GAAkBE,GACnBG,EAAMU,QAAOC,GAAKA,EAAExC,SAAWA,IAFjC,ECCE6C,CAAOnB,EAAe1B,GACtBgC,GAAkB,EAGdc,EAAiB,CAAC9C,EAAQqC,KAC9B,MAAMF,EAAON,EAAM3R,IAAI8P,GACvB5N,OAAO+P,EAAO,0CAAyCnC,KACvDkC,EAAW,IAAKC,EAAME,WAAtB,EAGIU,EAAa/C,IACjB,MAAMmC,EAAON,EAAM3R,IAAI8P,GACvB5N,OAAO+P,EAAO,kCAAiCnC,KAC/CkC,EAAW,IAAKC,EAAMC,QAAQ,GAA9B,EA6BF,OA1BoBY,GAAKtB,GACbuB,SAAQT,IAClB,IAAIU,EACJ,MAAMC,EAAY,IAAI9V,SAAQmG,IAC5B0P,EAAe,KACbH,EAAWP,EAAExC,QACbxM,GAAK,CAFP,IAMFqO,EAAMtR,IAAIiS,EAAExC,OAAQ,IACfwC,EACHW,YACAC,QAAS,CACPhB,OAAQc,EACRG,WAAYhB,GAAWS,EAAeN,EAAExC,OAAQqC,GAChDO,OAAQ,IAAMD,EAAWH,EAAExC,WAI3BwC,EAAEJ,QACJc,GACD,IAEHlB,IAEO,CACLH,QACAlN,WACA2O,QAASpB,EACTY,iBACAH,aACAI,aANF,EC5DWQ,GAAmBC,IAC9B,MAAMC,EAAc,IAAI/T,KAElB,SAAEiF,EAAF,QAAYmN,IAAYC,EAAAA,EAAAA,MACxBC,EAAmB,IAAMF,EAAQG,YAAY,IAAIwB,EAAY7R,WAE7D8R,EAAmBC,IACvBvR,OACEqR,EAAYxT,IAAI0T,GACf,+CAA8CA,KAEjDF,EAAYb,OAAOe,GACnB3B,GAAkB,EA0BpB,MAAO,CACLrN,WACAiP,cAzBoB,CAACvB,EAASsB,KAC9BF,EAAYlT,IAAIoT,EAAS,CACvBA,UACAtB,UACAe,QAAS,CACPR,OAAQ,IAAMc,EAAiBC,GAC/BtP,OAAQtD,UACN,MAAM8S,EAAS3U,KAAKqR,UAAU,CAC5BH,KAAM,gBACN3E,KAAM,CAAEkI,UAAStB,QAASyB,KAE5B,UACQN,EAAgBK,GACtBH,EAAiBC,EAGlB,CAFC,MAAO7J,GACPzL,QAAQe,MAAM,2BAA4ByU,EAC3C,MAIP7B,GAAkB,EAGpB,ECzCI+B,GAAoB,SAEbC,GAAatC,IAAa,wBACrCC,EAAAA,GAAAA,GAAU,CAACoC,GAAmBrC,WADO,QACY,EADZ,EAW1BuC,GAAc,CAACvC,EAAetD,KAAQ,IAAD,EAChD,MAAM8F,EAAM,UAAGF,GAAWtC,UAAd,QAAgC,IAC5CY,EAAAA,GAAAA,GACE,CAACyB,GAAmBrC,GACpBwC,EAAO3B,QAAO4B,GAAKA,EAAE/F,KAAOA,IAF9B,ECFWgG,GAAkB,CAC7B1C,EACA8B,EACAa,KAEA,MAAMH,EAAS,IAAIxU,IACnB,IAAI4U,EAAc,GAClB,MAAM,SAAE3P,EAAF,QAAYmN,IAAYC,EAAAA,EAAAA,MACxBC,EAAmB,IACvBF,EAAQG,YAAY,IAAIiC,EAAOtS,YAAa0S,IAExCC,EAAcC,IAClBN,EAAO3T,IAAIiU,EAAMpG,GAAIoG,GDpBD,EAAC9C,EAAe8C,KAAW,IAAD,EAChD,MAAMN,EAAM,UAAGF,GAAWtC,UAAd,QAAgC,IAC5CY,EAAAA,GAAAA,GACE,CAACyB,GAAmBrC,GACpB,IAAIwC,EAAO3B,QAAO4B,GAAKA,EAAE/F,KAAOoG,EAAMpG,KAAKoG,GAF7C,ECmBEC,CAAI/C,EAAe8C,GACnBxC,GAAkB,EAoBCgB,GAAKtB,GACbuB,SAAQkB,IACF,YAAbA,EAAEO,QACJ7B,GAAOnB,EAAeyC,EAAE/F,IAE1B8F,EAAO3T,IAAI4T,EAAE/F,GAAI,IACZ+F,GADL,IAIFnC,IAqBA,MAnByBjR,WACvB,UAAW,MAAM4T,KAASC,EAAAA,EAAAA,IACxBP,GAEK,OAALM,QAAK,IAALA,GAAAA,EAAO1B,SAAQuB,IACbnW,QAAQM,IAAI,cAAe6V,GAC3B,MAAMK,EAAUL,EAAMpG,GAAG7H,MAAM,KACzBuO,EAAQD,EAAQA,EAAQxU,OAAS,GACnC6T,EAAOjU,IAAI6U,KACbZ,EAAOtB,OAAOkC,GACdjC,GAAOnB,EAAeoD,IAExBR,EAAcK,EACd3C,GAAkB,GAErB,EAEH+C,GAEO,CACLb,SACAvP,WACAqQ,SAAUT,EACVU,YA5CkBlU,UAClB,MAAMyT,EAAQN,EAAOhU,IAAIkO,GAEzB,OADAhM,OAAOoS,EAAQ,mCAAkCpG,KAC1CoF,EAAgBgB,EAAMU,YAA7B,EA0CAC,YAvCkBC,IAClB/W,QAAQM,IAAI,qBAAZ,EAuCA0W,aArDmBjH,IACnB,MAAMoG,EAAQN,EAAOhU,IAAIkO,GACzBhM,OAAOoS,EAAQ,oCAAmCpG,KAClDmG,EAAY,IAAKC,EAAOE,OAAQ,YAChC1C,GAAkB,EA2CpB,EC7EWhB,GAAkB,CAAChB,EAAQsF,EAAsB9F,KAC5D,MAAM,kBACJ+F,EADI,YAEJC,EAFI,aAGJC,EAHI,cAIJC,EAJI,aAKJhM,EALI,cAMJiM,GACEnG,GAEE,MAAEqC,EAAF,QAASyB,EAAT,eAAkBR,EAAlB,WAAkCH,EAAlC,WAA8CI,GAClDyC,EAEInC,EAAahB,GAAWS,EAAe9C,EAAQqC,GAErD,IAAIF,EAAON,EAAM3R,IAAI8P,GACrB,IAAKmC,EAAM,CACT,IAAIe,EACJ,MAAMC,EAAY,IAAI9V,SAAQmG,IAC5B0P,EAAe,KACbH,EAAW/C,GACXxM,GAAK,CAFP,IAMF2O,EAAO,CACL/D,GAAI4B,EACJyC,KAAM,CAAErE,GAAI4B,GACZqC,QAASiD,EACTtF,SACAoC,QAAQ,EACRgB,QAAS,CACPhB,OAAQc,EACRG,aACAT,OAAQ,IAAMD,EAAW3C,IAE3BmD,aAEFG,EAAQnB,EACT,CAED,OAAOxS,EAAAA,GAAAA,IAAI,gBAAiB,CAC1BoB,eAAe6U,GACb,MAAMC,GAAc,IAAIC,MAAOC,UACzB3H,EAAM,GAAEyH,IAad,aAZM1D,EAAKgB,UACXsC,EAAaT,SAAS,CACpB5G,KACA4H,gBAAkB,YAAWJ,EAAOK,wBACpCC,eAAgB,CAAE7F,WAAYL,EAAQA,UACtCyC,KAAM,CACJrE,GAAK,GAAEyH,IACPM,cAAeN,GAEjBnB,OAAQ,cACLkB,IAEExH,CACR,EACDrN,oBAAoBsR,EAASsB,SACrBxB,EAAKgB,UACXuC,EAAc9B,cAAcvB,EAASsB,EACtC,EACD5S,0BAA0BsR,EAASsB,SAC3BxB,EAAKgB,UACX9U,QAAQM,IAAI,6BAA8B0T,EAASsB,EACpD,EACD5S,sBAAsBsR,EAASsB,SACvBxB,EAAKgB,UACX9U,QAAQM,IAAI,yBAA0B0T,EAASsB,EAChD,EACD5S,kBAAA,gBACQoR,EAAKgB,UAEJoC,KAETxU,kBAAA,gBACQoR,EAAKgB,UAEJsC,EAAa9Q,UAEtB5D,gBAAA,gBACQoR,EAAKgB,UACJzJ,GAET3I,aAAA,gBACQoR,EAAKgB,UACJwC,IA9CX,ECvBIS,GAAQ3O,GAAS,GAAEA,IAAO9J,KAAKC,W,gHCPrC,MAAMyY,GACK,EADLA,GAEe,EAFfA,GAGS,EAGTC,GACO,iEAyGb,IAAeC,EAAAA,GAAAA,KAnGS,IAAwD,IAAvD,QAAEC,EAAF,KAAWC,EAAX,QAAiBC,EAAjB,KAA0BC,EAA1B,gBAAgCC,GAAsB,EAC7E,MAAOC,EAAaC,IAAkBC,EAAAA,GAAAA,UAASV,KACxCjX,EAAO4X,IAAYD,EAAAA,GAAAA,UAAS,MA2B7BE,EAAoBhL,IACxB,WAACiL,GAAA,EAAD,YACE,UAACA,GAAA,EAAD,CACEC,GAAI,CACFC,OAAQ,OACRC,QAAS,OACTC,cAAe,MACfC,eAAgB,UALpB,UAQE,UAACC,GAAA,EAAD,OAEF,UAACC,GAAA,EAAD,CAAmBN,GAAI,CAAEO,GAAI,GAA7B,SAAmCzL,OAIjC0L,EAAU,MACd,OAAQd,GACN,KAAKR,GACH,OACE,6BACE,WAACoB,GAAA,EAAD,YACE,2CADF,IACyB,KACvB,UAACG,GAAA,EAAD,CAAMjB,KAAMA,EAAMkB,UAAU,OAAOC,MAAM,mBAAzC,SACGnB,QAGL,WAACc,GAAA,EAAD,CAAmBN,GAAI,CAAEO,GAAI,GAA7B,WACE,4CADF,IAC0BhB,MAE1B,WAACe,GAAA,EAAD,CAAmBN,GAAI,CAAEO,GAAI,GAA7B,kFAEK,wBA/DI,WA6DT,oCAMN,KAAKrB,GACH,OAAOY,EAAkB,4CAC3B,KAAKZ,GACH,OAAOY,EAAkB,qCAC3B,QACE,OAAO,0BAzBG,KA6BhB,OACE,WAACc,GAAA,EAAD,CAAQtB,KAAMA,EAAd,WACE,WAACuB,GAAA,EAAD,WACGnB,IAAgBR,GAAgB,WAAa,WADhD,oBAGA,WAAC4B,GAAA,EAAD,WACGN,EACAvY,IACC,UAACqY,GAAA,EAAD,CAAmBN,GAAI,CAAEO,GAAI,GAAKI,MAAM,UAAxC,SACG1Y,OAINyX,IAAgBR,KACf,WAAC6B,GAAA,EAAD,YACE,UAACC,GAAA,EAAD,CAAQL,MAAM,SAASM,QAAS5B,EAAhC,gCAGA,UAAC2B,GAAA,EAAD,CAAQC,QA3EkB,KAChC,MACEC,SAAS,kBAAEC,IACT1B,EACC0B,EAjBiBvX,WACtBiW,EAAS,MACTF,EAAeT,IACf,UACQkC,EAAOC,iBAKd,CAJC,MAAO1O,GAGP,OAFAgN,EAAeT,SACfW,EAASlN,EAAExK,QAEZ,CACDwX,EAAeT,GAAf,EAYAoC,CAAgBH,GAJdtB,EAASV,GAIX,EAkEM,yBAlBR,IAyBqDoC,IAAO,CAC5D9B,gBAAiB8B,EAAQ9B,oBC1GrB+B,GAAQC,GAAAA,YAAiB,WAAuCC,GAAM,IAA9B,SAAEC,KAAaC,GAAc,EACzE,OACE,UAAC,KAAD,CAAUC,UAAW,EAAGH,IAAKA,EAAKI,QAAQ,YAAaF,EAAvD,SACGD,GAGN,IA4ID,IAAevC,EAAAA,GAAAA,KA1Ie,IAMvB,IAAD,QANyB,iBAC7B2C,EAD6B,oBAE7BC,EAF6B,WAG7BC,EAH6B,uBAI7BC,EAJ6B,gBAK7BzC,GACI,EACJ,MAAO0C,EAAkBC,IAAuBxC,EAAAA,GAAAA,UAAS,KAClDyC,EAAqBC,IAA0B1C,EAAAA,GAAAA,WAAS,GAczD2C,EAAY,SAACpa,EAASwK,GAA2B,IAAxB6P,EAAuB,uDAAZ,QACpC7P,IACFzL,QAAQe,MAAO,GAAEE,KAAYwK,GAC7BxK,GAAY,KAAIwK,EAAExK,WAEH,UAAbqa,GACFR,EAAoBS,GAAAA,GAAAA,OAEtBL,GAAoBM,GAAM,IAAIA,EAAI,CAAEF,WAAUra,aAC/C,GAEK,KAAEqX,EAAF,sBAAQmD,GAA0BZ,EAElCxH,EAEFoI,IAA0BC,GAAAA,EAAAA,OAC1BnD,EAEOA,EAAgBF,QACdoD,IAA0BC,GAAAA,EAAAA,UAC5Bb,EAAiBxH,mBADnB,EAMHsI,EAAelQ,IACfA,EAAExK,UAAYuO,GAChB4L,GAAuB,GACvBN,EAAoBS,GAAAA,GAAAA,SAEpBR,EAAW,MACXM,EAAU,0BAA2B5P,GACtC,EA+DH,OA5DAmQ,EAAAA,GAAAA,YAAU,KACR,IACGf,GACAA,EAAiBY,wBAA0BC,GAAAA,EAAAA,QACzCnD,EAEH,OAGF,IAAIsD,EACAC,EA0CJ,MAxCepZ,WACb,MAAM2X,EViJqB,WAAwC,IAAvC0B,EAAuC,uDAAxBhL,GAC/C,MAAMiL,EAAgB,CAEpBC,MAAO,CACLrL,QAAQsL,EAAAA,EAAAA,MACRpL,OAAOoL,EAAAA,EAAAA,OAGTC,QAAS,CACPvL,QAAQsL,EAAAA,EAAAA,MACRpL,OAAOoL,EAAAA,EAAAA,OAGTE,QAAS,CACPxL,QAAQsL,EAAAA,EAAAA,MACRpL,OAAOoL,EAAAA,EAAAA,QAILG,EAAe,CACnBzL,QAAQsL,EAAAA,EAAAA,MACRpL,OAAOoL,EAAAA,EAAAA,OAUHI,EAAa,CAAC5L,EAAOhP,EAAMC,KAC/B,GAAI+O,EAAME,OAAOhP,IAAIF,GACnB,OAAOgP,EAAME,OAAO/O,IAAIH,GAE1B,MAAMiP,EAAMoL,EAAapa,GAEzB,OADA8O,GAAYC,EAAOhP,EAAMiP,GAClBA,CAAP,EAGI4L,EAAY,CAKhBC,UAAW,CAAC9a,EAAMC,KAChBoC,OAAO4L,GAAUjO,GAAOoC,EAAE,kBAAiBoG,GAAExI,MACtC4a,EAAWD,EAAc3a,EAAMC,IAOxC8a,aAAc,CAAC/a,EAAMC,KACnB,IAAKD,EAEH,OAAOqa,EAAc,GAAEra,KAEzB,MAAM,KAAE0H,EAAF,GAAQ2G,GAAOO,GAAgB0L,EAAeta,GACpD,OAAO0H,EACHkT,EAAWN,EAAc5S,GAAO2G,EAAIpO,GACpC4a,EAAUC,UAAU9a,EAAMC,EAF9B,GAME+a,EAAY,CAChBF,UAAW7L,GAAO0L,EAAavL,MAAMjP,IAAI8O,GAEzC8L,aAAc9L,IACZ,MAAMvH,EAAO4G,GAAQgM,GAAexL,GAAKwL,EAAcxL,GAAGM,MAAMlP,IAAI+O,KACpE5M,OAAOqF,EAAMtF,EAAE,iCAAgC6M,KAE/C,MAAMZ,EAAKiM,EAAc5S,GAAM0H,MAAMjP,IAAI8O,GACzC,OAAOd,GAAemM,EAAe5S,EAAM2G,EAA3C,GAIE4M,EAAU,CACdH,WAAWhb,EAAAA,EAAAA,IAAYkb,EAAUF,UAAWD,EAAUC,UAAW,CAC/DI,YAAa,cAEfH,cAAcjb,EAAAA,EAAAA,IAAYkb,EAAUD,aAAcF,EAAUE,aAAc,CACxEG,YAAa,kBAIjB,OAAOjc,OAAO,CAKZkc,YAAa,CAAC9M,EAAIY,KAChBF,GAAY4L,EAActM,EAAIY,EAA9B,EAMFmM,cAAe,CAAC/M,EAAIY,KACd0L,EAAavL,MAAMlP,IAAI+O,GACzB5M,OAAO+G,MAAMuR,EAAavL,MAAMjP,IAAI8O,GAAMZ,GAG5CU,GAAY4L,EAActM,EAAIY,EAA9B,EAEF8L,cAAcnb,EAAAA,EAAAA,IAAI,oBAAqB,IAAKqb,EAAQF,eACpDD,WAAWlb,EAAAA,EAAAA,IAAI,mBAAoB,IAAKqb,EAAQH,aAEnD,CU9PqBO,GACVla,EAAS+C,EAAW0S,GACpB0E,EAAkB7P,GACtBnC,EAAc,cAAamC,IAAQtK,EAAQ,CACzCwI,aAAcgP,EAAQoC,eAEpBtL,EFciC,SAC3C8L,EACAC,EACAra,EACAsa,EACA9J,EACAkF,EACAjB,GAMI,IALJ8F,EAKG,uDALY3R,IAEb,MAAMA,CAAN,EAEF4R,EACG,uDADa,OAEhB,MAAMC,EAAY,CAChBpG,kBAAmB,SACnBqG,oBAAqB,WACrBC,mBAAoB,UACpBC,kBAAmB,SACnBC,oBAAqB,YAIjBC,EAAexN,OAAOyN,YAC1BzN,OAAO0N,QAAQP,GAAWjY,KAAI,QAAEyY,EAASC,GAAX,QAA0B,CACtDA,GACArK,EAAAA,EAAAA,IAAgB,MAFY,KAQ1BmC,EAAS,CAAC,EAWVmI,EAAe,IAAI3c,IAEnB4c,EAAsB,IAAI5c,IAE5Bgc,IACFA,IACAlN,OAAO5M,OAAOoa,GAAc/I,SAAQ,QAAC,QAAEnB,GAAH,SAClCA,EAAQG,YAAY,GADc,IAGpCyJ,OAAgB5b,GAGlB,MAAMyc,EAAe,KACnB,MAAMC,EAAS,GACf,IAAK,MAAOC,EAAOnC,KAAU+B,EAAaH,UACpC5B,EAAMoC,eAAiBpC,EAAMqC,eAC/Bva,OAAOkY,EAAMsC,aAAc,8BAC3BN,EAAoB/b,IAAI+Z,EAAMsC,aAAcH,GAC5CD,EAAOtT,KAAKoR,IAGhB0B,EAAaQ,OAAO1K,QAAQG,YAAYjT,OAAOwd,GAA/C,EAGIK,EAAe9b,gBACb+M,EAAcwN,GACpB,MACM1V,SADuB3E,EAAAA,EAAAA,GAAEqa,GAAiBvZ,qBAChBV,OAAOC,iBAGjCwb,SAFelX,EAASpE,QAELK,MACnBkb,EAASD,EAAUjb,MACzB,IAAK,MAAMyY,KAASyC,EAAOP,OAAQ,CACjCne,QAAQC,MAAM,oBAAqBgc,GACnC,MAAM0C,EAAkBD,EAAOE,OAAOvO,MACpCwO,GAAM5C,EAAMmC,QAAUS,EAAGT,QAE3Bra,OAAO4a,EAAkB,gCAA+B1C,EAAMmC,SAE9D,MAAMU,EAAY,CAChBV,MAAOnC,EAAMmC,MACbC,cAAepC,EAAM8C,QACrBT,aAAcK,EAAgB3K,QAC9BuK,aAAcI,EAAgB3K,QAC9BgL,YAAaL,EAAgBK,aAE/BhB,EAAa9b,IAAI+Z,EAAMmC,MAAOU,EAC/B,CAGD,OAFA9e,QAAQC,MAAM,mBAAoB+d,GAClCE,IACOO,EAAUlU,WAAjB,EAGI0U,EAAevc,UACnB,UAAW,MAAM,MAAEc,KAAW4D,EAAY8V,EAAgB,CACxDlQ,OAAQkS,IACN,CAEF,MAAMC,EAAe3b,EACrB,OAAQ2b,EAAaC,SACnB,IAAK,QAAS,CACZ,MACEC,YAAY,MAAEjB,EAAF,QAASpK,EAAT,YAAkBgL,IAC5BG,EACEG,EAAQtB,EAAanc,IAAIuc,GACzBmB,EAAW,CACfnB,QACAE,aAActK,EACduK,aAAcvK,EACdgL,cACAX,eAAoB,OAALiB,QAAK,IAALA,OAAA,EAAAA,EAAOjB,gBAAiBmB,GAAAA,GAAAA,UAAqBpB,IAE9DJ,EAAa9b,IAAIkc,EAAOmB,GACxBrB,IACA,KACD,CACD,IAAK,UAAW,CAGd,MAAM,cAAEG,GAAkBc,EACpBI,EAAW,IACZvB,EAAanc,IAAIwc,EAAcD,OAClCC,gBACA7a,MAAO6a,EAAc7a,OAEvBwa,EAAa9b,IAAImc,EAAcD,MAAOmB,GACtCrB,IACA,KACD,CACD,IAAK,cAAe,CAClB,MAAM,OAAE7H,GAAW8I,EACnBnf,QAAQM,IAAI,cAAe,CAAE+V,SAAQR,WACrC,MAAM4J,EAAW5J,EAAOQ,EAAOtG,IAC/B,IAAK0P,EAAU,CACbzf,QAAQ0f,KAAK,4CACb,KACD,CACG,UAAWrJ,EACbR,EAAOQ,EAAOtG,IAAM,IACf0P,EACH1P,GAAIsG,EAAOtG,GACXsG,OAAQ,WACRtV,MAAQ,GAAEsV,EAAOtV,SAGC,WAApB0e,EAASpJ,QACT,sBAAuBA,IAEvBR,EAAOQ,EAAOtG,IAAM,IACf0P,EACH1P,GAAIsG,EAAOtG,GACXsG,OAAQ,WAGZsH,EAAa9H,OAAOpC,QAAQG,YAC1BjT,OAAOwP,OAAO5M,OAAOsS,KAEvB,KACD,CACD,QAEE,MAAM7U,MAAO,wBAAuBme,EAAaC,WAGtD,GAGGO,EAAW,IAAMnB,IAAe/d,KAAKwe,GAErCva,EAAQ,KACZib,IAAWxZ,OAAMsF,IACXA,EAAExK,UAAYuO,EAChBtQ,WAAWwF,EAAO,KAElB0Y,EAAa3R,EACd,GALH,EASFkU,IAAWxZ,OAAMsF,IACf2R,EAAa3R,GACTA,EAAExK,UAAYuO,GAChBtQ,WAAWwF,EAAO,IACnB,IAGH,MAAMkb,EAAqBzP,OAAOyN,YAChCzN,OAAO0N,QAAQP,GAAWjY,KAAI,IAA0B,IAAxBwa,EAAQ9B,GAAe,EACrD,MAAM,SAAEzX,GAAaqX,EAAaI,GAClC,MAAO,CAAC8B,EAAQ,IAAMvZ,EAAtB,KAIEwZ,EAAiB,KACrB9f,QAAQM,IAAI,mBAAZ,EAGIyf,EAAa,KACjB/f,QAAQM,IAAI,cAAZ,EAGI0f,EAAY,KAChBhgB,QAAQM,IAAI,aAAZ,EAGI6U,EAAkB/H,IACtB,MACE4M,SAAS,kBAAEC,IACT1B,EACJ,IAAK0B,EACH,MAAM,IAAIjZ,MACR,kEAGJ,OAAOiZ,EAAkBgG,kBAAkB7S,EAA3C,EAGIiK,EAAgBnC,GAAiBC,GACjCgC,EAAc5D,GAAeF,GAC7B+D,EAAerB,GACnB1C,EACA8B,EACAyK,EAAmBnC,sBAEf,YAAE7G,EAAF,aAAeI,EAAf,YAA6BF,GAAgBM,EAI7C8I,EAAkBxd,UACtB,MAAM,GACJqN,EACA6H,sBAAuBuI,EACvBC,iBAAiB,OAAEP,GACnBQ,kBAAkB,KAAEC,EAAF,KAAQC,IACxB1c,EAEE2c,EAAYve,GAChBkO,OAAOyN,YACLzN,OAAO0N,QAAQ5b,GAAKoD,KAAI,QAAEob,GAAI,MAAErC,EAAF,aAASG,EAAT,MAAuB/a,IAA7B,QAA0C,CAChEid,EACA,CACErC,MAAOA,GAASH,EAAoBpc,IAAI0c,GACxC/a,MAAOkd,OAAOld,IAJM,KAQtB2S,EAAQ,CACZpG,IAAI,IAAI0H,MAAOC,UACfiJ,eAAgB,CACdC,OAAQ,WACRT,WACAU,sBAAuBhB,GAEzBiB,SAAU,CACRR,KAAME,EAAUF,GAChBC,KAAMC,EAAUD,KAGd1J,QAAoBjU,EAAAA,EAAAA,GAAEua,GAAY4D,UACtCpgB,OAAO,CACLkf,OAAQ,eACR1J,YAMF6K,OAAQC,UACAre,EAAAA,EAAAA,GAAEua,GAAY4D,UAAUZ,GAE5Be,EAAY,IACbrd,EACH8T,gBAAkB,YAAWsJ,IAC7BpK,YAAahW,KAAKqR,UAAU2E,IAI9B,OAFAO,EAAaT,SAASuK,GACtBrL,EAAO9F,GAAMmR,EACNnR,CAAP,EA2BF,OAxBqBzO,EAAAA,EAAAA,IAAI,yBAA0B,IAC9Cse,EACHuB,iBAAkB,IAAMhK,EAAY7Q,SACpCmX,kBAAmB,IAAMrG,EAAa9Q,SACtC8a,6BAA8B,IAAM/J,EAAc/Q,SAClDsQ,cACAI,eACAF,cACAgJ,iBACAC,aACAC,YACArN,gBAAiB,CAAChB,EAAQsF,IACxBtE,GAAgBhB,EAAQsF,EAAsB,CAC5CE,cACAC,aAAc,IAAKA,EAAcT,SAAUuJ,GAC3Crd,SACAwI,aAAc8R,EACd9J,gBACAgE,gBACAC,mBACGsI,KAKV,CElUoByB,CACbrE,EAAiB,UAAS3J,aAC1B2J,EAAiB,UAAS3J,KAC1BxQ,EACAwX,EAAQmC,UACRnJ,EACAkF,EACAD,EACAqD,GACA,KACEb,EAAoBS,GAAAA,GAAAA,WACpBH,GAAuB,EAAvB,KAGE,UAAEkG,EAAF,OAAaC,GF9FkBC,KAKzC,MAAMC,EAAkB/e,UACtB6T,EAAAA,EAAAA,IAA8BjQ,GAAUtD,OAAOC,kBAEzCqD,SAAUob,IAAqBhO,EAAAA,EAAAA,IACrC/S,OAAO,CACLghB,OAAO/e,EAAAA,EAAAA,GAAE4e,GAAcI,cAkCrBC,EAAclhB,OAAO,CACzBoU,SAASzT,EAAAA,EAAAA,IAAI,gBAAiB,CAC5BwgB,YAAa,SAACC,GAAD,IAAShS,EAAT,uDAAcgI,GAAM,SAApB,OACXnV,EAAAA,EAAAA,GAAE4e,GAAc1B,eAAhB,OAA+BiC,QAA/B,IAA+BA,OAA/B,EAA+BA,EAAQC,cAAejS,EAD3C,EAEbkS,cAAe,SAACC,GAAD,IAAenS,EAAf,uDAAoBgI,GAAM,WAA1B,OACbnV,EAAAA,EAAAA,GAAE4e,GAAczB,WAAWhQ,EAAImS,EADlB,EAEfC,aAAc,SAACJ,GAAD,IAAShS,EAAT,uDAAcgI,GAAM,UAApB,OACZnV,EAAAA,EAAAA,GAAE4e,GAAcxB,UAAUjQ,EAAIgS,GAAQ,EAD1B,IAGhBK,SAAUX,EAAgBC,GAC1BW,SAAUZ,GAAgB7e,EAAAA,EAAAA,GAAE4e,GAAcjE,uBAC1C/J,MAAOiO,GAAgB7e,EAAAA,EAAAA,GAAE4e,GAAcL,oBACvCmB,QAASb,GAAgB7e,EAAAA,EAAAA,GAAE4e,GAAchE,sBACzC3H,QAxCyB0M,EA0CvBd,GAAgB7e,EAAAA,EAAAA,GAAE4e,GAAc/D,qBAzClC9c,OAAO,CACLwC,KAAMT,UACJ,MAAM,KAAEe,EAAF,MAAQD,SAAgBZ,EAAAA,EAAAA,GAAE2f,GAAepf,OAC/C,OAAOxC,OAAO,CACZ8C,OACAD,MACEA,GACAA,EAAM6B,KAAI,QAAC,GAAE0K,KAAOyS,GAAV,SACR7hB,OAAO,CACLoP,QACGyS,EACHzN,SAASzT,EAAAA,EAAAA,IAAI,eAAgB,CAE3B0E,OAAQ,KAAMpD,EAAAA,EAAAA,GAAE4e,GAAc5K,YAAY7G,GAC1C0S,QAAS,KAAM7f,EAAAA,EAAAA,GAAE4e,GAAcxK,aAAajH,GAC5CwR,OAAQ,KAAM3e,EAAAA,EAAAA,GAAE4e,GAAc1K,YAAY/G,MARtC,KAJd,EAkBF2S,OAAQH,EAAcG,OACtBC,MAAOJ,EAAcI,SAqBvBC,SAAUnB,GAAgB7e,EAAAA,EAAAA,GAAE4e,GAAc9D,uBAC1CS,OAAQsD,GAAgB7e,EAAAA,EAAAA,GAAE4e,GAActK,qBACxC2L,kBAAmBpB,GACjB7e,EAAAA,EAAAA,GAAE4e,GAAcJ,kCA/COmB,MAsD3B,MAAQjc,SAAUwc,EAAiBrP,QAASsP,IAC1CrP,EAAAA,EAAAA,IAAgBmO,GAQlB,MAAO,CAAEP,UANSG,EAAgBqB,GAMdvB,OAJL9V,IACbsX,EAAenZ,KAAK6B,EAApB,EAGF,EEckCuX,CAA4B7R,GAK1D,OAJA2K,EAAuB5K,GAAsBC,GAC7C0K,EAAiB0F,EAEjBvG,GAAuB,IAAMW,KACtBsH,EAAAA,EAAAA,IAAgB3B,EAAW,CAChC1N,YAAasP,IACXrH,GAAkBd,EAAWmI,EAA7B,EAEFtZ,KAAM6B,IACJoQ,GAAkBF,EAAalQ,EAA/B,EAEF0X,OAAQD,IACNrH,GAAkBd,EAAWmI,EAA7B,GARJ,EAYFE,GAASjd,OAAMsF,GAAK4P,EAAU,mCAAoC5P,KAE3D,KACLoQ,GAAkBA,IAClBA,OAAiBpa,EACjBqa,GAAwBA,IACxBA,OAAuBra,CAAvB,CAJF,GAMC,CAACoZ,EAAkBtC,KAGpB,6BACE,UAAC8K,GAAA,EAAD,CAAUjL,KAAM6C,EAAiBjZ,OAAS,EAA1C,UACE,UAACsY,GAAD,CACEnC,QA3GoB,CAACmL,EAAGC,KACf,cAAXA,GAIJrI,GAAoBM,GAAMA,EAAGzZ,MAAM,IAAnC,EAuGMuZ,SAAQ,UAAEL,EAAiB,UAAnB,aAAE,EAAqBK,SAC/BxC,GAAI,CAAE0K,MAAO,QAHf,mBAKGvI,EAAiB,UALpB,aAKG,EAAqBha,aAG1B,UAAC,GAAD,CACEmX,KAAM+C,EACNhD,QAxHyB,KAC7BiD,GAAuB,EAAvB,EAwHI/C,QAAShF,EACTiF,KAAMA,MAfZ,IAqB2D+B,IAAO,CAClEQ,iBAAkBR,EAAQQ,iBAC1BC,oBAAqBT,EAAQS,oBAC7BC,WAAYV,EAAQU,WACpBC,uBAAwBX,EAAQW,uBAChCzC,gBAAiB8B,EAAQ9B,mB","sources":["../../../casting/src/defaults.js","../../../casting/src/shuffle.js","../../../casting/src/change-follower.js","../../../casting/src/leader-netconfig.js","../../../casting/src/leader.js","../../../casting/src/iterable.js","../../../casting/src/casting-spec.js","../../../casting/src/follower-cosmjs.js","../../../casting/src/follower.js","../../../smart-wallet/src/utils.js","../../api/src/marshal-contexts.js","util/BridgeStorage.js","store/Dapps.js","service/Dapps.js","service/Issuers.js","store/Offers.js","service/Offers.js","service/ScopedBridge.js","util/WalletBackendAdapter.js","components/ProvisionDialog.jsx","components/SmartWalletConnection.jsx"],"sourcesContent":["// @ts-check\n/* global setTimeout */\nimport { Far } from '@endo/far';\nimport { makeMarshal } from '@endo/marshal';\n\n/**\n * Default to the local chain.\n */\nexport const DEFAULT_BOOTSTRAP = 'http://localhost:26657';\n\nexport const DEFAULT_JITTER_SECONDS = 5;\n\nexport const DEFAULT_POLL_WITH_EVENTS_SECONDS = 600;\n\nexport const DEFAULT_KEEP_POLLING_SECONDS = 5;\n\n/**\n * Resolve a Promise after a given number of milliseconds.\n *\n * SECURITY: closes over setTimeout global\n *\n * @param {number} ms\n * @returns {Promise<void>}\n */\nexport const delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n/**\n * @param {number} range\n * @param {number} [cap]\n */\nexport const randomBackoff = (range, cap = range) => {\n  return Math.random() * Math.min(cap, range);\n};\n\n/**\n * @param {number} [attempt]\n * @param {number} [base]\n * @param {number} [cap]\n */\nexport const exponentialBackoff = (attempt = 0, base = 1_000, cap = 30_000) => {\n  return randomBackoff(2 ** attempt * base, cap);\n};\n\n/**\n * Add a little to the retry delay to avoid a thundering herd.\n *\n * @param {string} where\n * @returns {Promise<void>}\n */\nexport const DEFAULT_JITTER = where => {\n  const jitter = randomBackoff(DEFAULT_JITTER_SECONDS * 1_000);\n  console.debug(`jittering ${where} by ${Math.ceil(jitter)}ms`);\n  return delay(jitter);\n};\n\n/**\n * Report an error, then retry the leader operation after a second or two.\n *\n * @param {string} where\n * @param {any} err\n * @param {number} [attempt]\n * @returns {Promise<void>}\n */\nexport const DEFAULT_RETRY_CALLBACK = (where, err, attempt = 0) => {\n  const backoff = exponentialBackoff(attempt);\n  console.log(\n    `retrying ${where} in ${Math.ceil(backoff)}ms after attempt #${attempt}`,\n    err,\n  );\n  return delay(backoff);\n};\n\n/**\n * Return true after we want to be sure we received latest state something.\n *\n * @returns {Promise<boolean>}\n */\nexport const DEFAULT_KEEP_POLLING = () =>\n  delay(randomBackoff(DEFAULT_KEEP_POLLING_SECONDS * 1_000)).then(() => true);\n\nexport const MAKE_DEFAULT_DECODER = () => {\n  /**\n   * Parse JSON.\n   *\n   * @param {string} str\n   */\n  return harden(str => {\n    try {\n      return harden(JSON.parse(str));\n    } catch (error) {\n      throw new Error(`Cannot decode alleged JSON (${error.message}): ${str}`);\n    }\n  });\n};\n\n/**\n * Unserialize the JSONable data.\n *\n * @type {() => import('./types').Unserializer}\n */\nexport const MAKE_DEFAULT_UNSERIALIZER = () => {\n  const ifaceAllegedPrefix = 'Alleged: ';\n  const ifaceInaccessiblePrefix = 'SEVERED: ';\n  const seen = new Map();\n  const slotToVal = (slot, iface) => {\n    // Private object.\n    if (seen.has(slot)) {\n      return seen.get(slot);\n    }\n    if (typeof iface === 'string' && iface.startsWith(ifaceAllegedPrefix)) {\n      iface = iface.slice(ifaceAllegedPrefix.length);\n    }\n    const obj = Far(`${ifaceInaccessiblePrefix}${iface}`, {});\n    seen.set(slot, obj);\n    return obj;\n  };\n  return Far('marshal unserializer', {\n    unserialize: makeMarshal(undefined, slotToVal).unserialize,\n  });\n};\n","// @ts-check\n\n/**\n * Modern version of Fisher-Yates shuffle algorithm (in-place).\n *\n * @template T\n * @param {Array<T>} a\n */\nexport const shuffle = a => {\n  for (let i = a.length - 1; i > 0; i -= 1) {\n    const j = Math.floor(Math.random() * (i + 1));\n    const x = a[i];\n    a[i] = a[j];\n    a[j] = x;\n  }\n};\n","// @ts-check\nimport { E, Far } from '@endo/far';\nimport { DEFAULT_KEEP_POLLING } from './defaults.js';\n\n/**\n * Just return an unspecified allegedValue every poll period.\n *\n * @param {import('./types').Leader} leader\n * @returns {Promise<import('./types.js').Follower<import('./types').CastingChange>>}\n */\nexport const makePollingChangeFollower = async leader => {\n  const { keepPolling = DEFAULT_KEEP_POLLING } = await E(leader).getOptions();\n\n  const iterable = Far('polling change follower iterable', {\n    [Symbol.asyncIterator]: () => {\n      /** @type {Promise<boolean> | undefined} */\n      let nextPollPromise;\n      return Far('polling change follower iterator', {\n        next: async () => {\n          if (!nextPollPromise) {\n            nextPollPromise = keepPolling('polling change follower').then(\n              cont => {\n                if (cont) {\n                  return E(leader)\n                    .jitter('polling change follower')\n                    .then(() => cont);\n                }\n                return cont;\n              },\n            );\n          }\n          const keepGoing = await nextPollPromise;\n          nextPollPromise = undefined;\n          const change = harden({\n            // Make no warrant as to the values.\n            values: [],\n          });\n          return harden({\n            value: change,\n            done: !keepGoing,\n          });\n        },\n      });\n    },\n  });\n\n  return Far('polling change follower', {\n    getLatestIterable: async () => iterable,\n    getEachIterable: async () => iterable,\n    getReverseIterable: async () => {\n      throw Error('not implemented for polling change follower');\n    },\n  });\n};\n","// @ts-check\n/* global fetch */\nimport { makeRoundRobinLeader } from './leader.js';\nimport {\n  DEFAULT_BOOTSTRAP,\n  DEFAULT_JITTER,\n  DEFAULT_RETRY_CALLBACK,\n} from './defaults.js';\n\nconst { details: X } = assert;\n\n/**\n * @param {string[]} rpcAddrs\n * @param {import('./types.js').LeaderOptions} [leaderOptions]\n * @returns {import('./types.js').Leader}\n */\nexport const makeLeaderFromRpcAddresses = (rpcAddrs, leaderOptions) => {\n  assert(Array.isArray(rpcAddrs), X`rpcAddrs ${rpcAddrs} must be an array`);\n\n  const rpcHrefs = rpcAddrs.map(rpcAddr => {\n    assert.typeof(rpcAddr, 'string', X`rpcAddr ${rpcAddr} must be a string`);\n    // Don't remove explicit port numbers from the URL, because the Cosmos\n    // `--node=xxx` flag requires them (it doesn't just assume that\n    // `--node=https://testnet.rpc.agoric.net` is the same as\n    // `--node=https://testnet.rpc.agoric.net:443`)\n    return rpcAddr.includes('://') ? rpcAddr : `http://${rpcAddr}`;\n  });\n\n  return makeRoundRobinLeader(rpcHrefs, leaderOptions);\n};\n\n/**\n * @param {string} netconfigURL\n * @param {import('./types.js').LeaderOptions} [options]\n */\nexport const makeLeaderFromNetworkConfig = (netconfigURL, options = {}) => {\n  const { retryCallback = DEFAULT_RETRY_CALLBACK, jitter = DEFAULT_JITTER } =\n    options;\n  /** @type {import('./types.js').LeaderOptions['retryCallback']} */\n  const retry = async (where, err, attempt) => {\n    if (retryCallback) {\n      return retryCallback(where, err, attempt);\n    }\n    throw err;\n  };\n  let attempt = 0;\n  const where = 'Network config leader';\n  return new Promise((resolve, reject) => {\n    const makeLeader = async () => {\n      const response = await fetch(netconfigURL, {\n        headers: { accept: 'application/json' },\n      });\n      const { rpcAddrs } = await response.json();\n      // Our part succeeded, so reset the attempt counter.\n      attempt = 0;\n      return makeLeaderFromRpcAddresses(rpcAddrs, options);\n    };\n    const retryLeader = async err => {\n      retry(where, err, attempt)\n        .then(() => jitter(where))\n        .then(() => makeLeader().then(resolve, retryLeader))\n        .catch(reject);\n      attempt += 1;\n    };\n    makeLeader().then(resolve, retryLeader);\n  });\n};\n\n/**\n * @param {string} [bootstrap]\n * @param {import('./types.js').LeaderOptions} [options]\n * @returns {ERef<import('./types.js').Leader>}\n */\nexport const makeLeader = (bootstrap = DEFAULT_BOOTSTRAP, options) => {\n  if (bootstrap.includes('network-config')) {\n    return makeLeaderFromNetworkConfig(bootstrap, options);\n  }\n  return makeLeaderFromRpcAddresses([bootstrap], options);\n};\n/** @typedef {ReturnType<typeof makeLeader>} Leader */\n","// @ts-check\nimport { E, Far } from '@endo/far';\nimport { DEFAULT_RETRY_CALLBACK, DEFAULT_JITTER } from './defaults.js';\nimport { shuffle } from './shuffle.js';\nimport { makePollingChangeFollower } from './change-follower.js';\n\n/**\n * Create a chain leader that rotates through a list of endpoints.\n *\n * @param {string[]} endpoints\n * @param {import('./types.js').LeaderOptions} leaderOptions\n */\nexport const makeRoundRobinLeader = (endpoints, leaderOptions = {}) => {\n  const { retryCallback = DEFAULT_RETRY_CALLBACK, jitter = DEFAULT_JITTER } =\n    leaderOptions;\n\n  // Shuffle the RPC addresses, so that we don't always hit the same one as all\n  // our peers.\n  shuffle(endpoints);\n\n  let lastRespondingEndpointIndex = 0;\n  let thisAttempt = 0;\n  let retrying;\n\n  /** @type {import('./types.js').Leader} */\n  const leader = Far('round robin leader', {\n    getOptions: () => leaderOptions,\n    jitter: async where => jitter && jitter(where),\n    retry: async (where, err, attempt) => {\n      if (retryCallback) {\n        return retryCallback(where, err, attempt);\n      }\n      throw err;\n    },\n    // eslint-disable-next-line no-use-before-define\n    watchCasting: _castingSpecP => pollingChangeFollower,\n    /**\n     * @template T\n     * @param {string} where\n     * @param {(endpoint: string) => Promise<T>} callback\n     */\n    mapEndpoints: async (where, callback) => {\n      where = `${where} (round-robin endpoints)`;\n      /** @type {Promise<T[]>} */\n      const p = new Promise((resolve, reject) => {\n        let endpointIndex = lastRespondingEndpointIndex;\n\n        const retry = err => {\n          if (!retrying) {\n            const attempt = thisAttempt;\n            retrying = E(leader)\n              .retry(where, err, attempt)\n              .then(() => {\n                endpointIndex = (endpointIndex + 1) % endpoints.length;\n                retrying = null;\n              });\n          }\n\n          retrying\n            .then(() => jitter && jitter(where))\n            // eslint-disable-next-line no-use-before-define\n            .then(applyOne, reject);\n          thisAttempt += 1;\n        };\n\n        const applyOne = () => {\n          Promise.resolve()\n            .then(() => callback(endpoints[endpointIndex]))\n            .then(res => {\n              resolve(harden([res]));\n              lastRespondingEndpointIndex = endpointIndex;\n              thisAttempt = 0;\n            }, retry);\n\n          // Don't return to prevent a promise chain.\n        };\n\n        applyOne();\n      });\n      return p;\n    },\n  });\n\n  const pollingChangeFollower = makePollingChangeFollower(leader);\n  return leader;\n};\n","// @ts-check\nimport { E, Far } from '@endo/far';\nimport { makeNotifier } from '@agoric/notifier';\n\n/**\n * @template T\n * @param {ERef<Notifier<T>>} notifier\n * @returns {ConsistentAsyncIterable<T>}\n */\nexport const makeNotifierIterable = notifier =>\n  makeNotifier(E(notifier).getSharableNotifierInternals());\n\n/**\n * TODO: Remove this function when we have `makePublisherKit`.\n *\n * @template T\n * @param {ERef<PublicationRecord<T>>} tailP\n * @returns {AsyncIterator<T>}\n */\nconst makeSubscriptionIterator = tailP => {\n  // To understand the implementation, start with\n  // https://web.archive.org/web/20160404122250/http://wiki.ecmascript.org/doku.php?id=strawman:concurrency#infinite_queue\n  return Far('SubscriptionIterator', {\n    next: async () => {\n      const resultP = E.get(tailP).head;\n      tailP = E.get(tailP).tail;\n      return resultP;\n    },\n  });\n};\n\n/**\n * TODO: Remove this function when we have `makePublisherKit`.\n *\n * @template T\n * @param {ERef<Subscription<T>>} subscription\n * @returns {ConsistentAsyncIterable<T>}\n */\nexport const makeSubscriptionIterable = subscription =>\n  harden({\n    [Symbol.asyncIterator]: () =>\n      makeSubscriptionIterator(\n        E(subscription).getSharableSubscriptionInternals(),\n      ),\n  });\n\n/**\n * @template TIn\n * @template TOut\n * @param {AsyncIterable<TIn>} iterable\n * @param {(value: TIn) => TOut} transform\n * @returns {AsyncIterable<TOut>}\n */\nexport const mapAsyncIterable = (iterable, transform) => {\n  async function* transformGenerator() {\n    for await (const value of iterable) {\n      yield transform(value);\n    }\n  }\n  return transformGenerator();\n};\n\n/**\n * TODO: Remove this function when we have `makePublisherKit`.\n *\n * @template T\n * @param {ERef<import('./types').Follower<T>>} follower\n */\nexport const iterateLatest = follower =>\n  // For now, just pass through the iterable.\n  Far('iterateLatest iterable', {\n    /** @returns {AsyncIterator<T>} */\n    [Symbol.asyncIterator]: () => {\n      const latestIterable = E(follower).getLatestIterable();\n      const iterator = E(latestIterable)[Symbol.asyncIterator]();\n      return Far('iterateLatest iterator', {\n        next: () => E(iterator).next(),\n      });\n    },\n  });\n\n/**\n * TODO: Remove this function when we have `makePublisherKit`.\n *\n * @template T\n * @param {ERef<import('./types.js').Follower<T>>} follower\n * @param {import('./types.js').IterateEachOptions} [options]\n */\nexport const iterateEach = (follower, options) =>\n  // For now, just pass through the iterable.\n  Far('iterateEach iterable', {\n    /** @returns {AsyncIterator<T>} */\n    [Symbol.asyncIterator]: () => {\n      const eachIterable = E(follower).getEachIterable(options);\n      const iterator = E(eachIterable)[Symbol.asyncIterator]();\n      return Far('iterateEach iterator', {\n        next: () => E(iterator).next(),\n      });\n    },\n  });\n\n/**\n * @template T\n * @param {ERef<import('./types.js').Follower<T>>} follower\n * @param {import('./types.js').IterateEachOptions} [options]\n */\nexport const iterateReverse = (follower, options) =>\n  // For now, just pass through the iterable.\n  Far('iterateReverse iterable', {\n    /** @returns {AsyncIterator<T>} */\n    [Symbol.asyncIterator]: () => {\n      const eachIterable = E(follower).getReverseIterable(options);\n      const iterator = E(eachIterable)[Symbol.asyncIterator]();\n      return Far('iterateEach iterator', {\n        next: () => E(iterator).next(),\n      });\n    },\n  });\n","// @ts-check\nimport * as encodingStar from '@cosmjs/encoding';\nimport { E, getInterfaceOf } from '@endo/far';\n\nimport './types.js';\n\nconst { toAscii } = encodingStar;\n\n/**\n * @param {string} storagePath\n * @returns {import('./types').CastingSpec}\n */\nconst swingsetPathToCastingSpec = storagePath =>\n  harden({\n    storeName: 'swingset',\n    storeSubkey: toAscii(`swingset/data:${storagePath}`),\n  });\n\nconst PATH_SEPARATOR_BYTE = '.'.charCodeAt(0);\nconst DATA_PREFIX_BYTES = new Uint8Array([0]);\n\n/**\n * @param {string} storagePath\n * @param {string} [storeName]\n * @returns {import('./types').CastingSpec}\n */\nconst vstoragePathToCastingSpec = (storagePath, storeName = 'vstorage') => {\n  const elems = storagePath ? storagePath.split('.') : [];\n  const buf = toAscii(`${elems.length}.${storagePath}`);\n  return harden({\n    storeName,\n    storeSubkey: buf.map(b => (b === PATH_SEPARATOR_BYTE ? 0 : b)),\n    dataPrefixBytes: DATA_PREFIX_BYTES,\n  });\n};\n\nexport const DEFAULT_PATH_CONVERTER = vstoragePathToCastingSpec;\n\n/**\n * @type {Record<string, (path: string) => import('./types').CastingSpec>}\n */\nexport const pathPrefixToConverters = harden({\n  'swingset:': swingsetPathToCastingSpec,\n  'vstore:': vstoragePathToCastingSpec,\n  ':': DEFAULT_PATH_CONVERTER,\n});\n\n/**\n * @param {string} specString\n * @returns {import('./types').CastingSpec}\n */\nexport const makeCastingSpecFromString = specString => {\n  assert.typeof(specString, 'string');\n  const match = specString.match(/^([^:.]*:)(.*)/);\n  assert(\n    match,\n    `spec string ${specString} does not match 'PREFIX:PATH' or ':PATH'`,\n  );\n  const kind = match[1];\n  const storePath = match[2];\n  const converter = pathPrefixToConverters[kind];\n  assert(converter, `Unknown pathKind ${kind}`);\n  return converter(storePath);\n};\n\nconst te = new TextEncoder();\n\n/**\n * @param {any} specObj\n * @returns {import('./types').CastingSpec}\n */\nexport const makeCastingSpecFromObject = specObj => {\n  const { storeName, storeSubkey, dataPrefixBytes, subscription, notifier } =\n    specObj;\n  if (subscription || notifier) {\n    return harden({\n      subscription,\n      notifier,\n    });\n  }\n  let subkey = storeSubkey;\n  if (typeof storeSubkey === 'string') {\n    subkey = te.encode(storeSubkey);\n  }\n  let dataPrefix = dataPrefixBytes;\n  if (typeof dataPrefixBytes === 'string') {\n    dataPrefix = te.encode(dataPrefixBytes);\n  }\n  return harden({\n    storeName,\n    storeSubkey: subkey,\n    dataPrefixBytes: dataPrefix,\n  });\n};\n\n/**\n * @param {ERef<any>} specCap\n * @returns {Promise<import('./types').CastingSpec>}\n */\nexport const makeCastingSpecFromRef = async specCap => {\n  const specObj = await E(specCap).getStoreKey();\n  return makeCastingSpecFromObject(specObj);\n};\n\n/**\n * Create an abstract type from a given source representation\n *\n * @param {ERef<unknown>} sourceP\n * @returns {Promise<import('./types').CastingSpec>}\n */\nexport const makeCastingSpec = async sourceP => {\n  const spec = await sourceP;\n  if (typeof spec === 'string') {\n    return makeCastingSpecFromString(spec);\n  }\n  // @ts-expect-error type detection\n  const { storeName, subscription, notifier } = spec;\n  if (storeName || subscription || notifier) {\n    return makeCastingSpecFromObject(spec);\n  }\n  if (getInterfaceOf(spec)) {\n    return makeCastingSpecFromRef(spec);\n  }\n  assert.fail(`CastingSpec ${spec} is not a string, object, or ref`);\n};\n/** @typedef {ReturnType<typeof makeCastingSpec>} CastingSpec */\n","// @ts-check\n/// <reference types=\"ses\"/>\n/* eslint-disable no-await-in-loop, no-continue, @jessie.js/no-nested-await */\n\nimport { E, Far } from '@endo/far';\nimport * as tendermintRpcStar from '@cosmjs/tendermint-rpc';\nimport * as stargateStar from '@cosmjs/stargate';\n\nimport { MAKE_DEFAULT_DECODER, MAKE_DEFAULT_UNSERIALIZER } from './defaults.js';\nimport { makeCastingSpec } from './casting-spec.js';\nimport { makeLeader as defaultMakeLeader } from './leader-netconfig.js';\n\nconst { QueryClient } = stargateStar;\nconst { Tendermint34Client } = tendermintRpcStar;\nconst { details: X, quote: q } = assert;\nconst textDecoder = new TextDecoder();\n\n/** @template T @typedef {import('./types.js').StreamCell<T>} StreamCell */\n/** @template T @typedef {import('./types.js').ValueFollowerElement<T>} ValueFollowerElement */\n/** @template T @typedef {import('./types.js').Follower<ValueFollowerElement<T>>} ValueFollower */\n\n/**\n * This is an imperfect heuristic to navigate the migration from value cells to\n * stream cells.\n * At time of writing, no legacy cells have the same shape as a stream cell,\n * and we do not intend to create any more legacy value cells.\n *\n * @param {any} cell\n */\nconst isStreamCell = cell =>\n  cell &&\n  typeof cell === 'object' &&\n  Array.isArray(cell.values) &&\n  typeof cell.blockHeight === 'string' &&\n  /^0$|^[1-9][0-9]*$/.test(cell.blockHeight);\n\n/**\n * @param {Uint8Array} a\n * @param {Uint8Array} b\n */\nconst arrayEqual = (a, b) => {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i += 1) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst defaultDataPrefixBytes = new Uint8Array();\n\n/**\n * @template T\n * @param {Iterable<T>} values\n * @returns {T}\n */\nconst collectSingle = values => {\n  /** @type {T[]} */\n  const head = [];\n  let count = 0;\n  for (const value of values) {\n    count += 1;\n    if (count === 1) {\n      head.push(value);\n    } else {\n      assert.fail(`expected single value, got at least ${count}`);\n    }\n  }\n\n  assert.equal(head.length, 1, 'expected single value');\n  return head[0];\n};\n\n// Coordinate with switch/case of tryGetDataAtHeight.\nconst proofs = ['strict', 'none', 'optimistic'];\n\n/**\n * @template T\n * @param {any} sourceP\n * @param {import('./types').LeaderOrMaker} [leaderOrMaker]\n * @param {import('./types').FollowerOptions} [options]\n * @returns {ValueFollower<T>}\n */\nexport const makeCosmjsFollower = (\n  sourceP,\n  leaderOrMaker = defaultMakeLeader,\n  options = {},\n) => {\n  const {\n    decode = MAKE_DEFAULT_DECODER(),\n    unserializer = MAKE_DEFAULT_UNSERIALIZER(),\n    proof = 'optimistic',\n    crasher = null,\n  } = options;\n\n  /**\n   * @param {any} err\n   */\n  const crash = err => {\n    if (crasher) {\n      E(crasher)\n        .crash(`PROOF VERIFICATION FAILURE; crashing follower`, err)\n        .catch(e => assert.fail(X`crashing follower failed: ${e}`));\n    }\n    throw err;\n  };\n\n  assert(proofs.includes(proof), X`unrecognized follower proof mode ${proof}`);\n\n  const where = 'CosmJS follower';\n  const castingSpecP = makeCastingSpec(sourceP);\n\n  const leader =\n    typeof leaderOrMaker === 'function' ? leaderOrMaker() : leaderOrMaker;\n\n  const tendermintClientPs = new Map();\n  /**\n   * @param {string} endpoint\n   * @returns {tendermintRpcStar.Tendermint34Client}\n   */\n  const provideTendermintClient = endpoint => {\n    let clientP = tendermintClientPs.get(endpoint);\n    if (!clientP) {\n      clientP = Tendermint34Client.connect(endpoint);\n      tendermintClientPs.set(endpoint, clientP);\n    }\n    return clientP;\n  };\n\n  const getBlockHeight = async () => {\n    const values = await E(leader).mapEndpoints(where, async endpoint => {\n      const client = await provideTendermintClient(endpoint);\n      const info = await client.abciInfo();\n      const { lastBlockHeight } = info;\n      assert.typeof(lastBlockHeight, 'number');\n      return lastBlockHeight;\n    });\n    return collectSingle(values);\n  };\n\n  /** @type {Map<string, import('@cosmjs/stargate').QueryClient>} */\n  const endpointToQueryClient = new Map();\n\n  /**\n   * @param {string} endpoint\n   */\n  const provideQueryClient = async endpoint => {\n    if (endpointToQueryClient.has(endpoint)) {\n      // Cache hit.\n      const queryClient = endpointToQueryClient.get(endpoint);\n      assert(queryClient);\n      return queryClient;\n    }\n    // Create a new client.  They retry automatically.\n    const rpcClient = await provideTendermintClient(endpoint);\n    const queryClient = QueryClient.withExtensions(rpcClient);\n    endpointToQueryClient.set(endpoint, queryClient);\n    return queryClient;\n  };\n\n  /**\n   * @param {(endpoint: string, storeName: string, storeSubkey: Uint8Array) => Promise<Uint8Array>} tryGetPrefixedData\n   */\n  const retryGetDataAndStripPrefix = async tryGetPrefixedData => {\n    const {\n      storeName,\n      storeSubkey,\n      dataPrefixBytes = defaultDataPrefixBytes,\n    } = await castingSpecP;\n\n    assert.typeof(\n      storeName,\n      'string',\n      X`storeName must be a string, got ${storeName}`,\n    );\n    assert(\n      storeSubkey,\n      X`storeSubkey must be a Uint8Array, got ${storeSubkey}`,\n    );\n\n    // mapEndpoints is our retry loop.\n    const values = await E(leader).mapEndpoints(where, async endpoint =>\n      tryGetPrefixedData(endpoint, storeName, storeSubkey).then(\n        result => {\n          return { result, error: null };\n        },\n        error => {\n          return { result: null, error };\n        },\n      ),\n    );\n\n    const { result, error } = collectSingle(values);\n    if (error !== null) {\n      throw error;\n    }\n    assert(result);\n\n    if (result.length === 0) {\n      // No data.\n      return result;\n    }\n\n    // Handle the data prefix if any.\n    assert(\n      result.length >= dataPrefixBytes.length,\n      X`result too short for data prefix ${dataPrefixBytes}`,\n    );\n    assert(\n      arrayEqual(result.subarray(0, dataPrefixBytes.length), dataPrefixBytes),\n      X`${result} doesn't start with data prefix ${dataPrefixBytes}`,\n    );\n    return result.slice(dataPrefixBytes.length);\n  };\n\n  /**\n   * @param {number} [height]\n   * @returns {Promise<Uint8Array>}\n   */\n  const getProvenDataAtHeight = async height => {\n    return retryGetDataAndStripPrefix(\n      async (endpoint, storeName, storeSubkey) => {\n        const queryClient = await provideQueryClient(endpoint);\n        return E(queryClient).queryVerified(storeName, storeSubkey, height);\n      },\n    );\n  };\n\n  /**\n   * @param {number} height\n   */\n  const getUnprovenDataAtHeight = async height => {\n    return retryGetDataAndStripPrefix(\n      async (endpoint, storeName, storeSubkey) => {\n        const client = await provideTendermintClient(endpoint);\n        const response = await client.abciQuery({\n          path: `store/${storeName}/key`,\n          data: storeSubkey,\n          height,\n          prove: false,\n        });\n        if (response.code !== 0) {\n          throw new Error(`Tendermint ABCI query failed: ${response.log}`);\n        }\n        const { value } = response;\n        return value;\n      },\n    );\n  };\n\n  /**\n   * @param {number} blockHeight\n   */\n  const tryGetDataAtHeight = async blockHeight => {\n    if (proof === 'strict') {\n      // Crash hard if we can't prove.\n      return getProvenDataAtHeight(blockHeight).catch(crash);\n    } else if (proof === 'none') {\n      // Fast and loose.\n      return getUnprovenDataAtHeight(blockHeight);\n    } else if (proof === 'optimistic') {\n      const allegedData = await getUnprovenDataAtHeight(blockHeight);\n\n      // Prove later, since it may take time we say we can't afford.\n      getProvenDataAtHeight(blockHeight).then(provenData => {\n        if (arrayEqual(provenData, allegedData)) {\n          return;\n        }\n        crash(\n          assert.error(\n            X`Alleged value ${allegedData} did not match proof ${provenData}`,\n          ),\n        );\n      }, crash);\n\n      // Speculate that we got the right value.\n      return allegedData;\n    }\n\n    assert.fail(\n      X`Unrecognized proof option ${q(\n        proof,\n      )}, must be one of strict, none, or optimistic`,\n    );\n  };\n\n  /**\n   * @param {number} blockHeight\n   */\n  const getDataAtHeight = async blockHeight => {\n    assert.typeof(blockHeight, 'number');\n    for (let attempt = 0; ; attempt += 1) {\n      try {\n        // AWAIT\n        return await tryGetDataAtHeight(blockHeight);\n      } catch (error) {\n        // We expect occasionally to see an error here if the chain has not\n        // reached the requested blockHeight.\n        await E(leader).retry(where, error, attempt);\n        continue;\n      }\n    }\n  };\n\n  /**\n   * @param {number} blockHeight\n   * @param {Uint8Array} data\n   */\n  const streamCellForData = (blockHeight, data) => {\n    const text = textDecoder.decode(data);\n    try {\n      const cell = JSON.parse(text);\n      if (isStreamCell(cell)) {\n        return harden({\n          blockHeight: Number(cell.blockHeight),\n          values: cell.values.map(decode),\n        });\n      }\n\n      // This is JSON but not the shape of a stream cell.\n      // Fall through...\n    } catch {\n      // This is not even JSON, so it must be a legacy value cell.\n      // Fall through...\n    }\n\n    // Coerce legacy value cells to stream cells at their given height.\n    // Since this is either the first iteration or the data varies bytewise\n    // from the data on the previous block, we can assume the blockHeight is\n    // the current block.\n    return harden({\n      blockHeight,\n      values: [decode(text)],\n    });\n  };\n\n  /**\n   * @param {any} data\n   * @param {number} blockHeight\n   * @param {number} currentBlockHeight\n   * @returns {Promise<ValueFollowerElement<T>>}\n   */\n  const followerElementFromStreamCellValue = async (\n    data,\n    blockHeight,\n    currentBlockHeight,\n  ) => {\n    // AWAIT\n    const value = await /** @type {T} */ (\n      unserializer ? E(unserializer).unserialize(data) : data\n    );\n    return { value, blockHeight, currentBlockHeight };\n  };\n\n  /**\n   * @param {StreamCell<T>} streamCell\n   * @param {number} currentBlockHeight\n   * @yields {ValueFollowerElement<T>}\n   */\n  function* allValuesFromCell(streamCell, currentBlockHeight) {\n    for (const data of streamCell.values) {\n      yield followerElementFromStreamCellValue(\n        data,\n        streamCell.blockHeight,\n        currentBlockHeight,\n      );\n    }\n  }\n\n  /**\n   * @param {StreamCell<T>} streamCell\n   * @param {number} currentBlockHeight\n   * @yields {ValueFollowerElement<T>}\n   */\n  function* reverseValuesFromCell(streamCell, currentBlockHeight) {\n    for (let i = streamCell.values.length - 1; i >= 0; i -= 1) {\n      yield followerElementFromStreamCellValue(\n        streamCell.values[i],\n        streamCell.blockHeight,\n        currentBlockHeight,\n      );\n    }\n  }\n\n  /**\n   * @param {StreamCell<T>} streamCell\n   * @param {number} currentBlockHeight\n   * @yields {ValueFollowerElement<T>}\n   */\n  function* lastValueFromCell(streamCell, currentBlockHeight) {\n    const { values } = streamCell;\n    if (values.length > 0) {\n      const last = values[values.length - 1];\n      yield followerElementFromStreamCellValue(\n        last,\n        streamCell.blockHeight,\n        currentBlockHeight,\n      );\n    }\n  }\n\n  /**\n   * @yields {ValueFollowerElement<T>}\n   */\n  async function* getLatestIterable() {\n    let blockHeight;\n    let data;\n    for (;;) {\n      const currentBlockHeight = await getBlockHeight();\n      if (currentBlockHeight === blockHeight) {\n        // TODO Long-poll for next block\n        // https://github.com/Agoric/agoric-sdk/issues/6154\n        await E(leader).jitter(where);\n        continue;\n      }\n\n      const currentData = await getDataAtHeight(currentBlockHeight);\n      if (currentData.length === 0) {\n        // TODO Long-poll for block data change\n        // https://github.com/Agoric/agoric-sdk/issues/6154\n        await E(leader).jitter(where);\n        continue;\n      }\n      const currentStreamCell = streamCellForData(\n        currentBlockHeight,\n        currentData,\n      );\n\n      blockHeight = currentBlockHeight;\n\n      // Ignore adjacent duplicates.\n      // This can only occur for legacy cells.\n      // It is possible that the data changed from and back to the last\n      // sampled data, but ignoring intermediate changes is consistent with\n      // the semantics of getLatestIterable.\n      if (data !== undefined && arrayEqual(data, currentData)) {\n        continue;\n      }\n      // However, streamCells that vacillate will reemit, since each iteration\n      // at a unique block height is considered distinct.\n\n      yield* lastValueFromCell(currentStreamCell, currentBlockHeight);\n      data = currentData;\n    }\n  }\n\n  /**\n   * @param {number} cursorBlockHeight\n   * @yields {ValueFollowerElement<T>}\n   */\n  async function* getEachIterableAtHeight(cursorBlockHeight) {\n    assert.typeof(cursorBlockHeight, 'number');\n    // Track the data for the last emitted cell (the cell at the\n    // cursorBlockHeight) so we know not to emit duplicates\n    // of that cell.\n    let cursorData;\n    // Initially yield *all* the values that were most recently stored in a\n    // block.\n    // If the block has no corresponding data, wait for the first block to\n    // contain data.\n    for (;;) {\n      cursorData = await getDataAtHeight(cursorBlockHeight);\n      if (cursorData.length !== 0) {\n        const cursorStreamCell = streamCellForData(\n          cursorBlockHeight,\n          cursorData,\n        );\n        yield* allValuesFromCell(cursorStreamCell, cursorBlockHeight);\n        break;\n      }\n      // TODO Long-poll for next block\n      // https://github.com/Agoric/agoric-sdk/issues/6154\n      await E(leader).jitter(where);\n      cursorBlockHeight = await getBlockHeight();\n    }\n\n    // For each subsequent iteration, yield every value that has been\n    // published since the last iteration and advance the cursor.\n    for (;;) {\n      const currentBlockHeight = await getBlockHeight();\n      // Wait until the chain has added at least one block.\n      if (currentBlockHeight <= cursorBlockHeight) {\n        // TODO Long-poll for next block\n        // https://github.com/Agoric/agoric-sdk/issues/6154\n        await E(leader).jitter(where);\n        continue;\n      }\n\n      // Scan backward for all changes since the last observed block and yield\n      // them in forward order.\n      // Stream cells allow us to skip blocks that did not change.\n      // We walk backward through all blocks with legacy cells, only yielding\n      // the value for cells that changed.\n      // This does imply accumulating a potentially large number of values if\n      // the eachIterable gets sampled infrequently.\n      let rightBlockHeight = currentBlockHeight;\n      let rightData = await getDataAtHeight(rightBlockHeight);\n      if (rightData.length === 0) {\n        // TODO Long-poll for next block\n        // https://github.com/Agoric/agoric-sdk/issues/6154\n        await E(leader).jitter(where);\n        continue;\n      }\n      let rightStreamCell = streamCellForData(rightBlockHeight, rightData);\n\n      // Compare block cell data pairwise (left, right) and accumulate\n      // a stack of each cell we encounter.\n      const currentData = rightData;\n      const cells = [];\n      while (rightBlockHeight > cursorBlockHeight) {\n        if (rightStreamCell.blockHeight > rightBlockHeight) {\n          const { storeName, storeSubkey } = await castingSpecP;\n          throw new Error(\n            `Corrupt storage cell for ${storeName} under key ${storeSubkey} at block-height ${rightBlockHeight} claims to being published at a later block height ${rightStreamCell.blockHeight}`,\n          );\n        }\n        const leftBlockHeight = rightStreamCell.blockHeight - 1;\n        // Do not scan behind the cusor.\n        if (leftBlockHeight <= cursorBlockHeight) {\n          break;\n        }\n        const leftData = await getDataAtHeight(leftBlockHeight);\n        // Do not scan behind a cell with no data.\n        // This should not happen but can be tolerated.\n        if (leftData.length === 0) {\n          break;\n        }\n        const leftStreamCell = streamCellForData(leftBlockHeight, leftData);\n\n        // Stream cells include a block height that is guaranteed to change\n        // between iterations even if the values are identical.\n        // We can rely on this difference to ensure that we yield\n        // every iteration, including duplicates.\n        // Legacy cells do not contain a block height to distingish versions,\n        // so we simply assume that the value must change between iterations\n        // for a cell to be worthy of notice.\n        if (!arrayEqual(leftData, rightData)) {\n          cells.push(rightStreamCell);\n        }\n\n        // Prepare for next iteration by moving left to right.\n        rightData = leftData;\n        rightStreamCell = leftStreamCell;\n        rightBlockHeight = leftBlockHeight;\n      }\n\n      // At the end of a sequence of identical value cells, we emit the value\n      // only if it differs from the last reported cell.\n      if (!arrayEqual(rightData, cursorData)) {\n        cells.push(rightStreamCell);\n      }\n\n      // Yield collected cells in forward order.\n      // They were collected by scanning blocks backward.\n      for (;;) {\n        const cell = cells.pop();\n        if (cell === undefined) {\n          break;\n        }\n        yield* allValuesFromCell(cell, currentBlockHeight);\n      }\n\n      // Advance the cursor.\n      cursorBlockHeight = currentBlockHeight;\n      cursorData = currentData;\n    }\n  }\n\n  /**\n   * @param {number} cursorBlockHeight\n   * @yields {ValueFollowerElement<T>}\n   */\n  async function* getReverseIterableAtHeight(cursorBlockHeight) {\n    // Track the data for the last emitted cell (the cell at the\n    // cursorBlockHeight) so we know not to emit duplicates\n    // of that cell.\n    let cursorData;\n    while (cursorBlockHeight > 0) {\n      cursorData = await getDataAtHeight(cursorBlockHeight);\n      if (cursorData.length === 0) {\n        // No data at the cursor height, so signal beginning of stream.\n        return;\n      }\n      const cursorStreamCell = streamCellForData(cursorBlockHeight, cursorData);\n      yield* reverseValuesFromCell(cursorStreamCell, cursorBlockHeight);\n      cursorBlockHeight = cursorStreamCell.blockHeight - 1;\n    }\n  }\n\n  /** @type {ValueFollower<T>} */\n  return Far('chain follower', {\n    async getLatestIterable() {\n      return getLatestIterable();\n    },\n    async getEachIterable({ height = undefined } = {}) {\n      if (height === undefined) {\n        height = await getBlockHeight();\n      }\n      return getEachIterableAtHeight(height);\n    },\n    async getReverseIterable({ height = undefined } = {}) {\n      if (height === undefined) {\n        height = await getBlockHeight();\n      }\n      return getReverseIterableAtHeight(height);\n    },\n  });\n};\n","// @ts-check\n\nimport { Far } from '@endo/far';\nimport {\n  mapAsyncIterable,\n  makeNotifierIterable,\n  makeSubscriptionIterable,\n} from './iterable.js';\nimport { makeCosmjsFollower } from './follower-cosmjs.js';\nimport { makeCastingSpec } from './casting-spec.js';\n\n/**\n * @template T\n * @param {ERef<import('./types').CastingSpec>} spec\n */\nconst makeSubscriptionFollower = spec => {\n  const transform = value =>\n    harden({ value, blockHeight: NaN, currentBlockHeight: NaN });\n  /** @type {import('./types').Follower<import('./types.js').ValueFollowerElement<T>>} */\n  const follower = Far('subscription/notifier follower', {\n    getLatestIterable: async () => {\n      const { notifier, subscription } = await spec;\n      let ai;\n      if (notifier) {\n        ai = makeNotifierIterable(notifier);\n      } else {\n        assert(subscription);\n        ai = makeSubscriptionIterable(subscription);\n      }\n      return mapAsyncIterable(ai, transform);\n    },\n\n    getEachIterable: async () => {\n      const { notifier, subscription } = await spec;\n      let ai;\n      if (subscription) {\n        ai = makeSubscriptionIterable(subscription);\n      } else {\n        assert(notifier);\n        ai = makeNotifierIterable(notifier);\n      }\n      return mapAsyncIterable(ai, transform);\n    },\n\n    getReverseIterable: async () => {\n      throw Error(\n        'reverse iteration not implemented for subscription follower',\n      );\n    },\n  });\n  return follower;\n};\n\n/**\n * @template T\n * @param {ERef<import('./types').CastingSpec> | string} specP\n * @param {import('./types').LeaderOrMaker} [leaderOrMaker]\n * @param {import('./types').FollowerOptions} [options]\n * @returns {Promise<import('./follower-cosmjs').ValueFollower<T>>}\n */\nexport const makeFollower = async (specP, leaderOrMaker, options) => {\n  const spec = await makeCastingSpec(specP);\n  const { storeName } = spec;\n  if (storeName) {\n    return makeCosmjsFollower(spec, leaderOrMaker, options);\n  }\n  return makeSubscriptionFollower(spec);\n};\n","/* eslint-disable no-undef-init */\n// @ts-check\nimport { iterateReverse } from '@agoric/casting';\nimport { observeIteration, subscribeEach } from '@agoric/notifier';\nimport { E } from '@endo/far';\n\nexport const NO_SMART_WALLET_ERROR = 'no smart wallet';\n\nexport const makeWalletStateCoalescer = () => {\n  /** @type {Map<Brand, import('./smartWallet').BrandDescriptor>} */\n  const brands = new Map();\n  /** @type {Map<number, import('./offers').OfferStatus>} */\n  const offerStatuses = new Map();\n  /** @type {Map<Brand, Amount>} */\n  const balances = new Map();\n\n  /** @type {Brand=} */\n  let allegedInvitationBrand = undefined;\n\n  /**\n   * keyed by description; xxx assumes unique\n   *\n   * @type {Map<string, { acceptedIn: number, description: string, instance: { boardId: string } }>}\n   */\n  const invitationsReceived = new Map();\n\n  /** @param {import('./smartWallet').UpdateRecord} updateRecord newer than previous */\n  const update = updateRecord => {\n    const { updated } = updateRecord;\n    switch (updateRecord.updated) {\n      case 'balance': {\n        const { currentAmount } = updateRecord;\n        // last record wins\n        balances.set(currentAmount.brand, currentAmount);\n        if (allegedInvitationBrand) {\n          console.warn(\n            'balance update before invitationBrand known may be an invitation',\n          );\n        }\n        if (currentAmount.brand === allegedInvitationBrand) {\n          // @ts-expect-error narrow to SetValue\n          for (const invitation of currentAmount.value) {\n            invitationsReceived.set(invitation.description, invitation);\n          }\n        }\n        break;\n      }\n      case 'offerStatus': {\n        const { status } = updateRecord;\n        const lastStatus = offerStatuses.get(status.id);\n        // merge records\n        offerStatuses.set(status.id, { ...lastStatus, ...status });\n        if (\n          status.invitationSpec.source === 'purse' &&\n          status.numWantsSatisfied === 1\n        ) {\n          // record acceptance of invitation\n          // xxx matching only by description\n          const { description } = status.invitationSpec;\n          const receptionRecord = invitationsReceived.get(description);\n          if (receptionRecord) {\n            invitationsReceived.set(description, {\n              ...receptionRecord,\n              acceptedIn: status.id,\n            });\n          } else {\n            console.error('no record of invitation in offerStatus', status);\n          }\n        }\n        break;\n      }\n      case 'brand': {\n        const { descriptor } = updateRecord;\n        // never mutate\n        assert(!brands.has(descriptor.brand));\n        brands.set(descriptor.brand, descriptor);\n        if (descriptor.petname === 'invitations') {\n          allegedInvitationBrand = descriptor.brand;\n        }\n        break;\n      }\n      default:\n        throw new Error(`unknown record updated ${updated}`);\n    }\n  };\n\n  return {\n    state: { brands, invitationsReceived, offerStatuses, balances },\n    update,\n  };\n};\n/** @typedef {ReturnType<typeof makeWalletStateCoalescer>['state']} CoalescedWalletState */\n\n/**\n * Coalesce updates from a wallet UpdateRecord publication feed. Note that local\n * state may not reflect the wallet's state if the initial updates are missed.\n *\n * If this proves to be a problem we can add an option to this or a related\n * utility to reset state from RPC.\n *\n * @param {ERef<Subscriber<import('./smartWallet').UpdateRecord>>} updates\n */\nexport const coalesceUpdates = updates => {\n  const coalescer = makeWalletStateCoalescer();\n\n  observeIteration(subscribeEach(updates), {\n    updateState: updateRecord => {\n      coalescer.update(updateRecord);\n    },\n  });\n  return coalescer.state;\n};\n\n/**\n *\n * @param {import('@agoric/casting').Follower<any>} follower\n * @throws if there is no first height\n */\nexport const assertHasData = async follower => {\n  const eachIterable = E(follower).getReverseIterable();\n  const iterator = await E(eachIterable)[Symbol.asyncIterator]();\n  const el = await iterator.next();\n\n  // done before we started\n  if (el.done && !el.value) {\n    assert.fail(NO_SMART_WALLET_ERROR);\n  }\n};\n\n/**\n * @deprecated use `.current` node for current state\n * @param {import('@agoric/casting').Follower<import('@agoric/casting').ValueFollowerElement<import('./smartWallet').UpdateRecord>>} follower\n */\nexport const coalesceWalletState = async follower => {\n  // values with oldest last\n  const history = [];\n  for await (const followerElement of iterateReverse(follower)) {\n    history.push(followerElement.value);\n  }\n\n  const coalescer = makeWalletStateCoalescer();\n  // update with oldest first\n  for (const record of history.reverse()) {\n    coalescer.update(record);\n  }\n\n  return coalescer.state;\n};\n","// @ts-check\nimport { makeScalarMap } from '@agoric/store';\nimport { Far, makeMarshal, Remotable } from '@endo/marshal';\nimport { HandledPromise } from '@endo/eventual-send'; // TODO: convince tsc this isn't needed\n\nconst { details: X, quote: q } = assert;\n\n/**\n * For a value with a known id in the board, we can use\n * that board id as a slot to preserve identity when marshaling.\n *\n * @typedef {`board${Digits}`} BoardId\n */\n\n/**\n * @param {unknown} specimen\n * @returns {specimen is BoardId}\n */\nconst isBoardId = specimen => {\n  return typeof specimen === 'string' && !!specimen.match(/^board[^:]/);\n};\n\n/**\n * When marshaling a purse, payment, etc. we partition the slots\n * using prefixes.\n *\n * @template {Record<string, IdTable<*,*>>} T\n * @typedef {`${string & keyof T}:${Digits}`} WalletSlot<T>\n */\n/**\n * @template {string} K\n * @typedef {`${K}:${Digits}`} KindSlot<K>\n */\n\n/**\n * @template {Record<string, IdTable<*,*>>} T\n * @param {T} _tables\n * @param {string & keyof T} kind\n * @param {number} id\n * @returns {WalletSlot<T>}\n */\nconst makeWalletSlot = (_tables, kind, id) => {\n  const digits = /** @type {Digits} */ (`${id}`);\n  return `${kind}:${digits}`;\n};\n\n/**\n * @template {Record<string, IdTable<*,*>>} T\n * @param {T} record\n * @param {(value: string, index: number, obj: string[]) => boolean} predicate\n * @returns {string & keyof T | undefined}\n */\nconst findKey = (record, predicate) => {\n  const key = Object.keys(record).find(predicate);\n  return key;\n};\n\n/**\n * @template {Record<string, IdTable<*,*>>} T\n * @param {T} tables\n * @param {string} slot\n * @returns {{ kind: undefined | string & keyof T, id: number }}\n */\nconst parseWalletSlot = (tables, slot) => {\n  const kind = findKey(tables, k => slot.startsWith(`${k}:`));\n  const id = kind ? Number(slot.slice(kind.length + 1)) : NaN;\n  return { kind, id };\n};\n\n/**\n * Since KindSlots always include a colon and BoardIds never do,\n * we an mix them without confusion.\n *\n * @template {Record<string, IdTable<*,*>>} T\n * @typedef {WalletSlot<T> | BoardId} MixedSlot<T>\n */\n/**\n * @typedef {`1` | `12` | `123`} Digits - 1 or more digits.\n * NOTE: the typescript definition here is more restrictive than\n * actual usage.\n */\n\n/**\n * @template Slot\n * @template Val\n *\n * @typedef {{\n *   bySlot: MapStore<Slot, Val>,\n *   byVal: MapStore<Val, Slot>,\n * }} IdTable<Value>\n */\n\n/**\n * @template Slot\n * @template Val\n * @param {IdTable<Slot, Val>} table\n * @param {Slot} slot\n * @param {Val} val\n */\nconst initSlotVal = (table, slot, val) => {\n  table.bySlot.init(slot, val);\n  table.byVal.init(val, slot);\n};\n\n/**\n * Make context for exporting wallet data where brands etc. can be recognized by boardId.\n * Export for use outside the smart wallet.\n *\n * When serializing wallet state for, there's a tension between\n *\n *  - keeping purses etc. closely held\n *  - recognizing identity of brands also referenced in the state of contracts such as the AMM\n *\n * `makeMarshal()` is parameterized by the type of slots. Here we use a disjoint union of\n *   - board ids for widely shared objects\n *   - kind:seq ids for closely held objects; for example purse:123\n */\nexport const makeExportContext = () => {\n  const walletObjects = {\n    /** @type {IdTable<number, Purse>} */\n    purse: {\n      bySlot: makeScalarMap(),\n      byVal: makeScalarMap(),\n    },\n    /** @type {IdTable<number, Payment>} */\n    payment: {\n      bySlot: makeScalarMap(),\n      byVal: makeScalarMap(),\n    },\n    // TODO: offer, contact, dapp\n    /** @type {IdTable<number, unknown>} */\n    unknown: {\n      bySlot: makeScalarMap(),\n      byVal: makeScalarMap(),\n    },\n  };\n  /** @type {IdTable<BoardId, unknown>} */\n  const boardObjects = {\n    bySlot: makeScalarMap(),\n    byVal: makeScalarMap(),\n  };\n\n  /**\n   * Look up the slot in mappings from published data\n   * else try walletObjects that we have seen.\n   *\n   * @throws if not found (a slotToVal function typically\n   *         conjures a new identity)\n   *\n   * @param {MixedSlot<typeof walletObjects>} slot\n   * @param {string} _iface\n   */\n  const slotToVal = (slot, _iface) => {\n    if (isBoardId(slot) && boardObjects.bySlot.has(slot)) {\n      return boardObjects.bySlot.get(slot);\n    }\n    const { kind, id } = parseWalletSlot(walletObjects, slot);\n    assert(kind, X`bad slot kind: ${slot}`);\n    const val = walletObjects[kind].bySlot.get(id); // or throw\n    return val;\n  };\n\n  let unknownNonce = 0;\n\n  /**\n   * @param {unknown} val\n   * @returns {MixedSlot<typeof walletObjects>}\n   */\n  const valToSlot = val => {\n    if (boardObjects.byVal.has(val)) {\n      return boardObjects.byVal.get(val);\n    }\n    const kind = findKey(walletObjects, k => walletObjects[k].byVal.has(val));\n    if (kind) {\n      // @ts-expect-error has(val) above ensures val has the right type\n      const id = walletObjects[kind].byVal.get(val);\n      return makeWalletSlot(walletObjects, kind, id);\n    }\n    unknownNonce += 1;\n    const slot = makeWalletSlot(walletObjects, 'unknown', unknownNonce);\n    initSlotVal(walletObjects.unknown, unknownNonce, val);\n    return slot;\n  };\n\n  /**\n   * @template V\n   * @param {string & keyof typeof walletObjects} kind\n   * @param {IdTable<number, V>} table\n   */\n  const makeSaver = (kind, table) => {\n    let nonce = 0;\n    /** @param {V} val */\n    const saver = val => {\n      nonce += 1;\n      initSlotVal(table, nonce, val);\n    };\n    return saver;\n  };\n\n  return harden({\n    savePurseActions: makeSaver('purse', walletObjects.purse),\n    savePaymentActions: makeSaver('payment', walletObjects.payment),\n    /**\n     * @param {number} id\n     * @param {Purse} purse\n     */\n    initPurseId: (id, purse) => {\n      initSlotVal(walletObjects.purse, id, purse);\n    },\n    purseEntries: walletObjects.purse.bySlot.entries,\n    /**\n     * @param {BoardId} id\n     * @param {unknown} val\n     */\n    initBoardId: (id, val) => {\n      initSlotVal(boardObjects, id, val);\n    },\n    /**\n     * @param {BoardId} id\n     * @param {unknown} val\n     */\n    ensureBoardId: (id, val) => {\n      if (boardObjects.byVal.has(val)) {\n        assert.equal(boardObjects.byVal.get(val), id);\n        return;\n      }\n      initSlotVal(boardObjects, id, val);\n    },\n    ...makeMarshal(valToSlot, slotToVal),\n  });\n};\n\nconst defaultMakePresence = iface => {\n  const severed = `SEVERED: ${iface.replace(/^Alleged: /, '')}`;\n  return Far(severed, {});\n};\n\n/**\n * Make context for marshalling wallet or board data.\n * To be imported into the client, which never exports objects.\n *\n * @param {(iface: string) => unknown} [makePresence]\n */\nexport const makeImportContext = (makePresence = defaultMakePresence) => {\n  const walletObjects = {\n    /** @type {IdTable<number, unknown>} */\n    purse: {\n      bySlot: makeScalarMap(),\n      byVal: makeScalarMap(),\n    },\n    /** @type {IdTable<number, unknown>} */\n    payment: {\n      bySlot: makeScalarMap(),\n      byVal: makeScalarMap(),\n    },\n    /** @type {IdTable<number, unknown>} */\n    unknown: {\n      bySlot: makeScalarMap(),\n      byVal: makeScalarMap(),\n    },\n  };\n  /** @type {IdTable<BoardId, unknown>} */\n  const boardObjects = {\n    bySlot: makeScalarMap(),\n    byVal: makeScalarMap(),\n  };\n\n  /**\n   * @template Slot\n   * @template Val\n   * @param {IdTable<Slot, Val>} table\n   * @param {Slot} slot\n   * @param {string} iface\n   */\n  const provideVal = (table, slot, iface) => {\n    if (table.bySlot.has(slot)) {\n      return table.bySlot.get(slot);\n    }\n    const val = makePresence(iface);\n    initSlotVal(table, slot, val);\n    return val;\n  };\n\n  const slotToVal = {\n    /**\n     * @param {string} slot\n     * @param {string} iface\n     */\n    fromBoard: (slot, iface) => {\n      assert(isBoardId(slot), X`bad board slot ${q(slot)}`);\n      return provideVal(boardObjects, slot, iface);\n    },\n\n    /**\n     * @param {string} slot\n     * @param {string} iface\n     */\n    fromMyWallet: (slot, iface) => {\n      if (!slot) {\n        // Empty or null slots are neither in the wallet nor the board.\n        return makePresence(`${slot}`);\n      }\n      const { kind, id } = parseWalletSlot(walletObjects, slot);\n      return kind\n        ? provideVal(walletObjects[kind], id, iface)\n        : slotToVal.fromBoard(slot, iface);\n    },\n  };\n\n  const valToSlot = {\n    fromBoard: val => boardObjects.byVal.get(val),\n    /** @param {unknown} val */\n    fromMyWallet: val => {\n      const kind = findKey(walletObjects, k => walletObjects[k].byVal.has(val));\n      assert(kind, X`cannot serialize unregistered ${val}`);\n\n      const id = walletObjects[kind].byVal.get(val);\n      return makeWalletSlot(walletObjects, kind, id);\n    },\n  };\n\n  const marshal = {\n    fromBoard: makeMarshal(valToSlot.fromBoard, slotToVal.fromBoard, {\n      marshalName: 'fromBoard',\n    }),\n    fromMyWallet: makeMarshal(valToSlot.fromMyWallet, slotToVal.fromMyWallet, {\n      marshalName: 'fromMyWallet',\n    }),\n  };\n\n  return harden({\n    /**\n     * @param {BoardId} id\n     * @param {unknown} val\n     */\n    initBoardId: (id, val) => {\n      initSlotVal(boardObjects, id, val);\n    },\n    /**\n     * @param {BoardId} id\n     * @param {unknown} val\n     */\n    ensureBoardId: (id, val) => {\n      if (boardObjects.byVal.has(val)) {\n        assert.equal(boardObjects.byVal.get(val), id);\n        return;\n      }\n      initSlotVal(boardObjects, id, val);\n    },\n    fromMyWallet: Far('wallet marshaller', { ...marshal.fromMyWallet }),\n    fromBoard: Far('board marshaller', { ...marshal.fromBoard }),\n  });\n};\n\n/**\n * @param {string} iface\n * @param {{\n *   applyMethod: (target: unknown, method: string | symbol, args: unknown[]) => void,\n *   applyFunction: (target: unknown, args: unknown[]) => void,\n * }} handler\n */\nconst makePresence = (iface, handler) => {\n  let obj;\n  // eslint-disable-next-line no-new\n  new HandledPromise((resolve, reject, resolveWithPresence) => {\n    obj = resolveWithPresence(handler);\n  });\n  assert(obj);\n  return Remotable(iface, undefined, obj);\n};\n\n/**\n * @param {string} iface\n * @param {(parts: unknown[]) => void} log\n */\nexport const makeLoggingPresence = (iface, log) => {\n  /** @type {any} */ // TODO: solve types puzzle\n  const it = makePresence(iface, {\n    applyMethod: (target, method, args) => {\n      log(harden(['applyMethod', target, method, args]));\n    },\n    applyFunction: (target, args) => {\n      log(harden(['applyFunction', target, args]));\n    },\n  });\n  return it;\n};\n","import { makeCapTP } from '@endo/captp';\nimport { E } from '@endo/eventual-send';\n\nexport const bridgeStorageMessages = bridge => {\n  /** @type {Map<string,[ReturnType<typeof makeCapTP>, number]>} */\n  const dappToConn = new Map();\n\n  const handleStorageMessage = (key, newValue) => {\n    const keyParts = JSON.parse(key);\n    assert(Array.isArray(keyParts));\n    const [tag, origin, epoch, _ix] = /** @type {unknown[]} */ (keyParts);\n    const payload = JSON.parse(newValue);\n    if (tag !== 'out' || !payload || typeof payload.type !== 'string') {\n      return;\n    }\n\n    const obj = {\n      ...payload,\n      dappOrigin: origin,\n    };\n    const dappKey = JSON.stringify([origin, epoch]);\n    /** @type {ReturnType<typeof makeCapTP>}  */\n    let conn;\n    /** @type {number} */\n    let ix;\n    if (dappToConn.has(dappKey)) {\n      [conn, ix] = dappToConn.get(dappKey) || assert.fail();\n    } else {\n      /** @param {unknown} payloadOut */\n      const send = payloadOut => {\n        console.debug('WalletConnect: message -> storage', payloadOut);\n        window.localStorage.setItem(\n          JSON.stringify(['in', origin, epoch, ix]),\n          JSON.stringify(payloadOut),\n        );\n        ix += 1; // ISSUE: overflow?\n      };\n      const makeBoot = () => E(bridge).getScopedBridge(origin, origin);\n      console.debug('new capTP connection', { origin, epoch });\n      conn = makeCapTP(`from ${origin} at ${epoch}`, send, makeBoot);\n      ix = 0;\n    }\n    dappToConn.set(dappKey, [conn, ix + 1]);\n    console.debug('WalletConnect: storage -> dispatch', obj);\n    conn.dispatch(obj);\n    window.localStorage.removeItem(key);\n  };\n\n  const storageListener = ev => {\n    const { key, newValue } = ev;\n    // removeItem causes an event where newValue is null\n    if (key && newValue) {\n      handleStorageMessage(key, newValue);\n    }\n  };\n  window.addEventListener('storage', storageListener);\n\n  return () => {\n    window.removeEventListener('storage', storageListener);\n    for (const [conn, _ix] of dappToConn.values()) {\n      // @ts-expect-error capTP abort has wrong type?\n      conn.abort(Error('wallet connection cancelled'));\n    }\n  };\n};\n","import { maybeLoad, maybeSave } from '../util/storage.js';\n\nconst DAPPS_KEY_PREFIX = 'DAPPS';\n\nexport const loadDapps = publicAddress =>\n  maybeLoad([DAPPS_KEY_PREFIX, publicAddress]) ?? [];\n\nexport const upsertDapp = (publicAddress, dapp) => {\n  const { origin, enable, petname } = dapp;\n\n  const dapps = loadDapps(publicAddress) ?? [];\n  maybeSave(\n    [DAPPS_KEY_PREFIX, publicAddress],\n    [\n      ...dapps.filter(d => d.origin !== origin),\n      { origin, enable, petname, id: origin, meta: { id: origin } },\n    ],\n  );\n};\n\nexport const removeDapp = (publicAddress, origin) => {\n  const dapps = loadDapps(publicAddress) ?? [];\n  maybeSave(\n    [DAPPS_KEY_PREFIX, publicAddress],\n    dapps.filter(d => d.origin !== origin),\n  );\n};\n","import { makeNotifierKit } from '@agoric/notifier';\nimport {\n  loadDapps as load,\n  removeDapp as remove,\n  upsertDapp as upsert,\n} from '../store/Dapps.js';\n\n/**\n * @param {string} publicAddress\n */\nexport const getDappService = publicAddress => {\n  const dapps = new Map();\n  const { notifier, updater } = makeNotifierKit();\n  const broadcastUpdates = () => updater.updateState([...dapps.values()]);\n\n  const upsertDapp = dapp => {\n    dapps.set(dapp.origin, dapp);\n    upsert(publicAddress, dapp);\n    broadcastUpdates();\n  };\n\n  const deleteDapp = origin => {\n    dapps.delete(origin);\n    remove(publicAddress, origin);\n    broadcastUpdates();\n  };\n\n  const setDappPetname = (origin, petname) => {\n    const dapp = dapps.get(origin);\n    assert(dapp, `Tried to set petname on undefined dapp ${origin}`);\n    upsertDapp({ ...dapp, petname });\n  };\n\n  const enableDapp = origin => {\n    const dapp = dapps.get(origin);\n    assert(dapp, `Tried to enable undefined dapp ${origin}`);\n    upsertDapp({ ...dapp, enable: true });\n  };\n\n  const storedDapps = load(publicAddress);\n  storedDapps.forEach(d => {\n    let enableAction;\n    const approvedP = new Promise(res => {\n      enableAction = () => {\n        enableDapp(d.origin);\n        res();\n      };\n    });\n\n    dapps.set(d.origin, {\n      ...d,\n      approvedP,\n      actions: {\n        enable: enableAction,\n        setPetname: petname => setDappPetname(d.origin, petname),\n        delete: () => deleteDapp(d.origin),\n      },\n    });\n\n    if (d.enable) {\n      enableAction();\n    }\n  });\n  broadcastUpdates();\n\n  return {\n    dapps,\n    notifier,\n    addDapp: upsertDapp,\n    setDappPetname,\n    deleteDapp,\n    enableDapp,\n  };\n};\n","import { makeNotifierKit } from '@agoric/notifier';\n\n/**\n * @param {(data: string) => Promise<any>} signSpendAction\n */\nexport const getIssuerService = signSpendAction => {\n  const suggestions = new Map();\n  // TODO: Upgrade to `makePublishKit`.\n  const { notifier, updater } = makeNotifierKit();\n  const broadcastUpdates = () => updater.updateState([...suggestions.values()]);\n\n  const deleteSuggestion = boardId => {\n    assert(\n      suggestions.has(boardId),\n      `Tried to delete undefined issuer suggestion ${boardId}`,\n    );\n    suggestions.delete(boardId);\n    broadcastUpdates();\n  };\n\n  const addSuggestion = (petname, boardId) => {\n    suggestions.set(boardId, {\n      boardId,\n      petname,\n      actions: {\n        delete: () => deleteSuggestion(boardId),\n        accept: async suggestedPetname => {\n          const action = JSON.stringify({\n            type: 'suggestIssuer',\n            data: { boardId, petname: suggestedPetname },\n          });\n          try {\n            await signSpendAction(action);\n            deleteSuggestion(boardId);\n          } catch (e) {\n            console.error('Sign spend action failed', action);\n          }\n        },\n      },\n    });\n    broadcastUpdates();\n  };\n\n  return {\n    notifier,\n    addSuggestion,\n  };\n};\n","import { maybeLoad, maybeSave } from '../util/storage.js';\n\nconst OFFERS_KEY_PREFIX = 'OFFERS';\n\nexport const loadOffers = publicAddress =>\n  maybeLoad([OFFERS_KEY_PREFIX, publicAddress]) ?? [];\n\nexport const addOffer = (publicAddress, offer) => {\n  const offers = loadOffers(publicAddress) ?? [];\n  maybeSave(\n    [OFFERS_KEY_PREFIX, publicAddress],\n    [...offers.filter(o => o.id !== offer.id), offer],\n  );\n};\n\nexport const removeOffer = (publicAddress, id) => {\n  const offers = loadOffers(publicAddress) ?? [];\n  maybeSave(\n    [OFFERS_KEY_PREFIX, publicAddress],\n    offers.filter(o => o.id !== id),\n  );\n};\n","import {\n  makeNotifierKit,\n  makeAsyncIterableFromNotifier,\n} from '@agoric/notifier';\nimport {\n  loadOffers as load,\n  removeOffer as remove,\n  addOffer as add,\n} from '../store/Offers.js';\n\n/**\n * @param {string} publicAddress\n * @param {(data: string) => Promise<any>} signSpendAction\n * @param {Notifier<any>} chainOffersNotifier\n */\nexport const getOfferService = (\n  publicAddress,\n  signSpendAction,\n  chainOffersNotifier,\n) => {\n  const offers = new Map();\n  let chainOffers = [];\n  const { notifier, updater } = makeNotifierKit();\n  const broadcastUpdates = () =>\n    updater.updateState([...offers.values(), ...chainOffers]);\n\n  const upsertOffer = offer => {\n    offers.set(offer.id, offer);\n    add(publicAddress, offer);\n    broadcastUpdates();\n  };\n\n  const declineOffer = id => {\n    const offer = offers.get(id);\n    assert(offer, `Tried to decline undefined offer ${id}`);\n    upsertOffer({ ...offer, status: 'decline' });\n    broadcastUpdates();\n  };\n\n  const acceptOffer = async id => {\n    const offer = offers.get(id);\n    assert(offer, `Tried to accept undefined offer ${id}`);\n    return signSpendAction(offer.spendAction);\n  };\n\n  const cancelOffer = _id => {\n    console.log('TODO: cancel offer');\n  };\n\n  const storedOffers = load(publicAddress);\n  storedOffers.forEach(o => {\n    if (o.status === 'decline') {\n      remove(publicAddress, o.id);\n    }\n    offers.set(o.id, {\n      ...o,\n    });\n  });\n  broadcastUpdates();\n\n  const watchChainOffers = async () => {\n    for await (const state of makeAsyncIterableFromNotifier(\n      chainOffersNotifier,\n    )) {\n      state?.forEach(offer => {\n        console.log('chain offer', offer);\n        const splitId = offer.id.split('#');\n        const rawId = splitId[splitId.length - 1];\n        if (offers.has(rawId)) {\n          offers.delete(rawId);\n          remove(publicAddress, rawId);\n        }\n        chainOffers = state;\n        broadcastUpdates();\n      });\n    }\n  };\n  watchChainOffers();\n\n  return {\n    offers,\n    notifier,\n    addOffer: upsertOffer,\n    acceptOffer,\n    cancelOffer,\n    declineOffer,\n  };\n};\n","import { Far } from '@endo/captp';\n\nexport const getScopedBridge = (origin, suggestedDappPetname, bridge) => {\n  const {\n    getPursesNotifier,\n    dappService,\n    offerService,\n    issuerService,\n    unserializer,\n    networkConfig,\n  } = bridge;\n\n  const { dapps, addDapp, setDappPetname, deleteDapp, enableDapp } =\n    dappService;\n\n  const setPetname = petname => setDappPetname(origin, petname);\n\n  let dapp = dapps.get(origin);\n  if (!dapp) {\n    let enableAction;\n    const approvedP = new Promise(res => {\n      enableAction = () => {\n        enableDapp(origin);\n        res();\n      };\n    });\n\n    dapp = {\n      id: origin,\n      meta: { id: origin },\n      petname: suggestedDappPetname,\n      origin,\n      enable: false,\n      actions: {\n        enable: enableAction,\n        setPetname,\n        delete: () => deleteDapp(origin),\n      },\n      approvedP,\n    };\n    addDapp(dapp);\n  }\n\n  return Far('scoped bridge', {\n    async addOffer(config) {\n      const currentTime = new Date().getTime();\n      const id = `${currentTime}`;\n      await dapp.approvedP;\n      offerService.addOffer({\n        id,\n        instancePetname: `instance@${config.instanceHandleBoardId}`,\n        requestContext: { dappOrigin: origin, origin },\n        meta: {\n          id: `${currentTime}`,\n          creationStamp: currentTime,\n        },\n        status: 'proposed',\n        ...config,\n      });\n      return id;\n    },\n    async suggestIssuer(petname, boardId) {\n      await dapp.approvedP;\n      issuerService.addSuggestion(petname, boardId);\n    },\n    async suggestInstallation(petname, boardId) {\n      await dapp.approvedP;\n      console.log('TODO: suggest installation', petname, boardId);\n    },\n    async suggestInstance(petname, boardId) {\n      await dapp.approvedP;\n      console.log('TODO: suggest instance', petname, boardId);\n    },\n    async getPursesNotifier() {\n      await dapp.approvedP;\n      // TODO: attenuate purses? maybe not needed if they're from follower\n      return getPursesNotifier();\n    },\n    async getOffersNotifier() {\n      await dapp.approvedP;\n      // TODO: filter offers by dapp origin\n      return offerService.notifier;\n    },\n    async getUnserializer() {\n      await dapp.approvedP;\n      return unserializer;\n    },\n    async getNetConfig() {\n      await dapp.approvedP;\n      return networkConfig;\n    },\n  });\n};\n","// @ts-check\nimport { iterateEach } from '@agoric/casting';\nimport { AmountMath } from '@agoric/ertp';\nimport {\n  makeAsyncIterableFromNotifier,\n  makeNotifierKit,\n} from '@agoric/notifier';\nimport {\n  assertHasData,\n  NO_SMART_WALLET_ERROR,\n} from '@agoric/smart-wallet/src/utils.js';\nimport { E } from '@endo/eventual-send';\nimport { Far } from '@endo/marshal';\nimport { getDappService } from '../service/Dapps.js';\nimport { getIssuerService } from '../service/Issuers.js';\nimport { getOfferService } from '../service/Offers.js';\nimport { getScopedBridge } from '../service/ScopedBridge.js';\n\n/** @typedef {import('@agoric/smart-wallet/src/types.js').Petname} Petname */\n\nconst newId = kind => `${kind}${Math.random()}`;\n\n/** @typedef {{actions: object, issuerSuggestions: Promise<AsyncIterator>}} BackendSchema */\n\nexport const makeBackendFromWalletBridge = walletBridge => {\n  /**\n   * @template T\n   * @param {ERef<Notifier<T>>} notifier\n   */\n  const iterateNotifier = async notifier =>\n    makeAsyncIterableFromNotifier(notifier)[Symbol.asyncIterator]();\n\n  const { notifier: servicesNotifier } = makeNotifierKit(\n    harden({\n      board: E(walletBridge).getBoard(),\n    }),\n  );\n\n  /**\n   * @param {AsyncIterator<any[], any[], undefined>} offersMembers\n   */\n  const wrapOffersIterator = offersMembers =>\n    harden({\n      next: async () => {\n        const { done, value } = await E(offersMembers).next();\n        return harden({\n          done,\n          value:\n            value &&\n            value.map(({ id, ...rest }) =>\n              harden({\n                id,\n                ...rest,\n                actions: Far('offerActions', {\n                  // Provide these synthetic actions since offers don't have any yet.\n                  accept: () => E(walletBridge).acceptOffer(id),\n                  decline: () => E(walletBridge).declineOffer(id),\n                  cancel: () => E(walletBridge).cancelOffer(id),\n                }),\n              }),\n            ),\n        });\n      },\n      return: offersMembers.return,\n      throw: offersMembers.throw,\n    });\n\n  /** @type {BackendSchema} */\n  const firstSchema = harden({\n    actions: Far('schemaActions', {\n      createPurse: (issuer, id = newId('Purse')) =>\n        E(walletBridge).makeEmptyPurse(issuer?.issuerPetname, id),\n      createContact: (depositFacet, id = newId('Contact')) =>\n        E(walletBridge).addContact(id, depositFacet),\n      createIssuer: (issuer, id = newId('Issuer')) =>\n        E(walletBridge).addIssuer(id, issuer, true),\n    }),\n    services: iterateNotifier(servicesNotifier),\n    contacts: iterateNotifier(E(walletBridge).getContactsNotifier()),\n    dapps: iterateNotifier(E(walletBridge).getDappsNotifier()),\n    issuers: iterateNotifier(E(walletBridge).getIssuersNotifier()),\n    offers: wrapOffersIterator(\n      // @ts-expect-error xxx\n      iterateNotifier(E(walletBridge).getOffersNotifier()),\n    ),\n    payments: iterateNotifier(E(walletBridge).getPaymentsNotifier()),\n    purses: iterateNotifier(E(walletBridge).getPursesNotifier()),\n    issuerSuggestions: iterateNotifier(\n      E(walletBridge).getIssuerSuggestionsNotifier(),\n    ),\n  });\n\n  // Just produce a single update for the initial backend.\n  // TODO: allow further updates.\n  /** @type {NotifierRecord<BackendSchema>} */\n  const { notifier: backendNotifier, updater: backendUpdater } =\n    makeNotifierKit(firstSchema);\n\n  const backendIt = iterateNotifier(backendNotifier);\n\n  const cancel = e => {\n    backendUpdater.fail(e);\n  };\n\n  return { backendIt, cancel };\n};\n\n/**\n * @param {import('@agoric/casting').ValueFollower<import('@agoric/smart-wallet/src/smartWallet').CurrentWalletRecord>} currentFollower\n * @param {import('@agoric/casting').ValueFollower<import('@agoric/smart-wallet/src/smartWallet').UpdateRecord>} updateFollower\n * @param {import('@agoric/casting').Leader} leader\n * @param {ReturnType<import('@endo/marshal').makeMarshal>} marshaller\n * @param {string} publicAddress\n * @param {object} keplrConnection\n * @param {string} networkConfig\n * @param {(e: unknown) => void} [errorHandler]\n * @param {() => void} [firstCallback]\n */\nexport const makeWalletBridgeFromFollowers = (\n  currentFollower,\n  updateFollower,\n  leader,\n  marshaller,\n  publicAddress,\n  keplrConnection,\n  networkConfig,\n  errorHandler = e => {\n    // Make an unhandled rejection.\n    throw e;\n  },\n  firstCallback = () => {},\n) => {\n  const notifiers = {\n    getPursesNotifier: 'purses',\n    getContactsNotifier: 'contacts',\n    getIssuersNotifier: 'issuers',\n    getOffersNotifier: 'offers',\n    getPaymentsNotifier: 'payments',\n  };\n\n  /** @type {Record<string, NotifierRecord<unknown>>} */\n  const notifierKits = Object.fromEntries(\n    Object.entries(notifiers).map(([_method, stateName]) => [\n      stateName,\n      makeNotifierKit(null),\n    ]),\n  );\n\n  // We assume just one cosmos purse per brand.\n  /** @type {Record<number, import('@agoric/smart-wallet/src/offers.js').OfferStatus & {status: 'accept' | 'rejected'}>} */\n  const offers = {};\n  /**\n   * @typedef {{\n   *  brand?: Brand,\n   *  brandPetname?: Petname,\n   *  currentAmount: Amount,\n   *  pursePetname?: Petname,\n   *  displayInfo?: DisplayInfo,\n   * }} PurseInfo\n   * @type {Map<Brand, PurseInfo>}\n   */\n  const brandToPurse = new Map();\n  /** @type {Map<Petname, Brand>} */\n  const pursePetnameToBrand = new Map();\n\n  if (firstCallback) {\n    firstCallback();\n    Object.values(notifierKits).forEach(({ updater }) =>\n      updater.updateState([]),\n    );\n    firstCallback = undefined;\n  }\n\n  const updatePurses = () => {\n    const purses = [];\n    for (const [brand, purse] of brandToPurse.entries()) {\n      if (purse.currentAmount && purse.brandPetname) {\n        assert(purse.pursePetname, 'missing purse.pursePetname');\n        pursePetnameToBrand.set(purse.pursePetname, brand);\n        purses.push(purse);\n      }\n    }\n    notifierKits.purses.updater.updateState(harden(purses));\n  };\n\n  const fetchCurrent = async () => {\n    await assertHasData(currentFollower);\n    const latestIterable = await E(currentFollower).getLatestIterable();\n    const iterator = latestIterable[Symbol.asyncIterator]();\n    const latest = await iterator.next();\n    /** @type {import('@agoric/casting').ValueFollowerElement<import('@agoric/smart-wallet/src/smartWallet').CurrentWalletRecord>} */\n    const currentEl = latest.value;\n    const wallet = currentEl.value;\n    for (const purse of wallet.purses) {\n      console.debug('registering purse', purse);\n      const brandDescriptor = wallet.brands.find(\n        bd => purse.brand === bd.brand,\n      );\n      assert(brandDescriptor, `missing descriptor for brand ${purse.brand}`);\n      /** @type {PurseInfo} */\n      const purseInfo = {\n        brand: purse.brand,\n        currentAmount: purse.balance,\n        brandPetname: brandDescriptor.petname,\n        pursePetname: brandDescriptor.petname,\n        displayInfo: brandDescriptor.displayInfo,\n      };\n      brandToPurse.set(purse.brand, purseInfo);\n    }\n    console.debug('brandToPurse map', brandToPurse);\n    updatePurses();\n    return currentEl.blockHeight;\n  };\n\n  const followLatest = async startingHeight => {\n    for await (const { value } of iterateEach(updateFollower, {\n      height: startingHeight,\n    })) {\n      /** @type {import('@agoric/smart-wallet/src/smartWallet').UpdateRecord} */\n      const updateRecord = value;\n      switch (updateRecord.updated) {\n        case 'brand': {\n          const {\n            descriptor: { brand, petname, displayInfo },\n          } = updateRecord;\n          const prior = brandToPurse.get(brand);\n          const purseObj = {\n            brand,\n            brandPetname: petname,\n            pursePetname: petname,\n            displayInfo,\n            currentAmount: prior?.currentAmount || AmountMath.makeEmpty(brand),\n          };\n          brandToPurse.set(brand, purseObj);\n          updatePurses();\n          break;\n        }\n        case 'balance': {\n          // TODO: Don't assume just one purse per brand.\n          // https://github.com/Agoric/agoric-sdk/issues/6126\n          const { currentAmount } = updateRecord;\n          const purseObj = {\n            ...brandToPurse.get(currentAmount.brand),\n            currentAmount,\n            value: currentAmount.value,\n          };\n          brandToPurse.set(currentAmount.brand, purseObj);\n          updatePurses();\n          break;\n        }\n        case 'offerStatus': {\n          const { status } = updateRecord;\n          console.log('offerStatus', { status, offers });\n          const oldOffer = offers[status.id];\n          if (!oldOffer) {\n            console.warn('Update for unknown offer, doing nothing.');\n            break;\n          }\n          if ('error' in status) {\n            offers[status.id] = {\n              ...oldOffer,\n              id: status.id,\n              status: 'rejected',\n              error: `${status.error}`,\n            };\n          } else if (\n            oldOffer.status !== 'accept' &&\n            'numWantsSatisfied' in status\n          ) {\n            offers[status.id] = {\n              ...oldOffer,\n              id: status.id,\n              status: 'accept',\n            };\n          }\n          notifierKits.offers.updater.updateState(\n            harden(Object.values(offers)),\n          );\n          break;\n        }\n        default: {\n          // @ts-expect-error exhaustive switch\n          throw Error(`Unknown updateRecord ${updateRecord.updated}`);\n        }\n      }\n    }\n  };\n\n  const loadData = () => fetchCurrent().then(followLatest);\n\n  const retry = () => {\n    loadData().catch(e => {\n      if (e.message === NO_SMART_WALLET_ERROR) {\n        setTimeout(retry, 5000);\n      } else {\n        errorHandler(e);\n      }\n    });\n  };\n\n  loadData().catch(e => {\n    errorHandler(e);\n    if (e.message === NO_SMART_WALLET_ERROR) {\n      setTimeout(retry, 5000);\n    }\n  });\n\n  const getNotifierMethods = Object.fromEntries(\n    Object.entries(notifiers).map(([method, stateName]) => {\n      const { notifier } = notifierKits[stateName];\n      return [method, () => notifier];\n    }),\n  );\n\n  const makeEmptyPurse = () => {\n    console.log('make empty purse');\n  };\n\n  const addContact = () => {\n    console.log('add contact');\n  };\n\n  const addIssuer = () => {\n    console.log('add issuer');\n  };\n\n  const signSpendAction = data => {\n    const {\n      signers: { interactiveSigner },\n    } = keplrConnection;\n    if (!interactiveSigner) {\n      throw new Error(\n        'Cannot sign a transaction in read only mode, connect to keplr.',\n      );\n    }\n    return interactiveSigner.submitSpendAction(data);\n  };\n\n  const issuerService = getIssuerService(signSpendAction);\n  const dappService = getDappService(publicAddress);\n  const offerService = getOfferService(\n    publicAddress,\n    signSpendAction,\n    getNotifierMethods.getOffersNotifier(),\n  );\n  const { acceptOffer, declineOffer, cancelOffer } = offerService;\n\n  // We override addOffer to adapt the old proposalTemplate format to the new\n  // smart-wallet format.\n  const addOfferPSMHack = async details => {\n    const {\n      id,\n      instanceHandleBoardId: instance, // This actually is the instance handle, not an ID.\n      invitationMaker: { method },\n      proposalTemplate: { give, want },\n    } = details;\n\n    const mapPurses = obj =>\n      Object.fromEntries(\n        Object.entries(obj).map(([kw, { brand, pursePetname, value }]) => [\n          kw,\n          {\n            brand: brand || pursePetnameToBrand.get(pursePetname),\n            value: BigInt(value),\n          },\n        ]),\n      );\n    const offer = {\n      id: new Date().getTime(),\n      invitationSpec: {\n        source: 'contract',\n        instance,\n        publicInvitationMaker: method,\n      },\n      proposal: {\n        give: mapPurses(give),\n        want: mapPurses(want),\n      },\n    };\n    const spendAction = await E(marshaller).serialize(\n      harden({\n        method: 'executeOffer',\n        offer,\n      }),\n    );\n\n    // Recover the instance's boardId.\n    const {\n      slots: [instanceBoardId],\n    } = await E(marshaller).serialize(instance);\n\n    const fullOffer = {\n      ...details,\n      instancePetname: `instance@${instanceBoardId}`,\n      spendAction: JSON.stringify(spendAction),\n    };\n    offerService.addOffer(fullOffer);\n    offers[id] = fullOffer;\n    return id;\n  };\n\n  const walletBridge = Far('follower wallet bridge', {\n    ...getNotifierMethods,\n    getDappsNotifier: () => dappService.notifier,\n    getOffersNotifier: () => offerService.notifier,\n    getIssuerSuggestionsNotifier: () => issuerService.notifier,\n    acceptOffer,\n    declineOffer,\n    cancelOffer,\n    makeEmptyPurse,\n    addContact,\n    addIssuer,\n    getScopedBridge: (origin, suggestedDappPetname) =>\n      getScopedBridge(origin, suggestedDappPetname, {\n        dappService,\n        offerService: { ...offerService, addOffer: addOfferPSMHack },\n        leader,\n        unserializer: marshaller,\n        publicAddress,\n        issuerService,\n        networkConfig,\n        ...getNotifierMethods,\n      }),\n  });\n\n  return walletBridge;\n};\n","import CircularProgress from '@mui/material/CircularProgress';\nimport Dialog from '@mui/material/Dialog';\nimport DialogTitle from '@mui/material/DialogTitle';\nimport DialogContent from '@mui/material/DialogContent';\nimport DialogContentText from '@mui/material/DialogContentText';\nimport DialogActions from '@mui/material/DialogActions';\nimport Button from '@mui/material/Button';\nimport Box from '@mui/material/Box';\nimport Link from '@mui/material/Link';\nimport { useState } from 'react';\n\nimport { withApplicationContext } from '../contexts/Application';\n\nconst steps = {\n  INITIAL: 0,\n  AWAITING_APPROVAL: 1,\n  IN_PROGRESS: 2,\n};\n\nconst errors = {\n  NO_SIGNER: 'Cannot sign a transaction in read only mode, connect to keplr.',\n};\n\n// TODO: Read this from the chain via rpc.\nconst CREATION_FEE = '10 BLD';\n\nconst ProvisionDialog = ({ onClose, open, address, href, keplrConnection }) => {\n  const [currentStep, setCurrentStep] = useState(steps.INITIAL);\n  const [error, setError] = useState(null);\n\n  const provisionWallet = async signer => {\n    setError(null);\n    setCurrentStep(steps.AWAITING_APPROVAL);\n    try {\n      await signer.submitProvision();\n    } catch (e) {\n      setCurrentStep(steps.INITIAL);\n      setError(e.message);\n      return;\n    }\n    setCurrentStep(steps.IN_PROGRESS);\n  };\n\n  const handleCreateButtonClicked = () => {\n    const {\n      signers: { interactiveSigner },\n    } = keplrConnection;\n    if (!interactiveSigner) {\n      setError(errors.NO_SIGNER);\n      return;\n    }\n\n    provisionWallet(interactiveSigner);\n  };\n\n  const progressIndicator = text => (\n    <Box>\n      <Box\n        sx={{\n          margin: 'auto',\n          display: 'flex',\n          flexDirection: 'row',\n          justifyContent: 'center',\n        }}\n      >\n        <CircularProgress />\n      </Box>\n      <DialogContentText sx={{ pt: 2 }}>{text}</DialogContentText>\n    </Box>\n  );\n\n  const content = (() => {\n    switch (currentStep) {\n      case steps.INITIAL:\n        return (\n          <div>\n            <DialogContentText>\n              <b>Network Config</b>:{' '}\n              <Link href={href} underline=\"none\" color=\"rgb(0, 176, 255)\">\n                {href}\n              </Link>\n            </DialogContentText>\n            <DialogContentText sx={{ pt: 2 }}>\n              <b>Wallet Address:</b> {address}\n            </DialogContentText>\n            <DialogContentText sx={{ pt: 2 }}>\n              There is no smart wallet provisioned for this address yet. A fee\n              of <b>{CREATION_FEE}</b> is required to create one.\n            </DialogContentText>\n          </div>\n        );\n      case steps.AWAITING_APPROVAL:\n        return progressIndicator('Please approve the transaction in Keplr.');\n      case steps.IN_PROGRESS:\n        return progressIndicator('Awaiting smart wallet creation...');\n      default:\n        return <></>;\n    }\n  })();\n\n  return (\n    <Dialog open={open}>\n      <DialogTitle>\n        {currentStep === steps.INITIAL ? 'Create a' : 'Creating'} Smart Wallet\n      </DialogTitle>\n      <DialogContent>\n        {content}\n        {error && (\n          <DialogContentText sx={{ pt: 2 }} color=\"primary\">\n            {error}\n          </DialogContentText>\n        )}\n      </DialogContent>\n      {currentStep === steps.INITIAL && (\n        <DialogActions>\n          <Button color=\"cancel\" onClick={onClose}>\n            Change Connection\n          </Button>\n          <Button onClick={handleCreateButtonClicked}>Create</Button>\n        </DialogActions>\n      )}\n    </Dialog>\n  );\n};\n\nexport default withApplicationContext(ProvisionDialog, context => ({\n  keplrConnection: context.keplrConnection,\n}));\n","import { makeFollower, makeLeader } from '@agoric/casting';\nimport { observeIterator } from '@agoric/notifier';\nimport { NO_SMART_WALLET_ERROR } from '@agoric/smart-wallet/src/utils';\nimport { makeImportContext } from '@agoric/wallet/api/src/marshal-contexts';\nimport MuiAlert from '@mui/material/Alert';\nimport Snackbar from '@mui/material/Snackbar';\nimport React, { useEffect, useState } from 'react';\n\nimport {\n  ConnectionStatus,\n  withApplicationContext,\n} from '../contexts/Application';\nimport { bridgeStorageMessages } from '../util/BridgeStorage';\nimport { SmartConnectionMethod } from '../util/connections';\nimport {\n  makeBackendFromWalletBridge,\n  makeWalletBridgeFromFollowers,\n} from '../util/WalletBackendAdapter';\nimport ProvisionDialog from './ProvisionDialog';\n\nconst Alert = React.forwardRef(function Alert({ children, ...props }, ref) {\n  return (\n    <MuiAlert elevation={6} ref={ref} variant=\"filled\" {...props}>\n      {children}\n    </MuiAlert>\n  );\n});\n\nconst SmartWalletConnection = ({\n  connectionConfig,\n  setConnectionStatus,\n  setBackend,\n  setBackendErrorHandler,\n  keplrConnection,\n}) => {\n  const [snackbarMessages, setSnackbarMessages] = useState([]);\n  const [provisionDialogOpen, setProvisionDialogOpen] = useState(false);\n\n  const onProvisionDialogClose = () => {\n    setProvisionDialogOpen(false);\n  };\n\n  const handleSnackbarClose = (_, reason) => {\n    if (reason === 'clickaway') {\n      return;\n    }\n\n    setSnackbarMessages(sm => sm.slice(1));\n  };\n\n  const showError = (message, e, severity = 'error') => {\n    if (e) {\n      console.error(`${message}:`, e);\n      message += `: ${e.message}`;\n    }\n    if (severity === 'error') {\n      setConnectionStatus(ConnectionStatus.Error);\n    }\n    setSnackbarMessages(sm => [...sm, { severity, message }]);\n  };\n\n  const { href, smartConnectionMethod } = connectionConfig;\n\n  const publicAddress = (() => {\n    if (\n      smartConnectionMethod === SmartConnectionMethod.KEPLR &&\n      keplrConnection\n    ) {\n      return keplrConnection.address;\n    } else if (smartConnectionMethod === SmartConnectionMethod.READ_ONLY) {\n      return connectionConfig.publicAddress;\n    }\n    return undefined;\n  })();\n\n  const backendError = e => {\n    if (e.message === NO_SMART_WALLET_ERROR) {\n      setProvisionDialogOpen(true);\n      setConnectionStatus(ConnectionStatus.Error);\n    } else {\n      setBackend(null);\n      showError('Error in wallet backend', e);\n    }\n  };\n\n  useEffect(() => {\n    if (\n      !connectionConfig ||\n      (connectionConfig.smartConnectionMethod === SmartConnectionMethod.KEPLR &&\n        !keplrConnection)\n    ) {\n      return undefined;\n    }\n\n    let cancelIterator;\n    let cleanupStorageBridge;\n\n    const follow = async () => {\n      const context = makeImportContext();\n      const leader = makeLeader(href);\n      const followPublished = path =>\n        makeFollower(`:published.${path}`, leader, {\n          unserializer: context.fromMyWallet,\n        });\n      const bridge = makeWalletBridgeFromFollowers(\n        followPublished(`wallet.${publicAddress}.current`),\n        followPublished(`wallet.${publicAddress}`),\n        leader,\n        context.fromBoard,\n        publicAddress,\n        keplrConnection,\n        href,\n        backendError,\n        () => {\n          setConnectionStatus(ConnectionStatus.Connected);\n          setProvisionDialogOpen(false);\n        },\n      );\n      const { backendIt, cancel } = makeBackendFromWalletBridge(bridge);\n      cleanupStorageBridge = bridgeStorageMessages(bridge);\n      cancelIterator = cancel;\n      // Need to thunk the error handler, or it gets called immediately.\n      setBackendErrorHandler(() => backendError);\n      return observeIterator(backendIt, {\n        updateState: be => {\n          cancelIterator && setBackend(be);\n        },\n        fail: e => {\n          cancelIterator && backendError(e);\n        },\n        finish: be => {\n          cancelIterator && setBackend(be);\n        },\n      });\n    };\n    follow().catch(e => showError('Cannot read Smart Wallet casting', e));\n\n    return () => {\n      cancelIterator && cancelIterator();\n      cancelIterator = undefined;\n      cleanupStorageBridge && cleanupStorageBridge();\n      cleanupStorageBridge = undefined;\n    };\n  }, [connectionConfig, keplrConnection]);\n\n  return (\n    <div>\n      <Snackbar open={snackbarMessages.length > 0}>\n        <Alert\n          onClose={handleSnackbarClose}\n          severity={snackbarMessages[0]?.severity}\n          sx={{ width: '100%' }}\n        >\n          {snackbarMessages[0]?.message}\n        </Alert>\n      </Snackbar>\n      <ProvisionDialog\n        open={provisionDialogOpen}\n        onClose={onProvisionDialogClose}\n        address={publicAddress}\n        href={href}\n      />\n    </div>\n  );\n};\n\nexport default withApplicationContext(SmartWalletConnection, context => ({\n  connectionConfig: context.connectionConfig,\n  setConnectionStatus: context.setConnectionStatus,\n  setBackend: context.setBackend,\n  setBackendErrorHandler: context.setBackendErrorHandler,\n  keplrConnection: context.keplrConnection,\n}));\n"],"names":["DEFAULT_BOOTSTRAP","delay","ms","Promise","resolve","setTimeout","randomBackoff","range","cap","Math","random","min","exponentialBackoff","attempt","base","DEFAULT_JITTER","where","jitter","DEFAULT_JITTER_SECONDS","console","debug","ceil","DEFAULT_RETRY_CALLBACK","err","backoff","log","DEFAULT_KEEP_POLLING","DEFAULT_KEEP_POLLING_SECONDS","then","MAKE_DEFAULT_DECODER","harden","str","JSON","parse","error","Error","message","MAKE_DEFAULT_UNSERIALIZER","ifaceAllegedPrefix","seen","Map","Far","unserialize","makeMarshal","undefined","slot","iface","has","get","startsWith","slice","length","obj","set","shuffle","a","i","j","floor","x","makePollingChangeFollower","async","keepPolling","E","leader","getOptions","iterable","Symbol","asyncIterator","nextPollPromise","next","cont","keepGoing","change","values","value","done","getLatestIterable","getEachIterable","getReverseIterable","details","X","assert","makeLeaderFromRpcAddresses","rpcAddrs","leaderOptions","Array","isArray","endpoints","retryCallback","retrying","lastRespondingEndpointIndex","thisAttempt","retry","watchCasting","_castingSpecP","pollingChangeFollower","mapEndpoints","callback","reject","endpointIndex","applyOne","res","makeRoundRobinLeader","map","rpcAddr","typeof","includes","makeLeaderFromNetworkConfig","netconfigURL","options","makeLeader","response","fetch","headers","accept","json","retryLeader","catch","bootstrap","makeNotifierIterable","notifier","makeNotifier","getSharableNotifierInternals","makeSubscriptionIterable","subscription","makeSubscriptionIterator","tailP","getSharableSubscriptionInternals","resultP","head","tail","mapAsyncIterable","transform","transformGenerator","iterateEach","follower","eachIterable","iterator","toAscii","encodingStar","PATH_SEPARATOR_BYTE","charCodeAt","DATA_PREFIX_BYTES","Uint8Array","vstoragePathToCastingSpec","storagePath","storeName","elems","split","buf","storeSubkey","b","dataPrefixBytes","pathPrefixToConverters","te","TextEncoder","makeCastingSpecFromObject","specObj","subkey","encode","dataPrefix","makeCastingSpec","spec","sourceP","specString","match","kind","storePath","converter","makeCastingSpecFromString","getInterfaceOf","specCap","getStoreKey","makeCastingSpecFromRef","fail","QueryClient","stargateStar","Tendermint34Client","tendermintRpcStar","quote","q","textDecoder","TextDecoder","isStreamCell","cell","blockHeight","test","arrayEqual","defaultDataPrefixBytes","collectSingle","count","push","equal","proofs","makeFollower","specP","leaderOrMaker","defaultMakeLeader","decode","unserializer","proof","crasher","crash","e","castingSpecP","tendermintClientPs","provideTendermintClient","endpoint","clientP","connect","getBlockHeight","client","info","abciInfo","lastBlockHeight","endpointToQueryClient","provideQueryClient","queryClient","rpcClient","withExtensions","retryGetDataAndStripPrefix","tryGetPrefixedData","result","subarray","getProvenDataAtHeight","queryVerified","height","getUnprovenDataAtHeight","abciQuery","path","data","prove","code","tryGetDataAtHeight","allegedData","provenData","getDataAtHeight","streamCellForData","text","Number","followerElementFromStreamCellValue","currentBlockHeight","allValuesFromCell","streamCell","reverseValuesFromCell","lastValueFromCell","last","currentData","currentStreamCell","getEachIterableAtHeight","cursorBlockHeight","cursorData","cursorStreamCell","rightBlockHeight","rightData","rightStreamCell","cells","leftBlockHeight","leftData","leftStreamCell","pop","getReverseIterableAtHeight","makeCosmjsFollower","NaN","ai","makeSubscriptionFollower","NO_SMART_WALLET_ERROR","assertHasData","el","isBoardId","specimen","makeWalletSlot","_tables","id","findKey","record","predicate","Object","keys","find","parseWalletSlot","tables","k","initSlotVal","table","val","bySlot","init","byVal","defaultMakePresence","severed","replace","bridgeStorageMessages","bridge","dappToConn","storageListener","ev","key","newValue","keyParts","tag","origin","epoch","_ix","payload","type","dappOrigin","dappKey","stringify","conn","ix","send","payloadOut","window","localStorage","setItem","makeBoot","getScopedBridge","makeCapTP","dispatch","removeItem","handleStorageMessage","addEventListener","removeEventListener","abort","DAPPS_KEY_PREFIX","loadDapps","publicAddress","maybeLoad","getDappService","dapps","updater","makeNotifierKit","broadcastUpdates","updateState","upsertDapp","dapp","enable","petname","maybeSave","filter","d","meta","upsert","deleteDapp","delete","remove","setDappPetname","enableDapp","load","forEach","enableAction","approvedP","actions","setPetname","addDapp","getIssuerService","signSpendAction","suggestions","deleteSuggestion","boardId","addSuggestion","action","suggestedPetname","OFFERS_KEY_PREFIX","loadOffers","removeOffer","offers","o","getOfferService","chainOffersNotifier","chainOffers","upsertOffer","offer","add","status","state","makeAsyncIterableFromNotifier","splitId","rawId","watchChainOffers","addOffer","acceptOffer","spendAction","cancelOffer","_id","declineOffer","suggestedDappPetname","getPursesNotifier","dappService","offerService","issuerService","networkConfig","config","currentTime","Date","getTime","instancePetname","instanceHandleBoardId","requestContext","creationStamp","newId","steps","errors","withApplicationContext","onClose","open","address","href","keplrConnection","currentStep","setCurrentStep","useState","setError","progressIndicator","Box","sx","margin","display","flexDirection","justifyContent","CircularProgress","DialogContentText","pt","content","Link","underline","color","Dialog","DialogTitle","DialogContent","DialogActions","Button","onClick","signers","interactiveSigner","signer","submitProvision","provisionWallet","context","Alert","React","ref","children","props","elevation","variant","connectionConfig","setConnectionStatus","setBackend","setBackendErrorHandler","snackbarMessages","setSnackbarMessages","provisionDialogOpen","setProvisionDialogOpen","showError","severity","ConnectionStatus","sm","smartConnectionMethod","SmartConnectionMethod","backendError","useEffect","cancelIterator","cleanupStorageBridge","makePresence","walletObjects","purse","makeScalarMap","payment","unknown","boardObjects","provideVal","slotToVal","fromBoard","fromMyWallet","valToSlot","marshal","marshalName","initBoardId","ensureBoardId","makeImportContext","followPublished","currentFollower","updateFollower","marshaller","errorHandler","firstCallback","notifiers","getContactsNotifier","getIssuersNotifier","getOffersNotifier","getPaymentsNotifier","notifierKits","fromEntries","entries","_method","stateName","brandToPurse","pursePetnameToBrand","updatePurses","purses","brand","currentAmount","brandPetname","pursePetname","fetchCurrent","currentEl","wallet","brandDescriptor","brands","bd","purseInfo","balance","displayInfo","followLatest","startingHeight","updateRecord","updated","descriptor","prior","purseObj","AmountMath","oldOffer","warn","loadData","getNotifierMethods","method","makeEmptyPurse","addContact","addIssuer","submitSpendAction","addOfferPSMHack","instance","invitationMaker","proposalTemplate","give","want","mapPurses","kw","BigInt","invitationSpec","source","publicInvitationMaker","proposal","serialize","slots","instanceBoardId","fullOffer","getDappsNotifier","getIssuerSuggestionsNotifier","makeWalletBridgeFromFollowers","backendIt","cancel","walletBridge","iterateNotifier","servicesNotifier","board","getBoard","firstSchema","createPurse","issuer","issuerPetname","createContact","depositFacet","createIssuer","services","contacts","issuers","offersMembers","rest","decline","return","throw","payments","issuerSuggestions","backendNotifier","backendUpdater","makeBackendFromWalletBridge","observeIterator","be","finish","follow","Snackbar","_","reason","width"],"sourceRoot":""}