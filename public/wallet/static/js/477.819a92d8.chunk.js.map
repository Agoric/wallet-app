{"version":3,"file":"static/js/477.819a92d8.chunk.js","mappings":"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","sources":["../../../cache/src/state.js","../../../cache/src/store.js","../../../cache/src/cache.js","../../../web-components/src/states.js","../../../web-components/src/admin-websocket-connector.js","../../../web-components/src/bridge-iframe-connector.js","../../../web-components/src/AgoricWalletConnection.js","../../../web-components/src/AgoricIframeMessenger.js","../../../web-components/src/agoric-iframe-messenger.js","../../../web-components/agoric-wallet-connection.js","../../../wallet-connection/react.js","util/fixed-websocket-connector.js","components/WalletConnection.jsx","../../../web-components/react.js"],"sourcesContent":["// @ts-check\n\n/** @typedef {import('./types').State} State */\n\n/**\n * The ground state for a cache key value is `undefined`.  It is impossible to\n * distinguish a set value of `undefined` from an unset key.\n *\n * @type {State}\n */\nexport const GROUND_STATE = harden({ generation: 0n, value: undefined });\n\n/**\n * Create a new state as an update relative to an existing one.\n *\n * @param {any} value\n * @param {State} [priorState]\n * @returns {State}\n */\nexport const makeState = (value, priorState = GROUND_STATE) =>\n  harden({\n    generation: priorState.generation + 1n,\n    value,\n  });\n\n/**\n * Wrap a state store to have a default value using the GROUND_STATE\n *\n * @param {MapStore<string, import('./types').State>} stateStore\n */\nexport const withGroundState = stateStore => ({\n  ...stateStore,\n  get: key => {\n    if (!stateStore.has(key)) {\n      return GROUND_STATE;\n    }\n    return stateStore.get(key);\n  },\n});\nharden(withGroundState);\n","// @ts-check\nimport { E, Far } from '@endo/far';\nimport { deeplyFulfilled, makeMarshal } from '@endo/marshal';\nimport { matches, makeScalarMapStore } from '@agoric/store';\nimport { makeScalarBigMapStore } from '@agoric/vat-data';\nimport { withGroundState, makeState } from './state.js';\n\nimport './types.js';\n\n/**\n * @param {(obj: unknown) => unknown} [sanitize]\n * @returns {(key: Passable) => Promise<string>}\n */\nconst makeKeyToString = (sanitize = obj => obj) => {\n  let lastNonce = 0;\n  const valToNonce = new WeakMap();\n  const valToSlot = val => {\n    let slot = valToNonce.get(val);\n    if (!slot) {\n      lastNonce += 1;\n      slot = lastNonce;\n      valToNonce.set(val, slot);\n    }\n    return slot;\n  };\n\n  const { serialize: keyToJsonable } = makeMarshal(valToSlot);\n  const keyToString = async keyP => {\n    const key = await sanitize(keyP);\n    const obj = keyToJsonable(key);\n    return JSON.stringify(obj);\n  };\n  return keyToString;\n};\n\n/**\n * @param {string} keyStr\n * @param {(oldValue: unknown) => unknown} txn\n * @param {Pattern} guardPattern\n * @param {(obj: unknown) => unknown} sanitize Process keys and values with\n * this function before storing them\n * @param {{\n * get(key: string): import('./types').State;\n * set(key: string, value: import('./types').State): void;\n * init(key: string, value: import('./types').State): void;\n * }} stateStore\n * @returns {Promise<unknown>} the value of the updated state\n */\nconst applyCacheTransaction = async (\n  keyStr,\n  txn,\n  guardPattern,\n  sanitize,\n  stateStore,\n) => {\n  /**\n   * Retrieve a potential updated state from the transaction.\n   *\n   * @param {import('./types').State} basisState\n   * @returns {Promise<import('./types').State | null>} the updated state, or null if no longer applicable\n   */\n  const getUpdatedState = async basisState => {\n    const { value } = basisState;\n    if (!matches(value, guardPattern)) {\n      // value doesn't match, so don't apply the update.\n      return null;\n    }\n\n    const newValue = await sanitize(txn(value));\n    return makeState(newValue, basisState);\n  };\n\n  let basisState = stateStore.get(keyStr);\n  let updatedState = await getUpdatedState(basisState);\n\n  // AWAIT INTERLEAVING\n\n  // Loop until our updated state is fresh wrt our current state.\n  basisState = stateStore.get(keyStr);\n  while (updatedState && updatedState.generation <= basisState.generation) {\n    // eslint-disable-next-line no-await-in-loop\n    updatedState = await getUpdatedState(basisState);\n    // AWAIT INTERLEAVING\n    basisState = stateStore.get(keyStr);\n  }\n\n  if (!updatedState) {\n    // The latest store value doesn't match the guard pattern, so don't\n    // update.\n    return basisState.value;\n  }\n\n  // The guard pattern passes and the updated state is fresh, so update the\n  // store.\n  if (basisState.generation < 1n) {\n    // XXX can encapsulate this logic in the caller and eliminate `init()`\n    stateStore.init(keyStr, updatedState);\n  } else {\n    stateStore.set(keyStr, updatedState);\n  }\n\n  // Return the newly-applied value.\n  return updatedState.value;\n};\n\n/**\n * @param {MapStore<string, import('./types').State>} stateStore\n * @param {ERef<Marshaller>} marshaller\n * @returns {Promise<string>}\n */\nconst stringifyStateStore = async (stateStore, marshaller) => {\n  const obj = {};\n  for (const [key, value] of stateStore.entries()) {\n    obj[key] = E(marshaller).serialize(value);\n  }\n  return deeplyFulfilled(harden(obj)).then(fulfilledObj =>\n    JSON.stringify(fulfilledObj),\n  );\n};\n\n/**\n * Make a cache coordinator backed by a MapStore.  This coordinator doesn't\n * currently enforce any cache eviction, but that would be a useful feature.\n *\n * @param {MapStore<string, import('./types').State>} [stateStore]\n * @param {(obj: unknown) => unknown} [sanitize] Process keys and values with\n * this function before storing them. Defaults to deeplyFulfilled.\n */\nexport const makeScalarStoreCoordinator = (\n  stateStore = makeScalarMapStore(),\n  sanitize = deeplyFulfilled,\n) => {\n  const serializePassable = makeKeyToString(sanitize);\n\n  const defaultStateStore = withGroundState(stateStore);\n\n  /** @type {import('./types').Coordinator} */\n  const coord = Far('store cache coordinator', {\n    getRecentValue: async key => {\n      const keyStr = await serializePassable(key);\n      return defaultStateStore.get(keyStr).value;\n    },\n    setCacheValue: async (key, newValue, guardPattern) => {\n      const keyStr = await serializePassable(key);\n      return applyCacheTransaction(\n        keyStr,\n        () => newValue,\n        guardPattern,\n        sanitize,\n        defaultStateStore,\n      );\n    },\n    updateCacheValue: async (key, updater, guardPattern) => {\n      const keyStr = await serializePassable(key);\n      return applyCacheTransaction(\n        keyStr,\n        oldValue => E(updater).update(oldValue),\n        guardPattern,\n        sanitize,\n        defaultStateStore,\n      );\n    },\n  });\n  return coord;\n};\n\n/**\n * Don't write any marshalled value that's older than what's already pushed\n *\n * @param {MapStore<string, import('./types').State>} stateStore\n * @param {ERef<Marshaller>} marshaller\n * @param {ERef<StorageNode>} storageNode\n * @returns {<T>(storedValue: T) => Promise<T>}\n */\nconst makeLastWinsUpdater = (stateStore, marshaller, storageNode) => {\n  let lastPrepareTicket = 0n;\n  let lastCommitTicket = 0n;\n\n  return async storedValue => {\n    // NB: two phase write (serialize/setValue)\n    // Make sure we're not racing ahead if the marshaller is taking too long, by skipping\n    // setValue (commit) for any serialized (prepare) that's older than the latest commit.\n    lastPrepareTicket += 1n;\n    const marshallTicket = lastPrepareTicket;\n    const serializedStore = await stringifyStateStore(stateStore, marshaller);\n    if (marshallTicket < lastCommitTicket) {\n      // skip setValue() so we don't regress the store state\n      return storedValue;\n    }\n    await E(storageNode).setValue(serializedStore);\n    lastCommitTicket = marshallTicket;\n    return storedValue;\n  };\n};\n\n/**\n * Make a cache coordinator backed by a MapStore.  This coordinator doesn't\n * currently enforce any cache eviction, but that would be a useful feature.\n *\n * @param {ERef<StorageNode>} storageNode\n * @param {ERef<Marshaller>} marshaller\n */\nexport const makeChainStorageCoordinator = (storageNode, marshaller) => {\n  const stateStore = makeScalarBigMapStore('stateKey');\n\n  const sanitize = deeplyFulfilled;\n  const serializePassable = makeKeyToString(sanitize);\n\n  const defaultStateStore = withGroundState(stateStore);\n\n  const updateStorageNode = makeLastWinsUpdater(\n    defaultStateStore,\n    marshaller,\n    storageNode,\n  );\n\n  /** @type {import('./types').Coordinator} */\n  const coord = Far('store cache coordinator', {\n    getRecentValue: async key => {\n      const keyStr = await serializePassable(key);\n      return defaultStateStore.get(keyStr).value;\n    },\n    setCacheValue: async (key, newValue, guardPattern) => {\n      const keyStr = await serializePassable(key);\n      const storedValue = await applyCacheTransaction(\n        keyStr,\n        () => newValue,\n        guardPattern,\n        sanitize,\n        defaultStateStore,\n      );\n      return updateStorageNode(storedValue);\n    },\n    updateCacheValue: async (key, updater, guardPattern) => {\n      const keyStr = await serializePassable(key);\n      const storedValue = await applyCacheTransaction(\n        keyStr,\n        oldValue => E(updater).update(oldValue),\n        guardPattern,\n        sanitize,\n        defaultStateStore,\n      );\n      return updateStorageNode(storedValue);\n    },\n  });\n  return coord;\n};\n","// @ts-check\nimport { E, Far } from '@endo/far';\n\nimport { makeScalarStoreCoordinator } from './store.js';\n\n/** @template T @typedef {import('@endo/far').ERef<T>} ERef */\n\n/**\n * @typedef {{ [x: PropertyKey]: any } | string | symbol | bigint | null |\n * undefined | number | ((oldValue: any) => ERef<unknown>)} Update a `newValue`\n * to update to.  If a function, then it should take an oldValue and return a\n * `newValue` or promise for `newValue`\n */\n\n/**\n * @param {ERef<import('./types').Coordinator>} [coordinator]\n */\nexport const makeCache = (coordinator = makeScalarStoreCoordinator()) => {\n  /**\n   * The ground state for a cache key value is `undefined`.  It is impossible to\n   * distinguish a set value of `undefined` from an unset key\n   *\n   * @param {unknown} key the cache key (any key type acceptable to the cache)\n   * @param {[] | [Update] | [Update, Pattern]} optUpdateGuardPattern an optional\n   */\n  const cache = (key, ...optUpdateGuardPattern) => {\n    if (optUpdateGuardPattern.length === 0) {\n      return E(coordinator).getRecentValue(key);\n    }\n\n    const [update, guardPattern] = optUpdateGuardPattern;\n    if (typeof update !== 'function') {\n      return E(coordinator).setCacheValue(key, update, guardPattern);\n    }\n\n    const updater = Far('cache updater', {\n      update: oldValue => {\n        return update(oldValue);\n      },\n    });\n    return E(coordinator).updateCacheValue(key, updater, guardPattern);\n  };\n\n  return cache;\n};\n","// @ts-check\nimport {\n  createMachine,\n  guard,\n  immediate,\n  reduce as rawReduce,\n  state,\n  transition,\n} from 'robot3';\n\n/**\n * @typedef {object} Context\n * @property {any?} error\n * @property {string?} location\n * @property {Record<string,any>} connectionParams\n */\n\n/**\n * @type {(fn: import('robot3').ReduceFunction<Context, any>) =>\n * import('robot3').Reducer<Context, any>}\n */\nconst reduce = rawReduce;\n\n/**\n * @returns {Context}\n */\nconst initialContext = () => ({\n  error: null,\n  location: null,\n  connectionParams: {},\n});\n\nconst common = [\n  // Allow the 'reset' event to go back to the 'idle' state.\n  transition('reset', 'idle', reduce(initialContext)),\n  // Make the 'error' event go to the 'error' state.\n  transition(\n    'error',\n    'error',\n    reduce((ctx, ev) => ({ ...ctx, error: ev.error })),\n  ),\n];\n\n/**\n * Create a state machine for the wallet connection.\n */\nexport const makeConnectionMachine = () =>\n  createMachine(\n    {\n      idle: state(\n        ...common,\n        transition(\n          'locate',\n          'locating',\n          reduce((ctx, ev) => ({\n            ...ctx,\n            connectionParams: ev.connectionParams,\n          })),\n        ),\n        transition('connect', 'connecting'),\n      ),\n      locating: state(\n        ...common,\n        immediate(\n          'connecting',\n          guard(({ location }) => !!location),\n        ),\n        transition(\n          'located',\n          'connecting',\n          reduce((ctx, ev) => ({ ...ctx, location: ev.href })),\n        ),\n      ),\n      connecting: state(...common, transition('connected', 'bridged')),\n      bridged: state(...common, transition('needDappApproval', 'approving')),\n      approving: state(\n        ...common,\n        transition('needDappApproval', 'approving'),\n        transition('dappApproved', 'bridged'),\n      ),\n      error: state(...common),\n    },\n    initialContext,\n  );\n","/* eslint-disable no-underscore-dangle */\nimport { E } from '@endo/eventual-send';\n\nconst CONNECTION_TIMEOUT_MS = 5000;\n\n// Wait for the wallet to finish loading.\nexport const waitForBootstrap = async getBootstrap => {\n  const getLoadingUpdate = (...args) =>\n    E(E.get(getBootstrap()).loadingNotifier).getUpdateSince(...args);\n  let update = await getLoadingUpdate();\n  while (update.value.includes('wallet')) {\n    console.log('waiting for wallet');\n    // eslint-disable-next-line no-await-in-loop\n    update = await getLoadingUpdate(update.updateCount);\n  }\n\n  return getBootstrap();\n};\n\nexport const makeAdminWebSocketConnector = component => {\n  let ws;\n\n  const onAdminOpen = () => {\n    const send = obj => {\n      if (ws.readyState !== WebSocket.OPEN) {\n        return;\n      }\n      ws.send(JSON.stringify(obj));\n    };\n    component._startCapTP(send, 'walletAdmin');\n\n    assert(component._captp);\n    const { dispatch, getBootstrap } = component._captp;\n\n    ws.addEventListener('message', ev => {\n      const obj = JSON.parse(ev.data);\n      dispatch(obj);\n    });\n\n    const adminFacet = E(\n      E.get(waitForBootstrap(getBootstrap)).wallet,\n    ).getAdminFacet();\n    adminFacet.then(component.service.send({ type: 'connected' }));\n    component._bridgePK.resolve(adminFacet);\n  };\n\n  return {\n    render: () => '',\n    hostConnected: () => {\n      const {\n        location,\n        connectionParams: { accessToken },\n      } = component.service.context;\n      assert(location);\n\n      const hrefs = [location, window.location.href];\n      const connect = () => {\n        // Cycle through the hrefs to find the websocket protocol for this path.\n        const href = hrefs.shift();\n        const url = new URL('/private/captp', href);\n        url.protocol = url.protocol.replace(/^http/, 'ws');\n\n        if (accessToken) {\n          url.searchParams.set('accessToken', accessToken);\n        }\n\n        const onClose = _ev => {\n          if (hrefs.length > 0) {\n            return connect();\n          }\n          return component.reset();\n        };\n\n        ws = new WebSocket(url.href);\n        const timeout = window.setTimeout(() => {\n          ws.close();\n        }, CONNECTION_TIMEOUT_MS);\n\n        ws.addEventListener('open', ev => {\n          window.clearTimeout(timeout);\n          return onAdminOpen(ev);\n        });\n        ws.addEventListener('close', onClose);\n        ws.addEventListener('error', () => {});\n      };\n      connect(location);\n    },\n    hostDisconnected: () => {\n      ws.close();\n    },\n  };\n};\n","/* eslint-disable no-underscore-dangle */\nimport { html } from 'lit';\nimport { assert, details as X } from '@agoric/assert';\n\nexport const makeBridgeIframeConnector = component => {\n  const connectedOnMessage = ev => {\n    console.log(component.state, 'bridge received', ev);\n    const { data } = ev.detail;\n    if (data && typeof data.type === 'string') {\n      if (data.type === 'walletBridgeClosed') {\n        component.reset();\n      }\n      if (data.type.startsWith('CTP_')) {\n        assert(component._captp);\n        component._captp.dispatch(data);\n      }\n    }\n  };\n\n  let onMessage = event => {\n    console.log(component.state, 'connect received', event);\n    const { data, send } = event.detail;\n    assert.equal(\n      data.type,\n      'walletBridgeLoaded',\n      X`Unexpected connect message type ${data.type}`,\n    );\n\n    component._startCapTP(\n      send,\n      component.service.context.suggestedDappPetname,\n      component._walletCallbacks,\n    );\n\n    onMessage = connectedOnMessage;\n\n    // Received bridge announcement, so mark the connection as bridged.\n    component.service.send({ type: 'connected' });\n    component._bridgePK.resolve(component._captp.getBootstrap());\n  };\n\n  return {\n    render: () => {\n      const {\n        location,\n        connectionParams: { suggestedDappPetname },\n      } = component.service.context;\n      assert(location);\n      const url = new URL(location);\n      if (suggestedDappPetname) {\n        url.searchParams.append('suggestedDappPetname', suggestedDappPetname);\n      }\n      return html`\n        <agoric-iframe-messenger\n          src=${url.href}\n          @message=${onMessage}\n          @error=${component.onError}\n        ></agoric-iframe-messenger>\n      `;\n    },\n    hostConnected() {},\n    hostDisconnected() {},\n  };\n};\n","/* eslint-disable no-underscore-dangle */\n// @ts-check\nimport { html, css, LitElement } from 'lit';\n\nimport { assert, details as X } from '@agoric/assert';\nimport { makeCache } from '@agoric/cache';\nimport { makeCapTP as defaultMakeCapTP } from '@endo/captp';\nimport { E } from '@endo/eventual-send';\nimport { Far } from '@endo/marshal';\nimport { makePromiseKit } from '@endo/promise-kit';\n\nimport 'robot3/debug';\nimport { interpret } from 'robot3';\n\nimport { makeConnectionMachine } from './states.js';\n\nimport { makeAdminWebSocketConnector } from './admin-websocket-connector.js';\nimport { makeBridgeIframeConnector } from './bridge-iframe-connector.js';\n\n// Delay after a reset.\nconst RESET_DELAY_MS = 3000;\n\n// TODO: Use something on agoric.app instead.\nconst DEFAULT_LOCATOR_URL =\n  'https://local.agoric.com/?append=/wallet-bridge.html';\n\nconst LOCAL_STORAGE_LOCATOR_URL =\n  'https://local.agoric.com/?append=/wallet/bridge.html';\n\nconst delay = (ms, resolution) =>\n  new Promise(resolve => setTimeout(resolve, ms, resolution));\n\nexport const makeAgoricWalletConnection = (makeCapTP = defaultMakeCapTP) =>\n  class AgoricWalletConnection extends LitElement {\n    static get styles() {\n      return css`\n        :host {\n          display: block;\n          padding: 8px;\n          color: var(--agoric-wallet-connection-text-color, #737373);\n        }\n        .connection {\n          background-color: #fff;\n        }\n        .connection-message {\n          text-align: center;\n        }\n        .connection-message > a {\n          text-decoration: none;\n          color: #1976d2;\n        }\n      `;\n    }\n\n    static get properties() {\n      return {\n        state: { type: String },\n        useLocalStorage: { type: Boolean },\n      };\n    }\n\n    get state() {\n      return this.machine.state.name;\n    }\n\n    async reset() {\n      if (this.isResetting) {\n        return;\n      }\n      this.isResetting = true;\n      await delay(RESET_DELAY_MS, 'reset');\n      if (this._captp) {\n        this._captp.abort();\n        this._captp = null;\n      }\n      if (this._connector) {\n        this._connector.hostDisconnected();\n        this._connector = null;\n      }\n\n      // Just make sure the reconnection logic is triggered.\n      this._bridgePK = makePromiseKit();\n      this._cache = undefined;\n      this._makeDefaultLeader = undefined;\n\n      this.service.send({ type: 'reset' });\n      this.isResetting = false;\n    }\n\n    get cache() {\n      if (this._cache) {\n        // The cache is cached.\n        return this._cache;\n      }\n      const cache = makeCache(E(this._bridgePK.promise).getCacheCoordinator());\n      this._cache = cache;\n      return this._cache;\n    }\n\n    get walletConnection() {\n      if (this._walletConnection) {\n        // Cached.\n        return this._walletConnection;\n      }\n\n      this._walletConnection = Far('WalletConnection', {\n        getScopedBridge: (\n          suggestedDappPetname,\n          dappOrigin = window.location.origin,\n          makeConnector = makeBridgeIframeConnector,\n        ) => {\n          assert.equal(\n            this.state,\n            'idle',\n            X`Cannot get scoped bridge in state ${this.state}`,\n          );\n          this.service.send({\n            type: 'locate',\n            connectionParams: {\n              caller: 'getScopedBridge',\n              suggestedDappPetname,\n              dappOrigin,\n              makeConnector,\n            },\n          });\n          return this._bridgePK.promise;\n        },\n        getAdminBootstrap: (\n          accessToken,\n          makeConnector = makeAdminWebSocketConnector,\n        ) => {\n          assert.equal(\n            this.state,\n            'idle',\n            X`Cannot get admin bootstrap in state ${this.state}`,\n          );\n          this.service.send({\n            type: 'locate',\n            connectionParams: {\n              caller: 'getAdminBootstrap',\n              accessToken,\n              makeConnector,\n            },\n          });\n          return this._bridgePK.promise;\n        },\n        reset: () => {\n          this.reset();\n        },\n      });\n\n      return this._walletConnection;\n    }\n\n    constructor() {\n      super();\n      this.useLocalStorage = false;\n      // This state machine integration is much like lit-robot, but also raises\n      // state events.\n      const machine = makeConnectionMachine();\n      const onState = (service, requestUpdate = true) => {\n        this.machine = service.machine;\n        const ev = new CustomEvent('state', {\n          detail: {\n            ...this.machine.context,\n            state: this.machine.state.name,\n            walletConnection: this.walletConnection,\n            cache: this.cache,\n          },\n        });\n        this.dispatchEvent(ev);\n        if (requestUpdate) {\n          this.requestUpdate();\n        }\n      };\n      this.service = interpret(machine, onState);\n      this.machine = this.service.machine;\n\n      // Wait until we load before sending the first state.\n      this.firstUpdated = () => onState(this.service, false);\n\n      this._nextEpoch = 0;\n      this._bridgePK = makePromiseKit();\n\n      this._walletCallbacks = Far('walletCallbacks', {\n        needDappApproval: (dappOrigin, suggestedDappPetname) => {\n          this.service.send({\n            type: 'needDappApproval',\n            dappOrigin,\n            suggestedDappPetname,\n          });\n        },\n        dappApproved: dappOrigin => {\n          this.service.send({ type: 'dappApproved', dappOrigin });\n        },\n      });\n    }\n\n    onLocateMessage(ev) {\n      console.log(this.state, 'locate', ev);\n      const { data } = ev.detail;\n      assert.typeof(data, 'string', X`Expected locate message to be a string`);\n      this.service.send({ type: 'located', href: data });\n    }\n\n    onError(event) {\n      console.log(this.state, 'error', event);\n      this.service.send({\n        type: 'error',\n        error: (event.detail && event.detail.error) || 'Unknown error',\n      });\n\n      // Allow retries to get a fresh bridge.\n      this._captp = null;\n    }\n\n    _startCapTP(send, ourEndpoint, ourPublishedBootstrap) {\n      // Start a new epoch of the bridge captp.\n      const epoch = this._nextEpoch;\n      this._nextEpoch += 1;\n\n      this._captp = makeCapTP(\n        `${ourEndpoint}.${epoch}`,\n        obj => {\n          // console.log('sending', obj);\n          send(obj);\n        },\n        ourPublishedBootstrap,\n        { epoch },\n      );\n    }\n\n    disconnectedCallback() {\n      super.disconnectedCallback();\n      if (this._captp) {\n        this._captp.abort();\n        this._captp = null;\n      }\n      if (this._connector) {\n        this._connector.hostDisconnected();\n        this._connector = null;\n      }\n    }\n\n    render() {\n      /** @type {import('lit-html').TemplateResult<1> | undefined} */\n      let backend;\n      const locatorHref = this.useLocalStorage\n        ? LOCAL_STORAGE_LOCATOR_URL\n        : DEFAULT_LOCATOR_URL;\n\n      switch (this.state) {\n        case 'locating': {\n          backend = html`\n            <agoric-iframe-messenger\n              src=${locatorHref}\n              @message=${this.onLocateMessage}\n              @error=${this.onError}\n            ></agoric-iframe-messenger>\n          `;\n          break;\n        }\n        case 'approving':\n        case 'bridged':\n        case 'connecting': {\n          if (!this._connector) {\n            this._connector =\n              this.service.context.connectionParams.makeConnector(this);\n            this._connector.hostConnected();\n          }\n          backend = this._connector.render();\n          break;\n        }\n        default:\n      }\n\n      const locatorUrl = new URL(locatorHref);\n\n      return html`\n        <div class=\"connection\">\n          ${backend}\n          <div class=\"connection-message\">\n            Wallet URL configured in\n            <a href=${locatorUrl.origin} target=\"_blank\">${locatorUrl.host}</a>\n          </div>\n        </div>\n      `;\n    }\n  };\n\nexport const AgoricWalletConnection = makeAgoricWalletConnection();\n","/* eslint-disable no-underscore-dangle */\n// @ts-check\nimport { LitElement, html, css } from 'lit';\n\nimport { assert } from '@agoric/assert';\n\nconst CONNECTION_TIMEOUT_MS = 5000;\n\nexport const makeAgoricIframeMessenger = (registerThis = _that => {}) =>\n  class AgoricIframeMessenger extends LitElement {\n    static get properties() {\n      return { src: { type: String } };\n    }\n\n    static get styles() {\n      return css`\n        :host {\n          display: block;\n        }\n        iframe {\n          border: none;\n          overflow: auto;\n          height: 64px;\n        }\n      `;\n    }\n\n    constructor() {\n      super();\n      this.src = '';\n      this._contentWindow = null;\n      this._origin = null;\n      this._timeout = undefined;\n\n      // Need to bind since these aren't declarative event handlers.\n      this.send = this.send.bind(this);\n      this._onMessage = this._onMessage.bind(this);\n      registerThis(this);\n    }\n\n    connectedCallback() {\n      super.connectedCallback();\n      window.addEventListener('message', this._onMessage);\n    }\n\n    disconnectedCallback() {\n      window.removeEventListener('message', this._onMessage);\n      super.disconnectedCallback();\n    }\n\n    render() {\n      return html`\n        <iframe\n          title=\"Agoric Iframe Messenger\"\n          src=${this.src}\n          @abort=${this._onError}\n          @error=${this._onError}\n          scrolling=\"no\"\n        ></iframe>\n      `;\n    }\n\n    updated() {\n      this._origin = new URL(this.src).origin;\n    }\n\n    firstUpdated() {\n      const iframe = this.renderRoot.querySelector('iframe');\n      assert(iframe);\n      // Detect the content window of the iframe to verify message sources.\n      this._contentWindow = iframe.contentWindow;\n      this._timeout = window.setTimeout(() => {\n        const ev = new CustomEvent('error', {\n          detail: { error: new Error('connection timeout') },\n        });\n        this.dispatchEvent(ev);\n      }, CONNECTION_TIMEOUT_MS);\n    }\n\n    _onMessage(event) {\n      // console.log('iframe message', event);\n      if (event.source !== this._contentWindow) {\n        return;\n      }\n\n      if (this._timeout) {\n        window.clearTimeout(this._timeout);\n        this._timeout = undefined;\n      }\n      event.preventDefault();\n\n      const ev = new CustomEvent('message', {\n        detail: { data: event.data, send: this.send },\n      });\n      this.dispatchEvent(ev);\n    }\n\n    _onError(event) {\n      event.preventDefault();\n      const ev = new CustomEvent('error', { detail: { error: event.error } });\n      this.dispatchEvent(ev);\n    }\n\n    send(data) {\n      assert(this._contentWindow);\n      assert(this._origin);\n      this._contentWindow.postMessage(data, this._origin);\n    }\n  };\n\nexport const AgoricIframeMessenger = makeAgoricIframeMessenger();\n","import { AgoricIframeMessenger } from './AgoricIframeMessenger.js';\n\nwindow.customElements.define('agoric-iframe-messenger', AgoricIframeMessenger);\n","import { AgoricWalletConnection } from './src/AgoricWalletConnection.js';\nimport './src/agoric-iframe-messenger.js';\n\nwindow.customElements.define(\n  'agoric-wallet-connection',\n  AgoricWalletConnection,\n);\n","export { makeReactAgoricWalletConnection } from '@agoric/web-components/react.js';\nconsole.warn(\n  'This package is deprecated. Use @agoric/web-components instead of @agoric/wallet-connection.',\n);\n","/* eslint-disable no-underscore-dangle */\nimport { E } from '@endo/eventual-send';\n\nconst CONNECTION_TIMEOUT_MS = 5000;\n\n// Wait for the wallet to finish loading.\nexport const waitForBootstrap = async getBootstrap => {\n  const getLoadingUpdate = (...args) =>\n    E(E.get(getBootstrap()).loadingNotifier).getUpdateSince(...args);\n  let update = await getLoadingUpdate();\n  while (update.value.includes('wallet')) {\n    console.log('waiting for wallet');\n    // eslint-disable-next-line no-await-in-loop\n    update = await getLoadingUpdate(update.updateCount);\n  }\n\n  return getBootstrap();\n};\n\nexport const makeFixedWebSocketConnector = href => component => {\n  let ws;\n\n  const onAdminOpen = () => {\n    const send = obj => {\n      if (ws.readyState !== WebSocket.OPEN) {\n        return;\n      }\n      ws.send(JSON.stringify(obj));\n    };\n    component._startCapTP(send, 'walletAdmin');\n\n    assert(component._captp);\n    const { dispatch, getBootstrap } = component._captp;\n\n    ws.addEventListener('message', ev => {\n      const obj = JSON.parse(ev.data);\n      dispatch(obj);\n    });\n\n    const adminFacet = E(\n      E.get(waitForBootstrap(getBootstrap)).wallet,\n    ).getAdminFacet();\n    adminFacet.then(component.service.send({ type: 'connected' }));\n    component._bridgePK.resolve(adminFacet);\n  };\n\n  return {\n    render: () => '',\n    hostConnected: () => {\n      const {\n        location,\n        connectionParams: { accessToken },\n      } = component.service.context;\n      assert(location);\n\n      const connect = () => {\n        // Cycle through the hrefs to find the websocket protocol for this path.\n        const url = new URL('/private/captp', href);\n        url.protocol = url.protocol.replace(/^http/, 'ws');\n\n        if (accessToken) {\n          url.searchParams.set('accessToken', accessToken);\n        }\n\n        const onClose = _ev => {\n          return component.reset();\n        };\n\n        ws = new WebSocket(url.href);\n        const timeout = window.setTimeout(() => {\n          ws.close();\n        }, CONNECTION_TIMEOUT_MS);\n\n        ws.addEventListener('open', ev => {\n          window.clearTimeout(timeout);\n          return onAdminOpen(ev);\n        });\n        ws.addEventListener('close', onClose);\n        ws.addEventListener('error', () => {});\n      };\n      connect(location);\n    },\n    hostDisconnected: () => {\n      ws.close();\n    },\n  };\n};\n","// @ts-check\n/* eslint-disable no-underscore-dangle */\n/* eslint-disable import/no-extraneous-dependencies */\n/* eslint-disable react/display-name */\nimport { makeReactAgoricWalletConnection } from '@agoric/wallet-connection/react.js';\nimport React, { useState, useEffect } from 'react';\nimport { E } from '@endo/eventual-send';\nimport { observeIterator } from '@agoric/notifier';\nimport { makeStyles } from '@mui/styles';\n\nimport { withApplicationContext } from '../contexts/Application.jsx';\nimport { makeBackendFromWalletBridge } from '../util/WalletBackendAdapter.js';\nimport { makeFixedWebSocketConnector } from '../util/fixed-websocket-connector.js';\nimport { bridgeStorageMessages } from '../util/BridgeStorage.js';\n\nconst useStyles = makeStyles(_ => ({\n  hidden: {\n    display: 'none',\n  },\n}));\n\n// Create a wrapper for agoric-wallet-connection that is specific to\n// the app's instance of React.\nconst AgoricWalletConnection = makeReactAgoricWalletConnection(React);\n\nconst WalletConnection = ({\n  setBackend,\n  setConnectionState,\n  disconnect,\n  connectionConfig,\n}) => {\n  const classes = useStyles();\n  /**\n   * TODO: where to get the full types for these?\n   *\n   * @typedef {{\n   *   getAdminBootstrap: (accessToken: any, makeConnector?: any) => WalletBridge\n   * }} WalletConnection\n   * @typedef {{\n   *   getScopedBridge: (suggestedDappPetname: unknown, dappOrigin?: unknown, makeConnector?: unknown) => unknown\n   * }} WalletBridge\n   */\n  const [wc, setWC] = useState(/** @type {WalletConnection|null} */ (null));\n\n  let cancelled = null;\n  const onWalletState = ev => {\n    if (cancelled) {\n      return;\n    }\n    const { walletConnection: newWC, state } = ev.detail;\n    setConnectionState(state);\n    if (!wc) {\n      setWC(newWC);\n    }\n  };\n\n  useEffect(() => {\n    if (!wc) {\n      return () => {};\n    }\n    const bridge = E(wc).getAdminBootstrap(\n      connectionConfig.accessToken,\n      makeFixedWebSocketConnector(connectionConfig.href),\n    );\n\n    const { backendIt, cancel } = makeBackendFromWalletBridge(bridge);\n    const rethrowIfNotCancelled = e => {\n      if (!cancelled) {\n        throw e;\n      }\n    };\n\n    observeIterator(backendIt, {\n      updateState: be => {\n        if (cancelled) {\n          throw Error('cancelled');\n        }\n        setBackend(be);\n      },\n    }).catch(rethrowIfNotCancelled);\n\n    const cleanupStorageBridge = bridgeStorageMessages(bridge);\n\n    return () => {\n      cancelled = true;\n      cleanupStorageBridge();\n      disconnect();\n      cancel();\n    };\n  }, [wc]);\n\n  return (\n    <AgoricWalletConnection\n      onState={onWalletState}\n      className={classes.hidden}\n    />\n  );\n};\n\nexport default withApplicationContext(WalletConnection, context => ({\n  setConnectionState: context.setConnectionState,\n  disconnect: context.disconnect,\n  setBackend: context.setBackend,\n  connectionConfig: context.connectionConfig,\n}));\n","import { createComponent } from '@lit-labs/react';\n\nimport { AgoricWalletConnection } from './index.js';\n\n// Upgrade the tags.\nimport './agoric-wallet-connection.js';\n\nexport const makeReactAgoricWalletConnection = React =>\n  createComponent(React, 'agoric-wallet-connection', AgoricWalletConnection, {\n    onState: 'state',\n  });\n"],"names":["GROUND_STATE","harden","generation","value","undefined","withGroundState","stateStore","get","key","has","makeKeyToString","sanitize","obj","lastNonce","valToNonce","WeakMap","valToSlot","val","slot","set","serialize","keyToJsonable","makeMarshal","keyToString","async","keyP","JSON","stringify","applyCacheTransaction","keyStr","txn","guardPattern","getUpdatedState","basisState","matches","makeState","updatedState","init","makeScalarStoreCoordinator","makeScalarMapStore","deeplyFulfilled","serializePassable","defaultStateStore","coord","Far","getRecentValue","setCacheValue","newValue","updateCacheValue","updater","oldValue","E","update","makeCache","coordinator","cache","optUpdateGuardPattern","length","reduce","rawReduce","initialContext","error","location","connectionParams","common","transition","ctx","ev","makeConnectionMachine","createMachine","idle","state","locating","immediate","guard","href","connecting","bridged","approving","makeAdminWebSocketConnector","component","ws","onAdminOpen","_startCapTP","readyState","WebSocket","OPEN","send","assert","_captp","dispatch","getBootstrap","addEventListener","parse","data","adminFacet","getLoadingUpdate","loadingNotifier","getUpdateSince","includes","console","log","updateCount","waitForBootstrap","wallet","getAdminFacet","then","service","type","_bridgePK","resolve","render","hostConnected","accessToken","context","hrefs","window","connect","shift","url","URL","protocol","replace","searchParams","timeout","setTimeout","close","clearTimeout","_ev","reset","hostDisconnected","makeBridgeIframeConnector","connectedOnMessage","detail","startsWith","onMessage","event","X","suggestedDappPetname","_walletCallbacks","append","html","onError","DEFAULT_LOCATOR_URL","LOCAL_STORAGE_LOCATOR_URL","delay","ms","resolution","Promise","AgoricWalletConnection","makeCapTP","defaultMakeCapTP","LitElement","styles","css","properties","String","useLocalStorage","Boolean","this","machine","name","isResetting","abort","_connector","makePromiseKit","_cache","_makeDefaultLeader","promise","getCacheCoordinator","walletConnection","_walletConnection","getScopedBridge","dappOrigin","origin","makeConnector","caller","getAdminBootstrap","constructor","super","onState","requestUpdate","CustomEvent","dispatchEvent","interpret","firstUpdated","_nextEpoch","needDappApproval","dappApproved","onLocateMessage","ourEndpoint","ourPublishedBootstrap","epoch","disconnectedCallback","backend","locatorHref","locatorUrl","host","makeAgoricWalletConnection","AgoricIframeMessenger","registerThis","_that","src","_contentWindow","_origin","_timeout","bind","_onMessage","connectedCallback","removeEventListener","_onError","updated","iframe","renderRoot","querySelector","contentWindow","Error","source","preventDefault","postMessage","makeAgoricIframeMessenger","customElements","define","warn","makeFixedWebSocketConnector","useStyles","makeStyles","_","hidden","display","React","createComponent","withApplicationContext","setBackend","setConnectionState","disconnect","connectionConfig","classes","wc","setWC","useState","cancelled","useEffect","bridge","backendIt","cancel","makeBackendFromWalletBridge","observeIterator","updateState","be","catch","e","cleanupStorageBridge","bridgeStorageMessages","newWC","className"],"sourceRoot":""}