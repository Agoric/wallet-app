"use strict";(globalThis.webpackChunk_agoric_wallet_ui=globalThis.webpackChunk_agoric_wallet_ui||[]).push([[858],{1858:(e,t,r)=>{r.r(t),r.d(t,{default:()=>Ne});var n=r(3876),a=r(7017),o=r(8848);const s="http://localhost:26657",i=e=>new Promise((t=>setTimeout(t,e))),c=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e;return Math.random()*Math.min(t,e)},l=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3e4;return c(2**e*t,r)},d=e=>{const t=c(5e3);return console.warn(`jittering ${e} by ${Math.ceil(t)}ms`),i(t)},u=function(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const n=l(r);return console.warn(`retrying ${e} in ${Math.ceil(n)}ms after attempt #${r}`,t),i(n)},f=()=>i(c(5e3)).then((()=>!0)),g=()=>harden((e=>{try{return harden(JSON.parse(e))}catch(t){throw new Error(`Cannot decode alleged JSON (${t.message}): ${e}`)}})),p=()=>{const e="Alleged: ",t=new Map;return(0,a.cI)("marshal unserializer",{unserialize:(0,o.AU)(void 0,((r,n)=>{if(t.has(r))return t.get(r);"string"===typeof n&&n.startsWith(e)&&(n=n.slice(e.length));const o=(0,a.cI)(`SEVERED: ${n}`,{});return t.set(r,o),o})).unserialize})},h=e=>{for(let t=e.length-1;t>0;t-=1){const r=Math.floor(Math.random()*(t+1)),n=e[t];e[t]=e[r],e[r]=n}},y=async e=>{const{keepPolling:t=f}=await(0,a.E)(e).getOptions(),r=(0,a.cI)("polling change follower iterable",{[Symbol.asyncIterator]:()=>{let r;return(0,a.cI)("polling change follower iterator",{next:async()=>{r||(r=t("polling change follower").then((t=>t?(0,a.E)(e).jitter("polling change follower").then((()=>t)):t)));const n=await r;r=void 0;const o=harden({values:[]});return harden({value:o,done:!n})}})}});return(0,a.cI)("polling change follower",{getLatestIterable:async()=>r,getEachIterable:async()=>r,getReverseIterable:async()=>{throw Error("not implemented for polling change follower")}})},{details:m}=assert,b=(e,t)=>{assert(Array.isArray(e),m`rpcAddrs ${e} must be an array`);return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{retryCallback:r=u,jitter:n=d}=t;h(e);let o,s=0,i=0;const c=(0,a.cI)("round robin leader",{getOptions:()=>t,jitter:async e=>n&&n(e),retry:async(e,t,n)=>{if(r)return r(e,t,n);throw t},watchCasting:e=>l,mapEndpoints:async(t,r)=>(t=`${t} (round-robin endpoints)`,new Promise(((l,d)=>{let u=s;const f=r=>{if(!o){const n=i;o=(0,a.E)(c).retry(t,r,n).then((()=>{u=(u+1)%e.length,o=null}))}o.then((()=>n&&n(t))).then(g,d),i+=1},g=()=>{Promise.resolve().then((()=>r(e[u]))).then((e=>{l(harden([e])),s=u,i=0}),f)};g()})))}),l=y(c);return c}(e.map((e=>(assert.typeof(e,"string",m`rpcAddr ${e} must be a string`),e.includes("://")?e:`http://${e}`))),t)},w=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{retryCallback:r=u,jitter:n=d}=t,a=async(e,t,n)=>{if(r)return r(e,t,n);throw t};let o=0;const s="Network config leader";return new Promise(((r,i)=>{const c=async()=>{const r=await fetch(e,{headers:{accept:"application/json"}}),{rpcAddrs:n}=await r.json();return o=0,b(n,t)},l=async e=>{a(s,e,o).then((()=>n(s))).then((()=>c().then(r,l))).catch(i),o+=1};c().then(r,l)}))},v=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:s,t=arguments.length>1?arguments[1]:void 0;return e.includes("network-config")?w(e,t):b([e],t)},E=e=>(0,n.a2)((0,a.E)(e).getSharableNotifierInternals()),S=e=>harden({[Symbol.asyncIterator]:()=>{return t=(0,a.E)(e).getSharableSubscriptionInternals(),(0,a.cI)("SubscriptionIterator",{next:async()=>{const e=a.E.get(t).head;return t=a.E.get(t).tail,e}});var t}}),I=(e,t)=>async function*(){for await(const r of e)yield t(r)}(),k=(e,t)=>(0,a.cI)("iterateEach iterable",{[Symbol.asyncIterator]:()=>{const r=(0,a.E)(e).getEachIterable(t),n=(0,a.E)(r)[Symbol.asyncIterator]();return(0,a.cI)("iterateEach iterator",{next:()=>(0,a.E)(n).next()})}}),$=(e,t)=>(0,a.cI)("iterateReverse iterable",{[Symbol.asyncIterator]:()=>{const r=(0,a.E)(e).getReverseIterable(t),n=(0,a.E)(r)[Symbol.asyncIterator]();return(0,a.cI)("iterateEach iterator",{next:()=>(0,a.E)(n).next()})}});var O=r(2039),N=r.t(O,2),P=r(6578),A=r.t(P,2),C=r(2363),B=r.t(C,2);const{toAscii:M}=B,j=".".charCodeAt(0),x=new Uint8Array([0]),H=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"vstorage";const r=e?e.split("."):[],n=M(`${r.length}.${e}`);return harden({storeName:t,storeSubkey:n.map((e=>e===j?0:e)),dataPrefixBytes:x})},W=harden({"swingset:":e=>harden({storeName:"swingset",storeSubkey:M(`swingset/data:${e}`)}),"vstore:":H,":":H}),T=new TextEncoder,D=e=>{const{storeName:t,storeSubkey:r,dataPrefixBytes:n,subscription:a,notifier:o}=e;if(a||o)return harden({subscription:a,notifier:o});let s=r;"string"===typeof r&&(s=T.encode(r));let i=n;return"string"===typeof n&&(i=T.encode(n)),harden({storeName:t,storeSubkey:s,dataPrefixBytes:i})},V=async e=>{const t=await e;if("string"===typeof t)return(e=>{assert.typeof(e,"string");const t=e.match(/^([^:.]*:)(.*)/);assert(t,`spec string ${e} does not match 'PREFIX:PATH' or ':PATH'`);const r=t[1],n=t[2],a=W[r];return assert(a,`Unknown pathKind ${r}`),a(n)})(t);const{storeName:r,subscription:n,notifier:o}=t;return r||n||o?D(t):(0,a.mY)(t)?(async e=>{const t=await(0,a.E)(e).getStoreKey();return D(t)})(t):void assert.fail(`CastingSpec ${t} is not a string, object, or ref`)},{QueryClient:R}=A,{Tendermint34Client:z}=N,{details:J,quote:U}=assert,L=new TextDecoder,q=e=>e&&"object"===typeof e&&Array.isArray(e.values)&&"string"===typeof e.blockHeight&&/^0$|^[1-9][0-9]*$/.test(e.blockHeight),F=(e,t)=>{if(e.length!==t.length)return!1;for(let r=0;r<e.length;r+=1)if(e[r]!==t[r])return!1;return!0},G=new Uint8Array,K=e=>{const t=[];let r=0;for(const n of e)r+=1,1===r?t.push(n):assert.fail(`expected single value, got at least ${r}`);return assert.equal(t.length,1,"expected single value"),t[0]},_=["strict","none","optimistic"],Q=async(e,t,r)=>{const n=await V(e),{storeName:o}=n;return o?function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:v,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const{decode:n=g(),unserializer:o=p(),proof:s="optimistic",crasher:i=null}=r,c=e=>{throw i&&(0,a.E)(i).crash("PROOF VERIFICATION FAILURE; crashing follower",e).catch((e=>assert.fail(J`crashing follower failed: ${e}`))),e};assert(_.includes(s),J`unrecognized follower proof mode ${s}`);const l="CosmJS follower",d=V(e),u="function"===typeof t?t():t,f=new Map,h=e=>{let t=f.get(e);return t||(t=z.connect(e),f.set(e,t)),t},y=async()=>{const e=await(0,a.E)(u).mapEndpoints(l,(async e=>{const t=await h(e),r=await t.abciInfo(),{lastBlockHeight:n}=r;return assert.typeof(n,"number"),n}));return K(e)},m=new Map,b=async e=>{if(m.has(e)){const t=m.get(e);return assert(t),t}const t=await h(e),r=R.withExtensions(t);return m.set(e,r),r},w=async e=>{const{storeName:t,storeSubkey:r,dataPrefixBytes:n=G}=await d;assert.typeof(t,"string",J`storeName must be a string, got ${t}`),assert(r,J`storeSubkey must be a Uint8Array, got ${r}`);const o=await(0,a.E)(u).mapEndpoints(l,(async n=>e(n,t,r).then((e=>({result:e,error:null})),(e=>({result:null,error:e}))))),{result:s,error:i}=K(o);if(null!==i)throw i;return assert(s),0===s.length?s:(assert(s.length>=n.length,J`result too short for data prefix ${n}`),assert(F(s.subarray(0,n.length),n),J`${s} doesn't start with data prefix ${n}`),s.slice(n.length))},E=async e=>w((async(t,r,n)=>{const o=await b(t);return(0,a.E)(o).queryVerified(r,n,e)})),S=async e=>w((async(t,r,n)=>{const a=await h(t),o=await a.abciQuery({path:`store/${r}/key`,data:n,height:e,prove:!1});if(0!==o.code)throw new Error(`Tendermint ABCI query failed: ${o.log}`);const{value:s}=o;return s})),I=async e=>{if("strict"===s)return E(e).catch(c);if("none"===s)return S(e);if("optimistic"===s){const t=await S(e);return E(e).then((e=>{F(e,t)||c(assert.error(J`Alleged value ${t} did not match proof ${e}`))}),c),t}assert.fail(J`Unrecognized proof option ${U(s)}, must be one of strict, none, or optimistic`)},k=async e=>{for(let r=0;;r+=1)try{return await I(e)}catch(t){await(0,a.E)(u).retry(l,t,r);continue}},$=(e,t)=>{const r=L.decode(t);try{const e=JSON.parse(r);if(q(e))return harden({blockHeight:Number(e.blockHeight),values:e.values.map(n)})}catch{}return harden({blockHeight:e,values:[n(r)]})},O=async(e,t,r)=>({value:await(o?(0,a.E)(o).unserialize(e):e),blockHeight:t,currentBlockHeight:r});function*N(e,t){for(const r of e.values)yield O(r,e.blockHeight,t)}function*P(e,t){for(let r=e.values.length-1;r>=0;r-=1)yield O(e.values[r],e.blockHeight,t)}function*A(e,t){const{values:r}=e;if(r.length>0){const n=r[r.length-1];yield O(n,e.blockHeight,t)}}async function*C(){let e,t;for(;;){const r=await y();if(r===e){await(0,a.E)(u).jitter(l);continue}const n=await k(r);if(0===n.length){await(0,a.E)(u).jitter(l);continue}const o=$(r,n);e=r,void 0!==t&&F(t,n)||(yield*A(o,r),t=n)}}async function*B(e){let t;for(;;){if(t=await k(e),0!==t.length){const r=$(e,t);yield*N(r,e);break}await(0,a.E)(u).jitter(l),e=await y()}for(;;){const r=await y();if(r<=e){await(0,a.E)(u).jitter(l);continue}let n=r,o=await k(n);if(0===o.length){await(0,a.E)(u).jitter(l);continue}let s=$(n,o);const i=o,c=[];for(;n>e;){if(s.blockHeight>n){const{storeName:e,storeSubkey:t}=await d;throw new Error(`Corrupt storage cell for ${e} under key ${t} at block-height ${n} claims to being published at a later block height ${s.blockHeight}`)}const t=s.blockHeight-1;if(t<=e)break;const r=await k(t);if(0===r.length)break;const a=$(t,r);F(r,o)||c.push(s),o=r,s=a,n=t}for(F(o,t)||c.push(s);;){const e=c.pop();if(void 0===e)break;yield*N(e,r)}e=r,t=i}}async function*M(e){let t;for(;e>0;){if(t=await k(e),0===t.length)return;const r=$(e,t);yield*P(r,e),e=r.blockHeight-1}}return(0,a.cI)("chain follower",{getLatestIterable:async()=>C(),async getEachIterable(){let{height:e}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return void 0===e&&(e=await y()),B(e)},async getReverseIterable(){let{height:e}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return void 0===e&&(e=await y()),M(e)}})}(n,t,r):(e=>{const t=e=>harden({value:e,blockHeight:NaN,currentBlockHeight:NaN});return(0,a.cI)("subscription/notifier follower",{getLatestIterable:async()=>{const{notifier:r,subscription:n}=await e;let a;return r?a=E(r):(assert(n),a=S(n)),I(a,t)},getEachIterable:async()=>{const{notifier:r,subscription:n}=await e;let a;return n?a=S(n):(assert(r),a=E(r)),I(a,t)},getReverseIterable:async()=>{throw Error("reverse iteration not implemented for subscription follower")}})})(n)};var Z=r(3617),X=r(3276),Y=r(4275),ee=r(7092),te=r(603);const{details:re,quote:ne}=assert,ae=e=>"string"===typeof e&&!!e.match(/^board[^:]/),oe=(e,t,r)=>`${t}:${`${r}`}`,se=(e,t)=>Object.keys(e).find(t),ie=(e,t)=>{const r=se(e,(e=>t.startsWith(`${e}:`)));return{kind:r,id:r?Number(t.slice(r.length+1)):NaN}},ce=(e,t,r)=>{e.bySlot.init(t,r),e.byVal.init(r,t)},le=e=>{const t=`SEVERED: ${e.replace(/^Alleged: /,"")}`;return(0,o.cI)(t,{})};var de=r(7141),ue=r(3770);const fe=(e,t,r)=>{const{getPursesNotifier:n,dappService:a,offerService:o,issuerService:s,unserializer:i,networkConfig:c}=r,{dapps:l,addDapp:d,setDappPetname:u,deleteDapp:f,enableDapp:g}=a,p=t=>u(e,t);let h=l.get(e);if(!h){let r;const n=new Promise((t=>{r=()=>{g(e),t()}}));h={id:e,meta:{id:e},petname:t,origin:e,enable:!1,actions:{enable:r,setPetname:p,delete:()=>f(e)},approvedP:n},d(h)}return(0,ue.cI)("scoped bridge",{async addOffer(t){const r=(new Date).getTime(),n=`${r}`;return await h.approvedP,o.addOffer({id:n,instancePetname:`instance@${t.instanceHandleBoardId}`,requestContext:{dappOrigin:e,origin:e},meta:{id:`${r}`,creationStamp:r},status:"proposed",...t}),n},async suggestIssuer(e,t){await h.approvedP,s.addSuggestion(e,t)},async suggestInstallation(e,t){await h.approvedP,console.log("TODO: suggest installation",e,t)},async suggestInstance(e,t){await h.approvedP,console.log("TODO: suggest instance",e,t)},getPursesNotifier:async()=>(await h.approvedP,n()),getOffersNotifier:async()=>(await h.approvedP,o.notifier),getUnserializer:async()=>(await h.approvedP,i),getNetConfig:async()=>(await h.approvedP,c)})};var ge=r(5155);const pe="DAPPS",he=e=>{var t;return null!==(t=(0,ge.K)([pe,e]))&&void 0!==t?t:[]},ye=e=>{const t=new Map,{notifier:r,updater:a}=(0,n.Gm)(),o=()=>a.updateState([...t.values()]),s=r=>{t.set(r.origin,r),((e,t)=>{var r;const{origin:n,enable:a,petname:o}=t,s=null!==(r=he(e))&&void 0!==r?r:[];(0,ge.A)([pe,e],[...s.filter((e=>e.origin!==n)),{origin:n,enable:a,petname:o,id:n,meta:{id:n}}])})(e,r),o()},i=r=>{t.delete(r),((e,t)=>{var r;const n=null!==(r=he(e))&&void 0!==r?r:[];(0,ge.A)([pe,e],n.filter((e=>e.origin!==t)))})(e,r),o()},c=(e,r)=>{const n=t.get(e);assert(n,`Tried to set petname on undefined dapp ${e}`),s({...n,petname:r})},l=e=>{const r=t.get(e);assert(r,`Tried to enable undefined dapp ${e}`),s({...r,enable:!0})};return he(e).forEach((e=>{let r;const n=new Promise((t=>{r=()=>{l(e.origin),t()}}));t.set(e.origin,{...e,approvedP:n,actions:{enable:r,setPetname:t=>c(e.origin,t),delete:()=>i(e.origin)}}),e.enable&&r()})),o(),{dapps:t,notifier:r,addDapp:s,setDappPetname:c,deleteDapp:i,enableDapp:l}},me="OFFERS",be=e=>{var t;return null!==(t=(0,ge.K)([me,e]))&&void 0!==t?t:[]},we=(e,t)=>{var r;const n=null!==(r=be(e))&&void 0!==r?r:[];(0,ge.A)([me,e],n.filter((e=>e.id!==t)))},ve=(e,t,r)=>{const a=new Map;let o=[];const{notifier:s,updater:i}=(0,n.Gm)(),c=()=>i.updateState([...a.values(),...o]),l=t=>{a.set(t.id,t),((e,t)=>{var r;const n=null!==(r=be(e))&&void 0!==r?r:[];(0,ge.A)([me,e],[...n.filter((e=>e.id!==t.id)),t])})(e,t),c()};be(e).forEach((t=>{"decline"===t.status&&we(e,t.id),a.set(t.id,{...t})})),c();return(async()=>{for await(const t of(0,n.oV)(r))null===t||void 0===t||t.forEach((r=>{console.log("chain offer",r);const n=r.id.split("#"),s=n[n.length-1];a.has(s)&&(a.delete(s),we(e,s)),o=t,c()}))})(),{offers:a,notifier:s,addOffer:l,acceptOffer:async e=>{const r=a.get(e);return assert(r,`Tried to accept undefined offer ${e}`),t(r.spendAction)},cancelOffer:e=>{console.log("TODO: cancel offer")},declineOffer:e=>{const t=a.get(e);assert(t,`Tried to decline undefined offer ${e}`),l({...t,status:"decline"}),c()}}},Ee=e=>{const t=new Map,{notifier:r,updater:a}=(0,n.Gm)(),o=()=>a.updateState([...t.values()]),s=e=>{assert(t.has(e),`Tried to delete undefined issuer suggestion ${e}`),t.delete(e),o()};return{notifier:r,addSuggestion:(r,n)=>{t.set(n,{boardId:n,petname:r,actions:{delete:()=>s(n),accept:async t=>{const r=JSON.stringify({type:"suggestIssuer",data:{boardId:n,petname:t}});try{await e(r),s(n)}catch(a){console.error("Sign spend action failed",r)}}}}),o()}}},Se=e=>`${e}${Math.random()}`;var Ie=r(5114);const ke=e=>{const t=new Map,r=r=>{const{key:n,newValue:a}=r;n&&a&&((r,n)=>{const a=JSON.parse(r);assert(Array.isArray(a));const[o,s,i,c]=a,l=JSON.parse(n);if("out"!==o||!l||"string"!==typeof l.type)return;const d={...l,dappOrigin:s},u=JSON.stringify([s,i]);let f,g;if(t.has(u))[f,g]=t.get(u)||assert.fail();else{const t=e=>{console.debug("WalletConnect: message -> storage",e),window.localStorage.setItem(JSON.stringify(["in",s,i,g]),JSON.stringify(e)),g+=1},r=()=>(0,te.E)(e).getScopedBridge(s,s);console.debug("new capTP connection",{origin:s,epoch:i}),f=(0,ue.Ol)(`from ${s} at ${i}`,t,r),g=0}t.set(u,[f,g+1]),console.debug("WalletConnect: storage -> dispatch",d),f.dispatch(d),window.localStorage.removeItem(r)})(n,a)};return window.addEventListener("storage",r),()=>{window.removeEventListener("storage",r);for(const[e,r]of t.values())e.abort(Error("wallet connection cancelled"))}};var $e=r(5030);const Oe=Z.forwardRef((function(e,t){let{children:r,...n}=e;return(0,$e.jsx)(Y.Z,{elevation:6,ref:t,variant:"filled",...n,children:r})})),Ne=(0,de.LW)((e=>{var t,r;let{connectionConfig:a,setConnectionState:s,setBackend:i,setBackendErrorHandler:c,keplrConnection:l}=e;const[d,u]=(0,Z.useState)([]);s("connecting");const f=function(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"error";t&&(console.error(`${e}:`,t),e+=`: ${t.message}`),"error"===r&&s("error"),u((t=>[...t,{severity:r,message:e}]))};return(0,Z.useEffect)((()=>{if(!a||a.smartConnectionMethod===Ie.a.KEPLR&&!l)return;let e,t;return(async()=>{const{href:r,smartConnectionMethod:d}=a;let u;u=d===Ie.a.KEPLR?l.address:a.publicAddress;const g=e=>{f("Error in wallet backend",e),i(null),s("error")},p=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:le;const t={purse:{bySlot:(0,ee.WS)(),byVal:(0,ee.WS)()},payment:{bySlot:(0,ee.WS)(),byVal:(0,ee.WS)()},unknown:{bySlot:(0,ee.WS)(),byVal:(0,ee.WS)()}},r={bySlot:(0,ee.WS)(),byVal:(0,ee.WS)()},n=(t,r,n)=>{if(t.bySlot.has(r))return t.bySlot.get(r);const a=e(n);return ce(t,r,a),a},a={fromBoard:(e,t)=>(assert(ae(e),re`bad board slot ${ne(e)}`),n(r,e,t)),fromMyWallet:(r,o)=>{if(!r)return e(`${r}`);const{kind:s,id:i}=ie(t,r);return s?n(t[s],i,o):a.fromBoard(r,o)}},s={fromBoard:e=>r.byVal.get(e),fromMyWallet:e=>{const r=se(t,(r=>t[r].byVal.has(e)));assert(r,re`cannot serialize unregistered ${e}`);const n=t[r].byVal.get(e);return oe(0,r,n)}},i={fromBoard:(0,o.AU)(s.fromBoard,a.fromBoard,{marshalName:"fromBoard"}),fromMyWallet:(0,o.AU)(s.fromMyWallet,a.fromMyWallet,{marshalName:"fromMyWallet"})};return harden({initBoardId:(e,t)=>{ce(r,e,t)},ensureBoardId:(e,t)=>{r.byVal.has(t)?assert.equal(r.byVal.get(t),e):ce(r,e,t)},fromMyWallet:(0,o.cI)("wallet marshaller",{...i.fromMyWallet}),fromBoard:(0,o.cI)("board marshaller",{...i.fromBoard})})}(),h=v(r),y=function(e,t,r,a,s,i){let c=arguments.length>6&&void 0!==arguments[6]?arguments[6]:e=>{throw e},l=arguments.length>7&&void 0!==arguments[7]?arguments[7]:()=>{};const d={getPursesNotifier:"purses",getContactsNotifier:"contacts",getIssuersNotifier:"issuers",getOffersNotifier:"offers",getPaymentsNotifier:"payments"},u=Object.fromEntries(Object.entries(d).map((e=>{let[t,r]=e;return[r,(0,n.Gm)(null)]}))),f={},g=new Map,p=new Map,h=()=>{const e=[];for(const[t,r]of g.entries())r.currentAmount&&r.brandPetname&&(p.set(r.pursePetname,t),e.push(r));u.purses.updater.updateState(harden(e))};(async()=>{let t;for await(const{blockHeight:r}of $(e))t=r;for await(const{value:r}of k(e,{height:t})){const e=r;switch(l&&(l(),Object.values(u).forEach((e=>{let{updater:t}=e;return t.updateState([])})),l=void 0),e.updated){case"brand":{const{descriptor:t}=e,r={...g.get(t.brand),brand:t.brand,brandPetname:t.petname,pursePetname:t.petname,displayInfo:t.displayInfo};g.set(t.brand,r),h();break}case"balance":{const{currentAmount:t}=e,r={...g.get(t.brand),currentAmount:t,value:t.value};g.set(t.brand,r),h();break}case"offerStatus":{const{status:t}=e;console.log("offerStatus",{status:t,offers:f});const r=f[t.id];r&&"accept"!==r.status&&"numWantsSatisfied"in t&&(f[t.id]={...r,id:`${t.id}`,status:"accept"},u.offers.updater.updateState(harden(Object.values(f))));break}default:throw Error(`Unknown updateRecord ${e.updated}`)}}})().catch(c);const y=Object.fromEntries(Object.entries(d).map((e=>{let[t,r]=e;const{notifier:n}=u[r];return[t,()=>n]}))),m=()=>{console.log("make empty purse")},b=()=>{console.log("add contact")},w=()=>{console.log("add issuer")},v=e=>{const{signers:{interactiveSigner:t}}=s;if(!t)throw new Error("Cannot sign a transaction in read only mode, connect to keplr.");return t.submitSpendAction(e)},E=Ee(v),S=ye(a),I=ve(a,v,y.getOffersNotifier()),{acceptOffer:O,declineOffer:N,cancelOffer:P}=I,A=async e=>{const{id:t,instanceHandleBoardId:n,invitationMaker:{method:a},proposalTemplate:{give:o,want:s}}=e,i=e=>Object.fromEntries(Object.entries(e).map((e=>{let[t,{brand:r,pursePetname:n,value:a}]=e;return[t,{brand:r||p.get(n),value:BigInt(a)}]}))),c={id:(new Date).getTime(),invitationSpec:{source:"contract",instance:n,publicInvitationMaker:a},proposal:{give:i(o),want:i(s)}},l=await(0,te.E)(r).serialize(harden({method:"executeOffer",offer:c})),{slots:[d]}=await(0,te.E)(r).serialize(n),u={...e,instancePetname:`instance@${d}`,spendAction:JSON.stringify(l)};return I.addOffer(u),f[t]=u,t};return(0,o.cI)("follower wallet bridge",{...y,getDappsNotifier:()=>S.notifier,getOffersNotifier:()=>I.notifier,getIssuerSuggestionsNotifier:()=>E.notifier,acceptOffer:O,declineOffer:N,cancelOffer:P,makeEmptyPurse:m,addContact:b,addIssuer:w,getScopedBridge:(e,n)=>fe(e,n,{dappService:S,offerService:{...I,addOffer:A},leader:t,unserializer:r,publicAddress:a,issuerService:E,networkConfig:i,...y})})}(Q(`:published.wallet.${u}`,h,{unserializer:p.fromMyWallet}),h,p.fromBoard,u,l,r,g,(()=>s("bridged"))),{backendIt:m,cancel:b}=await(e=>{const t=async e=>(0,n.oV)(e)[Symbol.asyncIterator](),{notifier:r}=(0,n.Gm)(harden({board:(0,te.E)(e).getBoard()})),a=harden({actions:(0,o.cI)("schemaActions",{createPurse:function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Se("Purse");return(0,te.E)(e).makeEmptyPurse(null===t||void 0===t?void 0:t.issuerPetname,r)},createContact:function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Se("Contact");return(0,te.E)(e).addContact(r,t)},createIssuer:function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Se("Issuer");return(0,te.E)(e).addIssuer(r,t,!0)}}),services:t(r),contacts:t((0,te.E)(e).getContactsNotifier()),dapps:t((0,te.E)(e).getDappsNotifier()),issuers:t((0,te.E)(e).getIssuersNotifier()),offers:(s=t((0,te.E)(e).getOffersNotifier()),harden({next:async()=>{const{done:t,value:r}=await(0,te.E)(s).next();return harden({done:t,value:r&&r.map((t=>{let{id:r,...n}=t;return harden({id:r,...n,actions:(0,o.cI)("offerActions",{accept:()=>(0,te.E)(e).acceptOffer(r),decline:()=>(0,te.E)(e).declineOffer(r),cancel:()=>(0,te.E)(e).cancelOffer(r)})})}))})},return:s.return,throw:s.throw})),payments:t((0,te.E)(e).getPaymentsNotifier()),purses:t((0,te.E)(e).getPursesNotifier()),issuerSuggestions:t((0,te.E)(e).getIssuerSuggestionsNotifier())});var s;const{notifier:i,updater:c}=(0,n.Gm)(a);return{backendIt:t(i),cancel:e=>{c.fail(e)}}})(y);return t=ke(y),e=b,c((()=>g)),(0,n.uO)(m,{updateState:t=>{e&&i(t)},fail:t=>{e&&g(t)},finish:t=>{e&&i(t)}})})().catch((e=>f("Cannot read Smart Wallet casting",e))),()=>{e&&e(),e=void 0,t&&t(),t=void 0}}),[a,l]),(0,$e.jsx)("div",{children:(0,$e.jsx)(X.Z,{open:d.length>0,children:(0,$e.jsx)(Oe,{onClose:(e,t)=>{"clickaway"!==t&&u((e=>e.slice(1)))},severity:null===(t=d[0])||void 0===t?void 0:t.severity,sx:{width:"100%"},children:null===(r=d[0])||void 0===r?void 0:r.message})})})}),(e=>({connectionConfig:e.connectionConfig,setConnectionState:e.setConnectionState,setBackend:e.setBackend,setBackendErrorHandler:e.setBackendErrorHandler,keplrConnection:e.keplrConnection})))}}]);
//# sourceMappingURL=858.e6ee81ed.chunk.js.map