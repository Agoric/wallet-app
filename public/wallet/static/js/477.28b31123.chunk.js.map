{"version":3,"file":"static/js/477.28b31123.chunk.js","mappings":"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","sources":["../../../cache/src/state.js","../../../cache/src/store.js","../../../cache/src/cache.js","../../../web-components/src/states.js","../../../web-components/src/admin-websocket-connector.js","../../../web-components/src/bridge-iframe-connector.js","../../../web-components/src/AgoricWalletConnection.js","../../../web-components/src/AgoricIframeMessenger.js","../../../web-components/src/agoric-iframe-messenger.js","../../../web-components/agoric-wallet-connection.js","../../../wallet-connection/react.js","util/fixed-websocket-connector.js","components/WalletConnection.jsx","../../../web-components/react.js"],"sourcesContent":["// @ts-check\n\n/** @typedef {import('./types').State} State */\n\n/**\n * The ground state for a cache key value is `undefined`.  It is impossible to\n * distinguish a set value of `undefined` from an unset key.\n *\n * @type {State}\n */\nexport const GROUND_STATE = harden({ generation: 0n, value: undefined });\n\n/**\n * Create a new state as an update relative to an existing one.\n *\n * @param {any} value\n * @param {State} [priorState]\n * @returns {State}\n */\nexport const makeState = (value, priorState = GROUND_STATE) =>\n  harden({\n    generation: priorState.generation + 1n,\n    value,\n  });\n","// @ts-check\nimport { Far } from '@endo/far';\nimport { matches, makeScalarMapStore } from '@agoric/store';\n\nimport '@agoric/store/exported.js';\n\nimport { GROUND_STATE } from './state.js';\n\nconst { details: X } = assert;\n\n/**\n * @param {MapStore<unknown, import('./types').State>} [stateStore]\n * @returns {import('./types').Coordinator}\n */\nexport const makeStoreCoordinator = (stateStore = makeScalarMapStore()) => {\n  const getCurrentState = key => {\n    if (!stateStore.has(key)) {\n      return GROUND_STATE;\n    }\n    return stateStore.get(key);\n  };\n  return Far('store cache coordinator', {\n    getRecentState: async key => getCurrentState(key),\n    tryUpdateState: async (key, desiredState, guardPattern) => {\n      const currentState = getCurrentState(key);\n      const { generation, value } = currentState;\n      const nextGeneration = generation + 1n;\n      const { generation: desiredGeneration, value: desiredValue } =\n        desiredState;\n      assert(\n        desiredGeneration <= nextGeneration,\n        X`Cannot refer to future generation; expected ${nextGeneration}, got ${desiredGeneration}`,\n      );\n      if (desiredGeneration < nextGeneration) {\n        return currentState;\n      }\n      assert.equal(desiredGeneration, nextGeneration);\n      if (!matches(value, guardPattern)) {\n        // value doesn't match, so don't apply the update.\n        return currentState;\n      }\n\n      const nextState = harden({\n        generation: nextGeneration,\n        value: desiredValue,\n      });\n      if (nextGeneration <= 1n) {\n        stateStore.init(key, nextState);\n      } else {\n        stateStore.set(key, nextState);\n      }\n      return nextState;\n    },\n  });\n};\n","// @ts-check\nimport { E } from '@endo/far';\nimport { M } from '@agoric/store';\n\nimport { makeState } from './state.js';\nimport { makeStoreCoordinator } from './store.js';\n\n/** @template T @typedef {import('@endo/far').ERef<T>} ERef */\n\n/**\n * @param {ERef<import('./types').Coordinator>} [coordinator]\n */\nexport const makeCache = (coordinator = makeStoreCoordinator()) => {\n  /**\n   * The ground state for a cache key value is `undefined`.  It is impossible to\n   * distinguish a set value of `undefined` from an unset key\n   *\n   * @param {unknown} key the cache key (any key type acceptable to the cache)\n   * @param {object | string | bigint | null | undefined | number | ((oldValue: any) => ERef<unknown>)} [update] a\n   * function that returns a `newValue` or promise for `newValue`\n   * @param {Pattern[]} optGuardPattern don't update unless this pattern matches\n   */\n  const cache = (key, update, ...optGuardPattern) => {\n    if (!update) {\n      return E.get(E(coordinator).getRecentState(key)).value;\n    }\n    const guardPattern =\n      optGuardPattern.length > 0 ? optGuardPattern[0] : M.any();\n    return new Promise((resolve, reject) => {\n      const retryTransaction = async recentState => {\n        const updatedValue = await (typeof update === 'function'\n          ? update(recentState.value)\n          : update);\n        const nextState = makeState(updatedValue, recentState);\n        const updatedState = await E(coordinator).tryUpdateState(\n          key,\n          nextState,\n          guardPattern,\n        );\n        if (updatedState.generation <= nextState.generation) {\n          resolve(updatedState.value);\n          return;\n        }\n        retryTransaction(updatedState).catch(reject);\n      };\n      // Start the transaction loop until it fails or we update successfully.\n      E(coordinator).getRecentState(key).then(retryTransaction).catch(reject);\n    });\n  };\n  return cache;\n};\n","// @ts-check\nimport {\n  createMachine,\n  guard,\n  immediate,\n  reduce as rawReduce,\n  state,\n  transition,\n} from 'robot3';\n\n/**\n * @typedef {object} Context\n * @property {any?} error\n * @property {string?} location\n * @property {Record<string,any>} connectionParams\n */\n\n/**\n * @type {(fn: import('robot3').ReduceFunction<Context, any>) =>\n * import('robot3').Reducer<Context, any>}\n */\nconst reduce = rawReduce;\n\n/**\n * @returns {Context}\n */\nconst initialContext = () => ({\n  error: null,\n  location: null,\n  connectionParams: {},\n});\n\nconst common = [\n  // Allow the 'reset' event to go back to the 'idle' state.\n  transition('reset', 'idle', reduce(initialContext)),\n  // Make the 'error' event go to the 'error' state.\n  transition(\n    'error',\n    'error',\n    reduce((ctx, ev) => ({ ...ctx, error: ev.error })),\n  ),\n];\n\n/**\n * Create a state machine for the wallet connection.\n */\nexport const makeConnectionMachine = () =>\n  createMachine(\n    {\n      idle: state(\n        ...common,\n        transition(\n          'locate',\n          'locating',\n          reduce((ctx, ev) => ({\n            ...ctx,\n            connectionParams: ev.connectionParams,\n          })),\n        ),\n        transition('connect', 'connecting'),\n      ),\n      locating: state(\n        ...common,\n        immediate(\n          'connecting',\n          guard(({ location }) => !!location),\n        ),\n        transition(\n          'located',\n          'connecting',\n          reduce((ctx, ev) => ({ ...ctx, location: ev.href })),\n        ),\n      ),\n      connecting: state(...common, transition('connected', 'bridged')),\n      bridged: state(...common, transition('needDappApproval', 'approving')),\n      approving: state(\n        ...common,\n        transition('needDappApproval', 'approving'),\n        transition('dappApproved', 'bridged'),\n      ),\n      error: state(...common),\n    },\n    initialContext,\n  );\n","/* eslint-disable no-underscore-dangle */\nimport { E } from '@endo/eventual-send';\n\nconst CONNECTION_TIMEOUT_MS = 5000;\n\n// Wait for the wallet to finish loading.\nexport const waitForBootstrap = async getBootstrap => {\n  const getLoadingUpdate = (...args) =>\n    E(E.get(getBootstrap()).loadingNotifier).getUpdateSince(...args);\n  let update = await getLoadingUpdate();\n  while (update.value.includes('wallet')) {\n    console.log('waiting for wallet');\n    // eslint-disable-next-line no-await-in-loop\n    update = await getLoadingUpdate(update.updateCount);\n  }\n\n  return getBootstrap();\n};\n\nexport const makeAdminWebSocketConnector = component => {\n  let ws;\n\n  const onAdminOpen = () => {\n    const send = obj => {\n      if (ws.readyState !== WebSocket.OPEN) {\n        return;\n      }\n      ws.send(JSON.stringify(obj));\n    };\n    component._startCapTP(send, 'walletAdmin');\n\n    assert(component._captp);\n    const { dispatch, getBootstrap } = component._captp;\n\n    ws.addEventListener('message', ev => {\n      const obj = JSON.parse(ev.data);\n      dispatch(obj);\n    });\n\n    const adminFacet = E(\n      E.get(waitForBootstrap(getBootstrap)).wallet,\n    ).getAdminFacet();\n    adminFacet.then(component.service.send({ type: 'connected' }));\n    component._bridgePK.resolve(adminFacet);\n  };\n\n  return {\n    render: () => '',\n    hostConnected: () => {\n      const {\n        location,\n        connectionParams: { accessToken },\n      } = component.service.context;\n      assert(location);\n\n      const hrefs = [location, window.location.href];\n      const connect = () => {\n        // Cycle through the hrefs to find the websocket protocol for this path.\n        const href = hrefs.shift();\n        const url = new URL('/private/captp', href);\n        url.protocol = url.protocol.replace(/^http/, 'ws');\n\n        if (accessToken) {\n          url.searchParams.set('accessToken', accessToken);\n        }\n\n        const onClose = _ev => {\n          if (hrefs.length > 0) {\n            return connect();\n          }\n          return component.reset();\n        };\n\n        ws = new WebSocket(url.href);\n        const timeout = window.setTimeout(() => {\n          ws.close();\n        }, CONNECTION_TIMEOUT_MS);\n\n        ws.addEventListener('open', ev => {\n          window.clearTimeout(timeout);\n          return onAdminOpen(ev);\n        });\n        ws.addEventListener('close', onClose);\n        ws.addEventListener('error', () => {});\n      };\n      connect(location);\n    },\n    hostDisconnected: () => {\n      ws.close();\n    },\n  };\n};\n","/* eslint-disable no-underscore-dangle */\nimport { html } from 'lit';\nimport { assert, details as X } from '@agoric/assert';\n\nexport const makeBridgeIframeConnector = component => {\n  const connectedOnMessage = ev => {\n    console.log(component.state, 'bridge received', ev);\n    const { data } = ev.detail;\n    if (data && typeof data.type === 'string') {\n      if (data.type === 'walletBridgeClosed') {\n        component.reset();\n      }\n      if (data.type.startsWith('CTP_')) {\n        assert(component._captp);\n        component._captp.dispatch(data);\n      }\n    }\n  };\n\n  let onMessage = event => {\n    console.log(component.state, 'connect received', event);\n    const { data, send } = event.detail;\n    assert.equal(\n      data.type,\n      'walletBridgeLoaded',\n      X`Unexpected connect message type ${data.type}`,\n    );\n\n    component._startCapTP(\n      send,\n      component.service.context.suggestedDappPetname,\n      component._walletCallbacks,\n    );\n\n    onMessage = connectedOnMessage;\n\n    // Received bridge announcement, so mark the connection as bridged.\n    component.service.send({ type: 'connected' });\n  };\n\n  return {\n    render: () => {\n      const {\n        location,\n        connectionParams: { suggestedDappPetname },\n      } = component.service.context;\n      assert(location);\n      const url = new URL(location);\n      if (suggestedDappPetname) {\n        url.searchParams.append('suggestedDappPetname', suggestedDappPetname);\n      }\n      return html`\n        <agoric-iframe-messenger\n          src=${url.href}\n          @open=${component.onOpen}\n          @message=${onMessage}\n          @error=${component.onError}\n        ></agoric-iframe-messenger>\n      `;\n    },\n    hostConnected() {},\n    hostDisconnected() {},\n  };\n};\n","/* eslint-disable no-underscore-dangle */\n// @ts-check\nimport { html, css, LitElement } from 'lit';\n\nimport { assert, details as X } from '@agoric/assert';\nimport { makeCache } from '@agoric/cache';\nimport { makeCapTP as defaultMakeCapTP } from '@endo/captp';\nimport { E } from '@endo/eventual-send';\nimport { Far } from '@endo/marshal';\nimport { makePromiseKit } from '@endo/promise-kit';\n\nimport 'robot3/debug';\nimport { interpret } from 'robot3';\n\nimport { makeConnectionMachine } from './states.js';\n\nimport { makeAdminWebSocketConnector } from './admin-websocket-connector.js';\nimport { makeBridgeIframeConnector } from './bridge-iframe-connector.js';\n\n// Delay after a reset.\nconst RESET_DELAY_MS = 3000;\n\n// TODO: Use something on agoric.app instead.\nconst DEFAULT_LOCATOR_URL =\n  'https://local.agoric.com/?append=/wallet-bridge.html';\n\nconst delay = (ms, resolution) =>\n  new Promise(resolve => setTimeout(resolve, ms, resolution));\n\nexport const makeAgoricWalletConnection = (makeCapTP = defaultMakeCapTP) =>\n  class AgoricWalletConnection extends LitElement {\n    static get styles() {\n      return css`\n        :host {\n          display: block;\n          padding: 25px;\n          color: var(--agoric-wallet-connection-text-color, #000);\n        }\n      `;\n    }\n\n    static get properties() {\n      return {\n        state: { type: String },\n      };\n    }\n\n    get state() {\n      return this.machine.state.name;\n    }\n\n    async reset() {\n      if (this.isResetting) {\n        return;\n      }\n      this.isResetting = true;\n      await delay(RESET_DELAY_MS, 'reset');\n      if (this._captp) {\n        this._captp.abort();\n        this._captp = null;\n      }\n      if (this._connector) {\n        this._connector.hostDisconnected();\n        this._connector = null;\n      }\n\n      // Just make sure the reconnection logic is triggered.\n      this._bridgePK = makePromiseKit();\n      this._cache = undefined;\n\n      this.service.send({ type: 'reset' });\n      this.isResetting = false;\n    }\n\n    get cache() {\n      if (this._cache) {\n        // The cache is cached.\n        return this._cache;\n      }\n      const cache = makeCache(E(this._bridgePK.promise).getCacheCoordinator());\n      this._cache = (key, update, ...optGuardPattern) =>\n        cache(key, update, ...optGuardPattern);\n      return this._cache;\n    }\n\n    get walletConnection() {\n      if (this._walletConnection) {\n        // Cached.\n        return this._walletConnection;\n      }\n\n      this._walletConnection = Far('WalletConnection', {\n        getScopedBridge: (\n          suggestedDappPetname,\n          dappOrigin = window.location.origin,\n          makeConnector = makeBridgeIframeConnector,\n        ) => {\n          assert.equal(\n            this.state,\n            'idle',\n            X`Cannot get scoped bridge in state ${this.state}`,\n          );\n          this.service.send({\n            type: 'locate',\n            connectionParams: {\n              caller: 'getScopedBridge',\n              suggestedDappPetname,\n              dappOrigin,\n              makeConnector,\n            },\n          });\n          return this._bridgePK.promise;\n        },\n        getAdminBootstrap: (\n          accessToken,\n          makeConnector = makeAdminWebSocketConnector,\n        ) => {\n          assert.equal(\n            this.state,\n            'idle',\n            X`Cannot get admin bootstrap in state ${this.state}`,\n          );\n          this.service.send({\n            type: 'locate',\n            connectionParams: {\n              caller: 'getAdminBootstrap',\n              accessToken,\n              makeConnector,\n            },\n          });\n          return this._bridgePK.promise;\n        },\n        reset: () => {\n          this.reset();\n        },\n      });\n\n      return this._walletConnection;\n    }\n\n    constructor() {\n      super();\n\n      // This state machine integration is much like lit-robot, but also raises\n      // state events.\n      const machine = makeConnectionMachine();\n      const onState = (service, requestUpdate = true) => {\n        this.machine = service.machine;\n        const ev = new CustomEvent('state', {\n          detail: {\n            ...this.machine.context,\n            state: this.machine.state.name,\n            walletConnection: this.walletConnection,\n            cache: this.cache,\n          },\n        });\n        this.dispatchEvent(ev);\n        if (requestUpdate) {\n          this.requestUpdate();\n        }\n      };\n      this.service = interpret(machine, onState);\n      this.machine = this.service.machine;\n\n      // Wait until we load before sending the first state.\n      this.firstUpdated = () => onState(this.service, false);\n\n      this._nextEpoch = 0;\n      this._bridgePK = makePromiseKit();\n\n      this._walletCallbacks = Far('walletCallbacks', {\n        needDappApproval: (dappOrigin, suggestedDappPetname) => {\n          this.service.send({\n            type: 'needDappApproval',\n            dappOrigin,\n            suggestedDappPetname,\n          });\n        },\n        dappApproved: dappOrigin => {\n          this.service.send({ type: 'dappApproved', dappOrigin });\n        },\n      });\n    }\n\n    onOpen(ev) {\n      console.log(this.state, 'open', ev);\n      if (this.state === 'bridged') {\n        assert(this._captp);\n        this._bridgePK.resolve(this._captp.getBootstrap());\n      }\n    }\n\n    onLocateMessage(ev) {\n      console.log(this.state, 'locate', ev);\n      const { data } = ev.detail;\n      assert.typeof(data, 'string', X`Expected locate message to be a string`);\n      this.service.send({ type: 'located', href: data });\n    }\n\n    onError(event) {\n      console.log(this.state, 'error', event);\n      this.service.send({\n        type: 'error',\n        error: (event.detail && event.detail.error) || 'Unknown error',\n      });\n\n      // Allow retries to get a fresh bridge.\n      this._captp = null;\n    }\n\n    _startCapTP(send, ourEndpoint, ourPublishedBootstrap) {\n      // Start a new epoch of the bridge captp.\n      const epoch = this._nextEpoch;\n      this._nextEpoch += 1;\n\n      this._captp = makeCapTP(\n        `${ourEndpoint}.${epoch}`,\n        obj => {\n          // console.log('sending', obj);\n          send(obj);\n        },\n        ourPublishedBootstrap,\n        { epoch },\n      );\n    }\n\n    disconnectedCallback() {\n      super.disconnectedCallback();\n      if (this._captp) {\n        this._captp.abort();\n        this._captp = null;\n      }\n      if (this._connector) {\n        this._connector.hostDisconnected();\n        this._connector = null;\n      }\n    }\n\n    render() {\n      /** @type {import('lit-html').TemplateResult<1> | undefined} */\n      let backend;\n      switch (this.state) {\n        case 'locating': {\n          backend = html`\n            <agoric-iframe-messenger\n              src=${DEFAULT_LOCATOR_URL}\n              @open=${this.onOpen}\n              @message=${this.onLocateMessage}\n              @error=${this.onError}\n            ></agoric-iframe-messenger>\n          `;\n          break;\n        }\n        case 'approving':\n        case 'bridged':\n        case 'connecting': {\n          if (!this._connector) {\n            this._connector =\n              this.service.context.connectionParams.makeConnector(this);\n            this._connector.hostConnected();\n          }\n          backend = this._connector.render();\n          break;\n        }\n        default:\n      }\n\n      return html`\n        <div>Agoric Wallet Connection: ${this.state}</div>\n        ${backend}\n      `;\n    }\n  };\n\nexport const AgoricWalletConnection = makeAgoricWalletConnection();\n","/* eslint-disable no-underscore-dangle */\n// @ts-check\nimport { LitElement, html } from 'lit';\n\nimport { assert } from '@agoric/assert';\n\nconst CONNECTION_TIMEOUT_MS = 5000;\n\nexport const makeAgoricIframeMessenger = (registerThis = _that => {}) =>\n  class AgoricIframeMessenger extends LitElement {\n    static get properties() {\n      return { src: { type: String } };\n    }\n\n    constructor() {\n      super();\n      this.src = '';\n      this._contentWindow = null;\n      this._origin = null;\n      this._timeout = undefined;\n\n      // Need to bind since these aren't declarative event handlers.\n      this.send = this.send.bind(this);\n      this._onMessage = this._onMessage.bind(this);\n      registerThis(this);\n    }\n\n    connectedCallback() {\n      super.connectedCallback();\n      window.addEventListener('message', this._onMessage);\n    }\n\n    disconnectedCallback() {\n      window.removeEventListener('message', this._onMessage);\n      super.disconnectedCallback();\n    }\n\n    render() {\n      return html`\n        <iframe\n          title=\"Agoric Iframe Messenger\"\n          src=${this.src}\n          @load=${this._onLoad}\n          @abort=${this._onError}\n          @error=${this._onError}\n        ></iframe>\n      `;\n    }\n\n    firstUpdated() {\n      const iframe = this.renderRoot.querySelector('iframe');\n      assert(iframe);\n      // Detect the content window of the iframe to verify message sources.\n      this._contentWindow = iframe.contentWindow;\n      this._timeout = window.setTimeout(() => {\n        const ev = new CustomEvent('error', {\n          detail: { error: new Error('connection timeout') },\n        });\n        this.dispatchEvent(ev);\n      }, CONNECTION_TIMEOUT_MS);\n    }\n\n    _onLoad(event) {\n      event.preventDefault();\n      const ev = new CustomEvent('open', { detail: { send: this.send } });\n      this._origin = new URL(this.src).origin;\n      this.dispatchEvent(ev);\n    }\n\n    _onMessage(event) {\n      // console.log('iframe message', event);\n      if (event.source !== this._contentWindow) {\n        return;\n      }\n      if (this._timeout) {\n        window.clearTimeout(this._timeout);\n        this._timeout = undefined;\n      }\n      event.preventDefault();\n\n      const ev = new CustomEvent('message', {\n        detail: { data: event.data, send: this.send },\n      });\n      this.dispatchEvent(ev);\n    }\n\n    _onError(event) {\n      event.preventDefault();\n      const ev = new CustomEvent('error', { detail: { error: event.error } });\n      this.dispatchEvent(ev);\n    }\n\n    send(data) {\n      assert(this._contentWindow);\n      assert(this._origin);\n      this._contentWindow.postMessage(data, this._origin);\n    }\n  };\n\nexport const AgoricIframeMessenger = makeAgoricIframeMessenger();\n","import { AgoricIframeMessenger } from './AgoricIframeMessenger.js';\n\nwindow.customElements.define('agoric-iframe-messenger', AgoricIframeMessenger);\n","import { AgoricWalletConnection } from './src/AgoricWalletConnection.js';\nimport './src/agoric-iframe-messenger.js';\n\nwindow.customElements.define(\n  'agoric-wallet-connection',\n  AgoricWalletConnection,\n);\n","export { makeReactAgoricWalletConnection } from '@agoric/web-components/react.js';\nconsole.warn(\n  'This package is deprecated. Use @agoric/web-components instead of @agoric/wallet-connection.',\n);\n","/* eslint-disable no-underscore-dangle */\nimport { E } from '@endo/eventual-send';\n\nconst CONNECTION_TIMEOUT_MS = 5000;\n\n// Wait for the wallet to finish loading.\nexport const waitForBootstrap = async getBootstrap => {\n  const getLoadingUpdate = (...args) =>\n    E(E.get(getBootstrap()).loadingNotifier).getUpdateSince(...args);\n  let update = await getLoadingUpdate();\n  while (update.value.includes('wallet')) {\n    console.log('waiting for wallet');\n    // eslint-disable-next-line no-await-in-loop\n    update = await getLoadingUpdate(update.updateCount);\n  }\n\n  return getBootstrap();\n};\n\nexport const makeFixedWebSocketConnector = href => component => {\n  let ws;\n\n  const onAdminOpen = () => {\n    const send = obj => {\n      if (ws.readyState !== WebSocket.OPEN) {\n        return;\n      }\n      ws.send(JSON.stringify(obj));\n    };\n    component._startCapTP(send, 'walletAdmin');\n\n    assert(component._captp);\n    const { dispatch, getBootstrap } = component._captp;\n\n    ws.addEventListener('message', ev => {\n      const obj = JSON.parse(ev.data);\n      dispatch(obj);\n    });\n\n    const adminFacet = E(\n      E.get(waitForBootstrap(getBootstrap)).wallet,\n    ).getAdminFacet();\n    adminFacet.then(component.service.send({ type: 'connected' }));\n    component._bridgePK.resolve(adminFacet);\n  };\n\n  return {\n    render: () => '',\n    hostConnected: () => {\n      const {\n        location,\n        connectionParams: { accessToken },\n      } = component.service.context;\n      assert(location);\n\n      const connect = () => {\n        // Cycle through the hrefs to find the websocket protocol for this path.\n        const url = new URL('/private/captp', href);\n        url.protocol = url.protocol.replace(/^http/, 'ws');\n\n        if (accessToken) {\n          url.searchParams.set('accessToken', accessToken);\n        }\n\n        const onClose = _ev => {\n          return component.reset();\n        };\n\n        ws = new WebSocket(url.href);\n        const timeout = window.setTimeout(() => {\n          ws.close();\n        }, CONNECTION_TIMEOUT_MS);\n\n        ws.addEventListener('open', ev => {\n          window.clearTimeout(timeout);\n          return onAdminOpen(ev);\n        });\n        ws.addEventListener('close', onClose);\n        ws.addEventListener('error', () => {});\n      };\n      connect(location);\n    },\n    hostDisconnected: () => {\n      ws.close();\n    },\n  };\n};\n","/* eslint-disable no-underscore-dangle */\n/* eslint-disable import/no-extraneous-dependencies */\n/* eslint-disable react/display-name */\nimport { makeReactAgoricWalletConnection } from '@agoric/wallet-connection/react.js';\nimport React, { useState, useCallback, useEffect } from 'react';\nimport { E } from '@endo/eventual-send';\nimport { observeIterator } from '@agoric/notifier';\nimport { makeStyles } from '@mui/styles';\n\nimport { withApplicationContext } from '../contexts/Application.jsx';\n\nimport { makeBackendFromWalletBridge } from '../util/WalletBackendAdapter.js';\nimport { makeFixedWebSocketConnector } from '../util/fixed-websocket-connector.js';\n\nconst useStyles = makeStyles(_ => ({\n  hidden: {\n    display: 'none',\n  },\n}));\n\n// Create a wrapper for agoric-wallet-connection that is specific to\n// the app's instance of React.\nconst AgoricWalletConnection = makeReactAgoricWalletConnection(React);\n\nconst WalletConnection = ({\n  setBackend,\n  setConnectionState,\n  disconnect,\n  walletConnection,\n}) => {\n  const classes = useStyles();\n  const [wc, setWC] = useState(null);\n\n  let cancelled = null;\n  const onWalletState = useCallback(\n    ev => {\n      if (cancelled) {\n        return;\n      }\n      const { walletConnection: newWC, state } = ev.detail;\n      setConnectionState(state);\n      if (!wc) {\n        setWC(newWC);\n      }\n    },\n    [walletConnection],\n  );\n\n  useEffect(() => {\n    if (!wc || !walletConnection || !walletConnection.accessToken) {\n      return () => {};\n    }\n\n    const bridge = E(wc).getAdminBootstrap(\n      walletConnection.accessToken,\n      makeFixedWebSocketConnector(walletConnection.url),\n    );\n\n    const { backendIt, cancel } = makeBackendFromWalletBridge(bridge);\n    const rethrowIfNotCancelled = e => {\n      if (!cancelled) {\n        throw e;\n      }\n    };\n\n    observeIterator(backendIt, {\n      updateState: be => {\n        if (cancelled) {\n          throw Error('cancelled');\n        }\n        setBackend(be);\n      },\n    }).catch(rethrowIfNotCancelled);\n\n    return () => {\n      cancelled = true;\n      disconnect();\n      cancel();\n    };\n  }, [wc, walletConnection]);\n\n  return (\n    <AgoricWalletConnection\n      onState={onWalletState}\n      className={classes.hidden}\n    />\n  );\n};\n\nexport default withApplicationContext(WalletConnection, context => ({\n  setConnectionState: context.setConnectionState,\n  disconnect: context.disconnect,\n  setBackend: context.setBackend,\n  walletConnection: context.walletConnection,\n}));\n","import { createComponent } from '@lit-labs/react';\n\nimport { AgoricWalletConnection } from './index.js';\n\n// Upgrade the tags.\nimport './agoric-wallet-connection.js';\n\nexport const makeReactAgoricWalletConnection = React =>\n  createComponent(React, 'agoric-wallet-connection', AgoricWalletConnection, {\n    onState: 'state',\n  });\n"],"names":["GROUND_STATE","harden","generation","value","undefined","makeState","priorState","details","X","assert","makeStoreCoordinator","stateStore","makeScalarMapStore","getCurrentState","key","has","get","Far","getRecentState","async","tryUpdateState","desiredState","guardPattern","currentState","nextGeneration","desiredGeneration","desiredValue","equal","matches","nextState","init","set","makeCache","coordinator","cache","update","E","M","Promise","resolve","reject","retryTransaction","updatedValue","recentState","updatedState","catch","then","reduce","rawReduce","initialContext","error","location","connectionParams","common","transition","ctx","ev","makeConnectionMachine","createMachine","idle","state","locating","immediate","guard","href","connecting","bridged","approving","makeAdminWebSocketConnector","component","ws","onAdminOpen","_startCapTP","obj","readyState","WebSocket","OPEN","send","JSON","stringify","_captp","dispatch","getBootstrap","addEventListener","parse","data","adminFacet","getLoadingUpdate","loadingNotifier","getUpdateSince","includes","console","log","updateCount","waitForBootstrap","wallet","getAdminFacet","service","type","_bridgePK","render","hostConnected","accessToken","context","hrefs","window","connect","shift","url","URL","protocol","replace","searchParams","timeout","setTimeout","close","clearTimeout","_ev","length","reset","hostDisconnected","makeBridgeIframeConnector","connectedOnMessage","detail","startsWith","onMessage","event","suggestedDappPetname","_walletCallbacks","append","html","onOpen","onError","DEFAULT_LOCATOR_URL","delay","ms","resolution","AgoricWalletConnection","makeCapTP","defaultMakeCapTP","LitElement","styles","css","properties","String","this","machine","name","isResetting","abort","_connector","makePromiseKit","_cache","promise","getCacheCoordinator","optGuardPattern","walletConnection","_walletConnection","getScopedBridge","dappOrigin","origin","makeConnector","caller","getAdminBootstrap","constructor","super","onState","requestUpdate","CustomEvent","dispatchEvent","interpret","firstUpdated","_nextEpoch","needDappApproval","dappApproved","onLocateMessage","ourEndpoint","ourPublishedBootstrap","epoch","disconnectedCallback","backend","makeAgoricWalletConnection","AgoricIframeMessenger","registerThis","_that","src","_contentWindow","_origin","_timeout","bind","_onMessage","connectedCallback","removeEventListener","_onLoad","_onError","iframe","renderRoot","querySelector","contentWindow","Error","preventDefault","source","postMessage","makeAgoricIframeMessenger","customElements","define","warn","makeFixedWebSocketConnector","useStyles","makeStyles","_","hidden","display","React","createComponent","withApplicationContext","setBackend","setConnectionState","disconnect","classes","wc","setWC","useState","cancelled","onWalletState","useCallback","newWC","useEffect","bridge","backendIt","cancel","makeBackendFromWalletBridge","observeIterator","updateState","be","e","className"],"sourceRoot":""}