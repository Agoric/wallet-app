{"version":3,"file":"static/js/770.c2760126.chunk.js","mappings":"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","sources":["../../../../node_modules/@endo/captp/src/trap.js","../../../../node_modules/@endo/captp/src/captp.js","../../../../node_modules/@endo/captp/src/atomics.js"],"sourcesContent":["// @ts-check\n// Lifted mostly from `@endo/eventual-send/src/E.js`.\n\nimport './types.js';\n\n/**\n * Default implementation of Trap for near objects.\n *\n * @type {TrapImpl}\n */\nexport const nearTrapImpl = harden({\n  applyFunction(target, args) {\n    return target(...args);\n  },\n  applyMethod(target, prop, args) {\n    return target[prop](...args);\n  },\n  get(target, prop) {\n    return target[prop];\n  },\n});\n\n/** @type {ProxyHandler<any>} */\nconst baseFreezableProxyHandler = {\n  set(_target, _prop, _value) {\n    return false;\n  },\n  isExtensible(_target) {\n    return false;\n  },\n  setPrototypeOf(_target, _value) {\n    return false;\n  },\n  deleteProperty(_target, _prop) {\n    return false;\n  },\n};\n\n/**\n * A Proxy handler for Trap(x)\n *\n * @param {*} x Any value passed to Trap(x)\n * @param {TrapImpl} trapImpl\n * @returns {ProxyHandler}\n */\nconst TrapProxyHandler = (x, trapImpl) => {\n  return harden({\n    ...baseFreezableProxyHandler,\n    get(_target, p, _receiver) {\n      return (...args) => trapImpl.applyMethod(x, p, args);\n    },\n    apply(_target, _thisArg, argArray = []) {\n      return trapImpl.applyFunction(x, argArray);\n    },\n    has(_target, _p) {\n      // TODO: has property is not yet transferrable over captp.\n      return true;\n    },\n  });\n};\n\n/**\n * @param {TrapImpl} trapImpl\n * @returns {Trap}\n */\nexport const makeTrap = trapImpl => {\n  const Trap = x => {\n    const handler = TrapProxyHandler(x, trapImpl);\n    return harden(new Proxy(() => {}, handler));\n  };\n\n  const makeTrapGetterProxy = x => {\n    const handler = harden({\n      ...baseFreezableProxyHandler,\n      has(_target, _prop) {\n        // TODO: has property is not yet transferrable over captp.\n        return true;\n      },\n      get(_target, prop) {\n        return trapImpl.get(x, prop);\n      },\n    });\n    return new Proxy(Object.create(null), handler);\n  };\n  Trap.get = makeTrapGetterProxy;\n\n  return harden(Trap);\n};\n","// @ts-check\n/// <reference types=\"ses\"/>\n\n/** @template Slot @typedef {import('@endo/marshal').ConvertValToSlot<Slot>} ConvertValToSlot */\n/** @template Slot @typedef {import('@endo/marshal').ConvertSlotToVal<Slot>} ConvertSlotToVal */\n\n// Your app may need to `import '@endo/eventual-send/shim.js'` to get HandledPromise\n\n// This logic was mostly lifted from @agoric/swingset-vat liveSlots.js\n// Defects in it are mfig's fault.\nimport { Remotable, Far, makeMarshal, QCLASS } from '@endo/marshal';\nimport { E, HandledPromise } from '@endo/eventual-send';\nimport { isPromise, makePromiseKit } from '@endo/promise-kit';\n\nimport { makeTrap } from './trap.js';\n\nimport './types.js';\n\nexport { E };\n\nconst { details: X } = assert;\n\n/**\n * @param {any} maybeThenable\n * @returns {boolean}\n */\nconst isThenable = maybeThenable =>\n  maybeThenable && typeof maybeThenable.then === 'function';\n\n/**\n * @typedef {Object} CapTPOptions the options to makeCapTP\n * @property {(err: any) => void} onReject\n * @property {number} epoch an integer tag to attach to all messages in order to\n * assist in ignoring earlier defunct instance's messages\n * @property {TrapGuest} trapGuest if specified, enable this CapTP (guest) to\n * use Trap(target) to block while the recipient (host) resolves and\n * communicates the response to the message\n * @property {TrapHost} trapHost if specified, enable this CapTP (host) to serve\n * objects marked with makeTrapHandler to synchronous clients (guests)\n */\n\n/**\n * Create a CapTP connection.\n *\n * @param {string} ourId our name for the current side\n * @param {(obj: Record<string, any>) => void} rawSend send a JSONable packet\n * @param {any} bootstrapObj the object to export to the other side\n * @param {Partial<CapTPOptions>} opts options to the connection\n */\nexport const makeCapTP = (\n  ourId,\n  rawSend,\n  bootstrapObj = undefined,\n  opts = {},\n) => {\n  const {\n    onReject = err => console.error('CapTP', ourId, 'exception:', err),\n    epoch = 0,\n    trapGuest,\n    trapHost,\n  } = opts;\n\n  // It's a hazard to have trapGuest and trapHost both enabled, as we may\n  // encounter deadlock.  Without a lot more bookkeeping, we can't detect it for\n  // more general networks of CapTPs, but we are conservative for at least this\n  // one case.\n  assert(\n    !(trapHost && trapGuest),\n    X`CapTP ${ourId} can only be one of either trapGuest or trapHost`,\n  );\n\n  const disconnectReason = id =>\n    Error(`${JSON.stringify(id)} connection closed`);\n\n  /** @type {Map<string, Promise<IteratorResult<void, void>>>} */\n  const trapIteratorResultP = new Map();\n  /** @type {Map<string, AsyncIterator<void, void, any>>} */\n  const trapIterator = new Map();\n\n  /** @type {any} */\n  let unplug = false;\n  const quietReject = async (reason = undefined, returnIt = true) => {\n    if ((unplug === false || reason !== unplug) && reason !== undefined) {\n      onReject(reason);\n    }\n    if (!returnIt) {\n      return Promise.resolve();\n    }\n\n    // Silence the unhandled rejection warning, but don't affect\n    // the user's handlers.\n    const p = Promise.reject(reason);\n    p.catch(_ => {});\n    return p;\n  };\n\n  /**\n   * @param {Record<string, any>} obj\n   */\n  const send = obj => {\n    // Don't throw here if unplugged, just don't send.\n    if (unplug === false) {\n      rawSend(obj);\n    }\n  };\n\n  /**\n   * convertValToSlot and convertSlotToVal both perform side effects,\n   * populating the c-lists (imports/exports/questions/answers) upon\n   * marshalling/unmarshalling.  As we traverse the datastructure representing\n   * the message, we discover what we need to import/export and send relevant\n   * messages across the wire.\n   */\n  const { serialize, unserialize } = makeMarshal(\n    // eslint-disable-next-line no-use-before-define\n    convertValToSlot,\n    // eslint-disable-next-line no-use-before-define\n    convertSlotToVal,\n    {\n      marshalName: `captp:${ourId}`,\n      // TODO Temporary hack.\n      // See https://github.com/Agoric/agoric-sdk/issues/2780\n      errorIdNum: 20000,\n    },\n  );\n\n  /** @type {WeakMap<any, CapTPSlot>} */\n  const valToSlot = new WeakMap(); // exports looked up by val\n  /** @type {Map<CapTPSlot, any>} */\n  const slotToVal = new Map(); // reverse\n  const exportedTrapHandlers = new WeakSet();\n\n  // Used to construct slot names for promises/non-promises.\n  // In this version of CapTP we use strings for export/import slot names.\n  // prefixed with 'p' if promises and 'o' otherwise;\n  let lastPromiseID = 0;\n  let lastExportID = 0;\n  // Since we decide the ids for questions, we use this to increment the\n  // question key\n  let lastQuestionID = 0;\n\n  /** @type {Map<string, any>} */\n  const questions = new Map(); // chosen by us\n  /** @type {Map<string, any>} */\n  const answers = new Map(); // chosen by our peer\n  /** @type {Map<number, any>} */\n  const imports = new Map(); // chosen by our peer\n\n  /**\n   * Called at marshalling time.  Either retrieves an existing export, or if\n   * not yet exported, records this exported object.  If a promise, sets up a\n   * promise listener to inform the other side when the promise is\n   * fulfilled/broken.\n   *\n   * @type {ConvertValToSlot<CapTPSlot>}\n   */\n  function convertValToSlot(val) {\n    if (!valToSlot.has(val)) {\n      /**\n       * new export\n       *\n       * @type {CapTPSlot}\n       */\n      let slot;\n      if (isPromise(val)) {\n        // This is a promise, so we're going to increment the lastPromiseId\n        // and use that to construct the slot name.  Promise slots are prefaced\n        // with 'p+'.\n        lastPromiseID += 1;\n        const promiseID = lastPromiseID;\n        slot = `p+${promiseID}`;\n        // Set up promise listener to inform other side when this promise\n        // is fulfilled/broken\n        val.then(\n          res =>\n            send({\n              type: 'CTP_RESOLVE',\n              promiseID,\n              res: serialize(harden(res)),\n            }),\n          rej =>\n            send({\n              type: 'CTP_RESOLVE',\n              promiseID,\n              rej: serialize(harden(rej)),\n            }),\n        );\n      } else {\n        // Since this isn't a promise, we instead increment the lastExportId and\n        // use that to construct the slot name.  Non-promises are prefaced with\n        // 'o+' for normal objects, or `t+` for syncable.\n        lastExportID += 1;\n        const exportID = lastExportID;\n        if (exportedTrapHandlers.has(val)) {\n          slot = `t+${exportID}`;\n        } else {\n          slot = `o+${exportID}`;\n        }\n      }\n      // Now record the export in both valToSlot and slotToVal so we can look it\n      // up from either the value or the slot name later.\n      valToSlot.set(val, slot);\n      slotToVal.set(slot, val);\n    }\n    // At this point, the value is guaranteed to be exported, so return the\n    // associated slot number.\n    const slot = valToSlot.get(val);\n    assert.typeof(slot, 'string');\n    return slot;\n  }\n\n  /**\n   * Generate a new question in the questions table and set up a new\n   * remote handled promise.\n   *\n   * @returns {[string, ReturnType<typeof makeRemoteKit>]}\n   */\n  const makeQuestion = () => {\n    lastQuestionID += 1;\n    const questionID = `${ourId}#${lastQuestionID}`;\n    // eslint-disable-next-line no-use-before-define\n    const pr = makeRemoteKit(questionID);\n    questions.set(questionID, pr);\n\n    // To fix #2846:\n    // We return 'p' to the handler, and the eventual resolution of 'p' will\n    // be used to resolve the caller's Promise, but the caller never sees 'p'\n    // itself. The caller got back their Promise before the handler ever got\n    // invoked, and thus before queueMessage was called. If that caller\n    // passes the Promise they received as argument or return value, we want\n    // it to serialize as resultVPID. And if someone passes resultVPID to\n    // them, we want the user-level code to get back that Promise, not 'p'.\n    lastPromiseID += 1;\n    const promiseID = lastPromiseID;\n    const resultVPID = `p+${promiseID}`;\n    valToSlot.set(pr.p, resultVPID);\n    slotToVal.set(resultVPID, pr.p);\n\n    return [questionID, pr];\n  };\n\n  // Make a remote promise for `target` (an id in the questions table)\n  const makeRemoteKit = target => {\n    // This handler is set up such that it will transform both\n    // attribute access and method invocation of this remote promise\n    // as also being questions / remote handled promises\n    const handler = {\n      get(_o, prop) {\n        if (unplug !== false) {\n          return quietReject(unplug);\n        }\n        const [questionID, pr] = makeQuestion();\n        send({\n          type: 'CTP_CALL',\n          epoch,\n          questionID,\n          target,\n          method: serialize(harden([prop])),\n        });\n        return harden(pr.p);\n      },\n      applyFunction(_o, args) {\n        if (unplug !== false) {\n          return quietReject(unplug);\n        }\n        const [questionID, pr] = makeQuestion();\n        send({\n          type: 'CTP_CALL',\n          epoch,\n          questionID,\n          target,\n          method: serialize(harden([null, args])),\n        });\n        return harden(pr.p);\n      },\n      applyMethod(_o, prop, args) {\n        if (unplug !== false) {\n          return quietReject(unplug);\n        }\n        // Support: o~.[prop](...args) remote method invocation\n        const [questionID, pr] = makeQuestion();\n        send({\n          type: 'CTP_CALL',\n          epoch,\n          questionID,\n          target,\n          method: serialize(harden([prop, args])),\n        });\n        return harden(pr.p);\n      },\n    };\n\n    const pr = {};\n    pr.p = new HandledPromise((res, rej, resolveWithPresence) => {\n      pr.rej = rej;\n      pr.resPres = () => resolveWithPresence(handler);\n      pr.res = res;\n    }, handler);\n\n    // Silence the unhandled rejection warning, but don't affect\n    // the user's handlers.\n    pr.p.catch(e => quietReject(e, false));\n\n    return harden(pr);\n  };\n\n  /**\n   * Set up import\n   *\n   * @type {ConvertSlotToVal<CapTPSlot>}\n   */\n  function convertSlotToVal(theirSlot, iface = undefined) {\n    let val;\n    // Invert slot direction from other side.\n\n    // Inverted to prevent namespace collisions between slots we\n    // allocate and the ones the other side allocates.  If we allocate\n    // a slot, serialize it to the other side, and they send it back to\n    // us, we need to reference just our own slot, not one from their\n    // side.\n    const otherDir = theirSlot[1] === '+' ? '-' : '+';\n    const slot = `${theirSlot[0]}${otherDir}${theirSlot.slice(2)}`;\n    if (!slotToVal.has(slot)) {\n      // Make a new handled promise for the slot.\n      const pr = makeRemoteKit(slot);\n      if (slot[0] === 'o' || slot[0] === 't') {\n        if (iface === undefined) {\n          iface = `Alleged: Presence ${ourId} ${slot}`;\n        }\n        // A new remote presence\n        // Use Remotable rather than Far to make a remote from a presence\n        val = Remotable(iface, undefined, pr.resPres());\n      } else {\n        // A new promise\n        imports.set(Number(slot.slice(2)), pr);\n        val = pr.p;\n      }\n      slotToVal.set(slot, val);\n      valToSlot.set(val, slot);\n    }\n    return slotToVal.get(slot);\n  }\n\n  // Message handler used for CapTP dispatcher\n  const handler = {\n    // Remote is asking for bootstrap object\n    async CTP_BOOTSTRAP(obj) {\n      const { questionID } = obj;\n      const bootstrap =\n        typeof bootstrapObj === 'function' ? bootstrapObj(obj) : bootstrapObj;\n      E.when(bootstrap, bs => {\n        // console.log('sending bootstrap', bootstrap);\n        answers.set(questionID, bs);\n        return send({\n          type: 'CTP_RETURN',\n          epoch,\n          answerID: questionID,\n          result: serialize(bs),\n        });\n      });\n    },\n    // Remote is invoking a method or retrieving a property.\n    async CTP_CALL(obj) {\n      // questionId: Remote promise (for promise pipelining) this call is\n      //   to fulfill\n      // target: Slot id of the target to be invoked.  Checks against\n      //   answers first; otherwise goes through unserializer\n      const { questionID, target, trap } = obj;\n\n      const [prop, args] = unserialize(obj.method);\n      let val;\n      if (answers.has(target)) {\n        val = answers.get(target);\n      } else {\n        val = unserialize({\n          body: JSON.stringify({\n            [QCLASS]: 'slot',\n            index: 0,\n          }),\n          slots: [target],\n        });\n      }\n\n      /** @type {(isReject: boolean, value: any) => void} */\n      let processResult = (isReject, value) => {\n        send({\n          type: 'CTP_RETURN',\n          epoch,\n          answerID: questionID,\n          [isReject ? 'exception' : 'result']: serialize(harden(value)),\n        });\n      };\n      if (trap) {\n        assert(\n          exportedTrapHandlers.has(val),\n          X`Refused Trap(${val}) because target was not registered with makeTrapHandler`,\n        );\n        assert.typeof(\n          trapHost,\n          'function',\n          X`CapTP cannot answer Trap(${val}) without a trapHost function`,\n        );\n\n        // We need to create a promise for the \"isDone\" iteration right now to\n        // prevent a race with the other side.\n        const resultPK = makePromiseKit();\n        trapIteratorResultP.set(questionID, resultPK.promise);\n\n        processResult = async (isReject, value) => {\n          const serialized = serialize(harden(value));\n          const ait = trapHost([isReject, serialized]);\n          if (!ait) {\n            // One-shot, no async iterator.\n            resultPK.resolve({ done: true });\n            return;\n          }\n\n          // We're ready for them to drive the iterator.\n          trapIterator.set(questionID, ait);\n          resultPK.resolve({ done: false });\n        };\n      }\n\n      // If `args` is supplied, we're applying a method or function...\n      // otherwise this is property access\n      let hp;\n      if (!args) {\n        hp = HandledPromise.get(val, prop);\n      } else if (prop === null) {\n        hp = HandledPromise.applyFunction(val, args);\n      } else {\n        hp = HandledPromise.applyMethod(val, prop, args);\n      }\n\n      // Answer with our handled promise\n      answers.set(questionID, hp);\n\n      // We let rejections bubble up to our caller, `dispatch`.\n      await hp\n        // Process this handled promise method's result when settled.\n        .then(\n          fulfilment => processResult(false, fulfilment),\n          reason => processResult(true, reason),\n        );\n    },\n    // Have the host serve more of the reply.\n    CTP_TRAP_ITERATE: async obj => {\n      assert(trapHost, X`CTP_TRAP_ITERATE is impossible without a trapHost`);\n      const { questionID, serialized } = obj;\n\n      const resultP = trapIteratorResultP.get(questionID);\n      assert(resultP, X`CTP_TRAP_ITERATE did not expect ${questionID}`);\n\n      const [method, args] = unserialize(serialized);\n\n      const getNextResultP = async () => {\n        const result = await resultP;\n\n        // Done with this trap iterator.\n        const cleanup = () => {\n          trapIterator.delete(questionID);\n          trapIteratorResultP.delete(questionID);\n          return harden({ done: true });\n        };\n\n        // We want to ensure we clean up the iterator in case of any failure.\n        try {\n          if (!result || result.done) {\n            return cleanup();\n          }\n\n          const ait = trapIterator.get(questionID);\n          if (!ait) {\n            // The iterator is done, so we're done.\n            return cleanup();\n          }\n\n          // Drive the next iteration.\n          return await ait[method](...args);\n        } catch (e) {\n          cleanup();\n          if (!e) {\n            assert.fail(\n              X`trapGuest expected trapHost AsyncIterator(${questionID}) to be done, but it wasn't`,\n            );\n          }\n          assert.note(e, X`trapHost AsyncIterator(${questionID}) threw`);\n          throw e;\n        }\n      };\n\n      // Store the next result promise.\n      const nextResultP = getNextResultP();\n      trapIteratorResultP.set(questionID, nextResultP);\n\n      // Ensure that our caller handles any rejection.\n      await nextResultP;\n    },\n    // Answer to one of our questions.\n    async CTP_RETURN(obj) {\n      const { result, exception, answerID } = obj;\n      if (!questions.has(answerID)) {\n        throw new Error(\n          `Got an answer to a question we have not asked. (answerID = ${answerID} )`,\n        );\n      }\n      const pr = questions.get(answerID);\n      if ('exception' in obj) {\n        pr.rej(unserialize(exception));\n      } else {\n        pr.res(unserialize(result));\n      }\n    },\n    // Resolution to an imported promise\n    async CTP_RESOLVE(obj) {\n      const { promiseID, res, rej } = obj;\n      if (!imports.has(promiseID)) {\n        throw new Error(\n          `Got a resolvement of a promise we have not imported. (promiseID = ${promiseID} )`,\n        );\n      }\n      const pr = imports.get(promiseID);\n      if ('rej' in obj) {\n        pr.rej(unserialize(rej));\n      } else {\n        pr.res(unserialize(res));\n      }\n      imports.delete(promiseID);\n    },\n    // The other side has signaled something has gone wrong.\n    // Pull the plug!\n    async CTP_DISCONNECT(obj) {\n      const { reason = disconnectReason(ourId) } = obj;\n      if (unplug === false) {\n        // Reject with the original reason.\n        quietReject(obj.reason, false);\n        unplug = reason;\n        // Deliver the object, even though we're unplugged.\n        rawSend(obj);\n      }\n      for (const pr of questions.values()) {\n        pr.rej(reason);\n      }\n      for (const pr of imports.values()) {\n        pr.rej(reason);\n      }\n    },\n  };\n\n  // Get a reference to the other side's bootstrap object.\n  const getBootstrap = async () => {\n    if (unplug !== false) {\n      return quietReject(unplug);\n    }\n    const [questionID, pr] = makeQuestion();\n    send({\n      type: 'CTP_BOOTSTRAP',\n      epoch,\n      questionID,\n    });\n    return harden(pr.p);\n  };\n  harden(handler);\n\n  // Return a dispatch function.\n  const dispatch = obj => {\n    try {\n      if (unplug !== false) {\n        return false;\n      }\n      const fn = handler[obj.type];\n      if (fn) {\n        fn(obj).catch(e => quietReject(e, false));\n        return true;\n      }\n      return false;\n    } catch (e) {\n      quietReject(e, false);\n      return false;\n    }\n  };\n\n  // Abort a connection.\n  const abort = (reason = undefined) => {\n    dispatch({ type: 'CTP_DISCONNECT', epoch, reason });\n  };\n\n  const makeTrapHandler = (name, obj) => {\n    const far = Far(name, obj);\n    exportedTrapHandlers.add(far);\n    return far;\n  };\n\n  // Put together our return value.\n  const rets = {\n    abort,\n    dispatch,\n    getBootstrap,\n    serialize,\n    unserialize,\n    makeTrapHandler,\n    Trap: /** @type {Trap | undefined} */ (undefined),\n  };\n\n  if (trapGuest) {\n    assert.typeof(trapGuest, 'function', X`opts.trapGuest must be a function`);\n\n    // Create the Trap proxy maker.\n    const makeTrapImpl = implMethod => (target, ...implArgs) => {\n      assert(\n        Promise.resolve(target) !== target,\n        X`Trap(${target}) target cannot be a promise`,\n      );\n\n      const slot = valToSlot.get(target);\n      assert(\n        slot && slot[1] === '-',\n        X`Trap(${target}) target was not imported`,\n      );\n      assert(\n        slot[0] === 't',\n        X`Trap(${target}) imported target was not created with makeTrapHandler`,\n      );\n\n      // Send a \"trap\" message.\n      lastQuestionID += 1;\n      const questionID = `${ourId}#${lastQuestionID}`;\n\n      // Encode the \"method\" parameter of the CTP_CALL.\n      let method;\n      switch (implMethod) {\n        case 'get': {\n          const [prop] = implArgs;\n          method = serialize(harden([prop]));\n          break;\n        }\n        case 'applyFunction': {\n          const [args] = implArgs;\n          method = serialize(harden([null, args]));\n          break;\n        }\n        case 'applyMethod': {\n          const [prop, args] = implArgs;\n          method = serialize(harden([prop, args]));\n          break;\n        }\n        default: {\n          assert.fail(X`Internal error; unrecognized implMethod ${implMethod}`);\n        }\n      }\n\n      // Set up the trap call with its identifying information and a way to send\n      // messages over the current CapTP data channel.\n      const [isException, serialized] = trapGuest({\n        trapMethod: implMethod,\n        slot,\n        trapArgs: implArgs,\n        startTrap: () => {\n          // Send the call metadata over the connection.\n          send({\n            type: 'CTP_CALL',\n            epoch,\n            trap: true, // This is the magic marker.\n            questionID,\n            target: slot,\n            method,\n          });\n\n          // Return an IterationObserver.\n          const makeIteratorMethod = (iteratorMethod, done) => (...args) => {\n            send({\n              type: 'CTP_TRAP_ITERATE',\n              epoch,\n              questionID,\n              serialized: serialize(harden([iteratorMethod, args])),\n            });\n            return harden({ done, value: undefined });\n          };\n          return harden({\n            next: makeIteratorMethod('next', false),\n            return: makeIteratorMethod('return', true),\n            throw: makeIteratorMethod('throw', true),\n          });\n        },\n      });\n\n      const value = unserialize(serialized);\n      assert(\n        !isThenable(value),\n        X`Trap(${target}) reply cannot be a Thenable; have ${value}`,\n      );\n\n      if (isException) {\n        throw value;\n      }\n      return value;\n    };\n\n    /** @type {TrapImpl} */\n    const trapImpl = {\n      applyFunction: makeTrapImpl('applyFunction'),\n      applyMethod: makeTrapImpl('applyMethod'),\n      get: makeTrapImpl('get'),\n    };\n    harden(trapImpl);\n\n    rets.Trap = makeTrap(trapImpl);\n  }\n\n  return harden(rets);\n};\n","// @ts-check\n/// <reference types=\"ses\"/>\n\nconst { details: X } = assert;\n\n// This is a pathological minimum, but exercised by the unit test.\nexport const MIN_DATA_BUFFER_LENGTH = 1;\n\n// Calculate how big the transfer buffer needs to be.\nexport const TRANSFER_OVERHEAD_LENGTH =\n  BigUint64Array.BYTES_PER_ELEMENT + Int32Array.BYTES_PER_ELEMENT;\nexport const MIN_TRANSFER_BUFFER_LENGTH =\n  MIN_DATA_BUFFER_LENGTH + TRANSFER_OVERHEAD_LENGTH;\n\n// These are bit flags for the status element of the transfer buffer.\nconst STATUS_WAITING = 1;\nconst STATUS_FLAG_DONE = 2;\nconst STATUS_FLAG_REJECT = 4;\n\n/**\n * Return a status buffer, length buffer, and data buffer backed by transferBuffer.\n *\n * @param {SharedArrayBuffer} transferBuffer the backing buffer\n */\nconst splitTransferBuffer = transferBuffer => {\n  assert(\n    transferBuffer.byteLength >= MIN_TRANSFER_BUFFER_LENGTH,\n    X`Transfer buffer of ${transferBuffer.byteLength} bytes is smaller than MIN_TRANSFER_BUFFER_LENGTH ${MIN_TRANSFER_BUFFER_LENGTH}`,\n  );\n  const lenbuf = new BigUint64Array(transferBuffer, 0, 1);\n\n  // The documentation says that this needs to be an Int32Array for use with\n  // Atomics.notify:\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/notify#syntax\n  const statusbuf = new Int32Array(transferBuffer, lenbuf.byteLength, 1);\n  const overheadLength = lenbuf.byteLength + statusbuf.byteLength;\n  assert.equal(\n    overheadLength,\n    TRANSFER_OVERHEAD_LENGTH,\n    X`Internal error; actual overhead ${overheadLength} of bytes is not TRANSFER_OVERHEAD_LENGTH ${TRANSFER_OVERHEAD_LENGTH}`,\n  );\n  const databuf = new Uint8Array(transferBuffer, overheadLength);\n  assert(\n    databuf.byteLength >= MIN_DATA_BUFFER_LENGTH,\n    X`Transfer buffer of size ${transferBuffer.byteLength} only supports ${databuf.byteLength} data bytes; need at least ${MIN_DATA_BUFFER_LENGTH}`,\n  );\n  return { statusbuf, lenbuf, databuf };\n};\n\n/**\n * Create a trapHost that can be paired with makeAtomicsTrapGuest.\n *\n * This host encodes the transfer buffer and returns it in consecutive slices\n * when the guest iterates over it.\n *\n * @param {SharedArrayBuffer} transferBuffer\n * @returns {TrapHost}\n */\nexport const makeAtomicsTrapHost = transferBuffer => {\n  const { statusbuf, lenbuf, databuf } = splitTransferBuffer(transferBuffer);\n\n  const te = new TextEncoder();\n\n  return async function* trapHost([isReject, serialized]) {\n    // Get the complete encoded message buffer.\n    const json = JSON.stringify(serialized);\n    const encoded = te.encode(json);\n\n    // Send chunks in the data transfer buffer.\n    let i = 0;\n    let done = false;\n    while (!done) {\n      // Copy the next slice of the encoded arry to the data buffer.\n      const subenc = encoded.subarray(i, i + databuf.length);\n      databuf.set(subenc);\n\n      // Save the length of the remaining data.\n      const remaining = BigInt(encoded.length - i);\n      lenbuf[0] = remaining;\n\n      // Calculate the next slice, and whether this is the last one.\n      i += subenc.length;\n      done = i >= encoded.length;\n\n      // Find bitflags to represent the rejected and finished state.\n      const rejectFlag = isReject ? STATUS_FLAG_REJECT : 0;\n      const doneFlag = done ? STATUS_FLAG_DONE : 0;\n\n      // Notify our guest for this data buffer.\n\n      // eslint-disable-next-line no-bitwise\n      statusbuf[0] = rejectFlag | doneFlag;\n      Atomics.notify(statusbuf, 0, +Infinity);\n\n      if (!done) {\n        // Wait until the next call to `it.next()`.  If the guest calls\n        // `it.return()` or `it.throw()`, then this yield will return or throw,\n        // terminating the generator function early.\n        yield;\n      }\n    }\n  };\n};\n\n/**\n * Create a trapGuest that can be paired with makeAtomicsTrapHost.\n *\n * This guest iterates through the consecutive slices of the JSON-encoded data,\n * then returns it.\n *\n * @param {SharedArrayBuffer} transferBuffer\n * @returns {TrapGuest}\n */\nexport const makeAtomicsTrapGuest = transferBuffer => {\n  const { statusbuf, lenbuf, databuf } = splitTransferBuffer(transferBuffer);\n\n  return ({ startTrap }) => {\n    // Start by sending the trap call to the host.\n    const it = startTrap();\n\n    /** @type {Uint8Array | undefined} */\n    let encoded;\n    let i = 0;\n    let done = false;\n    while (!done) {\n      // Tell that we are ready for another buffer.\n      statusbuf[0] = STATUS_WAITING;\n      const { done: itDone } = it.next();\n      assert(!itDone, X`Internal error; it.next() returned done=${itDone}`);\n\n      // Wait for the host to wake us.\n      Atomics.wait(statusbuf, 0, STATUS_WAITING);\n\n      // Determine whether this is the last buffer.\n      // eslint-disable-next-line no-bitwise\n      done = (statusbuf[0] & STATUS_FLAG_DONE) !== 0;\n\n      // Accumulate the encoded buffer.\n      const remaining = Number(lenbuf[0]);\n      const datalen = Math.min(remaining, databuf.byteLength);\n      if (!encoded) {\n        if (done) {\n          // Special case: we are done on first try, so we don't need to copy\n          // anything.\n          encoded = databuf.subarray(0, datalen);\n          break;\n        }\n        // Allocate our buffer for the remaining data.\n        encoded = new Uint8Array(remaining);\n      }\n\n      // Copy the next buffer.\n      encoded.set(databuf.subarray(0, datalen), i);\n      i += datalen;\n    }\n\n    // This throw is harmless if the host iterator has already finished, and\n    // if not finished, captp will correctly raise an error.\n    //\n    // TODO: It would be nice to use an error type, but captp is just too\n    // noisy with spurious \"Temporary logging of sent error\" messages.\n    // it.throw(assert.error(X`Trap host has not finished`));\n    it.throw(null);\n\n    // eslint-disable-next-line no-bitwise\n    const isReject = !!(statusbuf[0] & STATUS_FLAG_REJECT);\n\n    // Decode the accumulated encoded buffer.\n    const td = new TextDecoder('utf-8');\n    const json = td.decode(encoded);\n\n    // Parse the JSON data into marshalled form.\n    const serialized = JSON.parse(json);\n    return [isReject, serialized];\n  };\n};\n"],"names":["harden","applyFunction","target","args","applyMethod","prop","get","baseFreezableProxyHandler","set","_target","_prop","_value","isExtensible","setPrototypeOf","deleteProperty","makeTrap","trapImpl","Trap","x","handler","p","_receiver","apply","_thisArg","argArray","has","_p","TrapProxyHandler","Proxy","Object","create","details","X","assert","isThenable","maybeThenable","then","makeCapTP","ourId","rawSend","bootstrapObj","undefined","opts","onReject","err","console","error","epoch","trapGuest","trapHost","disconnectReason","id","Error","JSON","stringify","trapIteratorResultP","Map","trapIterator","unplug","quietReject","async","reason","returnIt","Promise","resolve","reject","catch","_","send","obj","serialize","unserialize","makeMarshal","convertValToSlot","convertSlotToVal","marshalName","errorIdNum","valToSlot","WeakMap","slotToVal","exportedTrapHandlers","WeakSet","lastPromiseID","lastExportID","lastQuestionID","questions","answers","imports","val","slot","isPromise","promiseID","res","type","rej","exportID","typeof","makeQuestion","questionID","pr","makeRemoteKit","resultVPID","_o","method","HandledPromise","resolveWithPresence","resPres","e","theirSlot","iface","otherDir","slice","Remotable","Number","bootstrap","E","bs","answerID","result","trap","body","QCLASS","index","slots","hp","processResult","isReject","value","resultPK","makePromiseKit","promise","serialized","ait","done","fulfilment","CTP_TRAP_ITERATE","resultP","nextResultP","cleanup","delete","fail","note","getNextResultP","exception","values","getBootstrap","dispatch","fn","abort","makeTrapHandler","name","far","Far","add","rets","makeTrapImpl","implMethod","implArgs","isException","trapMethod","trapArgs","startTrap","makeIteratorMethod","iteratorMethod","next","return","throw","BigUint64Array","BYTES_PER_ELEMENT","Int32Array"],"sourceRoot":""}