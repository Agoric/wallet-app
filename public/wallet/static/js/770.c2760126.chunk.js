"use strict";(globalThis.webpackChunk_agoric_wallet_ui=globalThis.webpackChunk_agoric_wallet_ui||[]).push([[770],{3770:(e,t,r)=>{r.d(t,{cI:()=>n.cI,Ol:()=>h});var n=r(6912),o=r(603),a=r(5725);harden({applyFunction:(e,t)=>e(...t),applyMethod:(e,t,r)=>e[t](...r),get:(e,t)=>e[t]});const s={set:(e,t,r)=>!1,isExtensible:e=>!1,setPrototypeOf:(e,t)=>!1,deleteProperty:(e,t)=>!1},c=e=>{const t=t=>{const r=((e,t)=>harden({...s,get:(r,n,o)=>function(){for(var r=arguments.length,o=new Array(r),a=0;a<r;a++)o[a]=arguments[a];return t.applyMethod(e,n,o)},apply(r,n){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];return t.applyFunction(e,o)},has:(e,t)=>!0}))(t,e);return harden(new Proxy((()=>{}),r))};return t.get=t=>{const r=harden({...s,has:(e,t)=>!0,get:(r,n)=>e.get(t,n)});return new Proxy(Object.create(null),r)},harden(t)},{details:i}=assert,p=e=>e&&"function"===typeof e.then,h=function(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};const{onReject:h=(t=>console.error("CapTP",e,"exception:",t)),epoch:l=0,trapGuest:d,trapHost:u}=s;assert(!(u&&d),i`CapTP ${e} can only be one of either trapGuest or trapHost`);const T=e=>Error(`${JSON.stringify(e)} connection closed`),y=new Map,g=new Map;let f=!1;const w=async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:void 0,t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(!1!==f&&e===f||void 0===e||h(e),!t)return Promise.resolve();const r=Promise.reject(e);return r.catch((e=>{})),r},P=e=>{!1===f&&t(e)},{serialize:E,unserialize:C}=(0,n.AU)(M,O,{marshalName:`captp:${e}`,errorIdNum:2e4}),_=new WeakMap,I=new Map,v=new WeakSet;let m=0,$=0,A=0;const R=new Map,b=new Map,D=new Map;function M(e){if(!_.has(e)){let t;if((0,a.tI)(e)){m+=1;const r=m;t=`p+${r}`,e.then((e=>P({type:"CTP_RESOLVE",promiseID:r,res:E(harden(e))})),(e=>P({type:"CTP_RESOLVE",promiseID:r,rej:E(harden(e))})))}else{$+=1;const r=$;t=v.has(e)?`t+${r}`:`o+${r}`}_.set(e,t),I.set(t,e)}const t=_.get(e);return assert.typeof(t,"string"),t}const L=()=>{A+=1;const t=`${e}#${A}`,r=N(t);R.set(t,r),m+=1;const n=`p+${m}`;return _.set(r.p,n),I.set(n,r.p),[t,r]},N=e=>{const t={get(t,r){if(!1!==f)return w(f);const[n,o]=L();return P({type:"CTP_CALL",epoch:l,questionID:n,target:e,method:E(harden([r]))}),harden(o.p)},applyFunction(t,r){if(!1!==f)return w(f);const[n,o]=L();return P({type:"CTP_CALL",epoch:l,questionID:n,target:e,method:E(harden([null,r]))}),harden(o.p)},applyMethod(t,r,n){if(!1!==f)return w(f);const[o,a]=L();return P({type:"CTP_CALL",epoch:l,questionID:o,target:e,method:E(harden([r,n]))}),harden(a.p)}},r={};return r.p=new o.T(((e,n,o)=>{r.rej=n,r.resPres=()=>o(t),r.res=e}),t),r.p.catch((e=>w(e,!1))),harden(r)};function O(t){let r,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0;const a="+"===t[1]?"-":"+",s=`${t[0]}${a}${t.slice(2)}`;if(!I.has(s)){const t=N(s);"o"===s[0]||"t"===s[0]?(void 0===o&&(o=`Alleged: Presence ${e} ${s}`),r=(0,n.Z7)(o,void 0,t.resPres())):(D.set(Number(s.slice(2)),t),r=t.p),I.set(s,r),_.set(r,s)}return I.get(s)}const k={async CTP_BOOTSTRAP(e){const{questionID:t}=e,n="function"===typeof r?r(e):r;o.E.when(n,(e=>(b.set(t,e),P({type:"CTP_RETURN",epoch:l,answerID:t,result:E(e)}))))},async CTP_CALL(e){const{questionID:t,target:r,trap:s}=e,[c,p]=C(e.method);let h;h=b.has(r)?b.get(r):C({body:JSON.stringify({[n.mn]:"slot",index:0}),slots:[r]});let d,T=(e,r)=>{P({type:"CTP_RETURN",epoch:l,answerID:t,[e?"exception":"result"]:E(harden(r))})};if(s){assert(v.has(h),i`Refused Trap(${h}) because target was not registered with makeTrapHandler`),assert.typeof(u,"function",i`CapTP cannot answer Trap(${h}) without a trapHost function`);const e=(0,a.gn)();y.set(t,e.promise),T=async(r,n)=>{const o=E(harden(n)),a=u([r,o]);a?(g.set(t,a),e.resolve({done:!1})):e.resolve({done:!0})}}d=p?null===c?o.T.applyFunction(h,p):o.T.applyMethod(h,c,p):o.T.get(h,c),b.set(t,d),await d.then((e=>T(!1,e)),(e=>T(!0,e)))},CTP_TRAP_ITERATE:async e=>{assert(u,i`CTP_TRAP_ITERATE is impossible without a trapHost`);const{questionID:t,serialized:r}=e,n=y.get(t);assert(n,i`CTP_TRAP_ITERATE did not expect ${t}`);const[o,a]=C(r),s=(async()=>{const e=await n,r=()=>(g.delete(t),y.delete(t),harden({done:!0}));try{if(!e||e.done)return r();const n=g.get(t);return n?await n[o](...a):r()}catch(s){throw r(),s||assert.fail(i`trapGuest expected trapHost AsyncIterator(${t}) to be done, but it wasn't`),assert.note(s,i`trapHost AsyncIterator(${t}) threw`),s}})();y.set(t,s),await s},async CTP_RETURN(e){const{result:t,exception:r,answerID:n}=e;if(!R.has(n))throw new Error(`Got an answer to a question we have not asked. (answerID = ${n} )`);const o=R.get(n);"exception"in e?o.rej(C(r)):o.res(C(t))},async CTP_RESOLVE(e){const{promiseID:t,res:r,rej:n}=e;if(!D.has(t))throw new Error(`Got a resolvement of a promise we have not imported. (promiseID = ${t} )`);const o=D.get(t);"rej"in e?o.rej(C(n)):o.res(C(r)),D.delete(t)},async CTP_DISCONNECT(r){const{reason:n=T(e)}=r;!1===f&&(w(r.reason,!1),f=n,t(r));for(const e of R.values())e.rej(n);for(const e of D.values())e.rej(n)}},x=async()=>{if(!1!==f)return w(f);const[e,t]=L();return P({type:"CTP_BOOTSTRAP",epoch:l,questionID:e}),harden(t.p)};harden(k);const S=e=>{try{if(!1!==f)return!1;const t=k[e.type];return!!t&&(t(e).catch((e=>w(e,!1))),!0)}catch(t){return w(t,!1),!1}},j=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:void 0;S({type:"CTP_DISCONNECT",epoch:l,reason:e})},q=(e,t)=>{const r=(0,n.cI)(e,t);return v.add(r),r},H={abort:j,dispatch:S,getBootstrap:x,serialize:E,unserialize:C,makeTrapHandler:q,Trap:void 0};if(d){assert.typeof(d,"function",i`opts.trapGuest must be a function`);const t=t=>function(r){assert(Promise.resolve(r)!==r,i`Trap(${r}) target cannot be a promise`);const n=_.get(r);assert(n&&"-"===n[1],i`Trap(${r}) target was not imported`),assert("t"===n[0],i`Trap(${r}) imported target was not created with makeTrapHandler`),A+=1;const o=`${e}#${A}`;let a;for(var s=arguments.length,c=new Array(s>1?s-1:0),h=1;h<s;h++)c[h-1]=arguments[h];switch(t){case"get":{const[e]=c;a=E(harden([e]));break}case"applyFunction":{const[e]=c;a=E(harden([null,e]));break}case"applyMethod":{const[e,t]=c;a=E(harden([e,t]));break}default:assert.fail(i`Internal error; unrecognized implMethod ${t}`)}const[u,T]=d({trapMethod:t,slot:n,trapArgs:c,startTrap:()=>{P({type:"CTP_CALL",epoch:l,trap:!0,questionID:o,target:n,method:a});const e=(e,t)=>function(){for(var r=arguments.length,n=new Array(r),a=0;a<r;a++)n[a]=arguments[a];return P({type:"CTP_TRAP_ITERATE",epoch:l,questionID:o,serialized:E(harden([e,n]))}),harden({done:t,value:void 0})};return harden({next:e("next",!1),return:e("return",!0),throw:e("throw",!0)})}}),y=C(T);if(assert(!p(y),i`Trap(${r}) reply cannot be a Thenable; have ${y}`),u)throw y;return y},r={applyFunction:t("applyFunction"),applyMethod:t("applyMethod"),get:t("get")};harden(r),H.Trap=c(r)}return harden(H)},{details:l}=assert;BigUint64Array.BYTES_PER_ELEMENT,Int32Array.BYTES_PER_ELEMENT}}]);
//# sourceMappingURL=770.c2760126.chunk.js.map