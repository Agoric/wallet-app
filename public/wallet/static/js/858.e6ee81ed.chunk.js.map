{"version":3,"file":"static/js/858.e6ee81ed.chunk.js","mappings":"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","sources":["../../../casting/src/defaults.js","../../../casting/src/shuffle.js","../../../casting/src/change-follower.js","../../../casting/src/leader-netconfig.js","../../../casting/src/leader.js","../../../casting/src/iterable.js","../../../casting/src/casting-spec.js","../../../casting/src/follower-cosmjs.js","../../../casting/src/follower.js","../../api/src/marshal-contexts.js","service/ScopedBridge.js","store/Dapps.js","service/Dapps.js","store/Offers.js","service/Offers.js","service/Issuers.js","util/WalletBackendAdapter.js","util/BridgeStorage.js","components/SmartWalletConnection.jsx"],"sourcesContent":["// @ts-check\n/* global setTimeout */\nimport { Far } from '@endo/far';\nimport { makeMarshal } from '@endo/marshal';\n\n/**\n * Default to the local chain.\n */\nexport const DEFAULT_BOOTSTRAP = 'http://localhost:26657';\n\nexport const DEFAULT_JITTER_SECONDS = 5;\n\nexport const DEFAULT_POLL_WITH_EVENTS_SECONDS = 600;\n\nexport const DEFAULT_KEEP_POLLING_SECONDS = 5;\n\n/**\n * Resolve a Promise after a given number of milliseconds.\n *\n * SECURITY: closes over setTimeout global\n *\n * @param {number} ms\n * @returns {Promise<void>}\n */\nexport const delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n/**\n * @param {number} range\n * @param {number} [cap]\n */\nexport const randomBackoff = (range, cap = range) => {\n  return Math.random() * Math.min(cap, range);\n};\n\n/**\n * @param {number} [attempt]\n * @param {number} [base]\n * @param {number} [cap]\n */\nexport const exponentialBackoff = (attempt = 0, base = 1_000, cap = 30_000) => {\n  return randomBackoff(2 ** attempt * base, cap);\n};\n\n/**\n * Add a little to the retry delay to avoid a thundering herd.\n *\n * @param {string} where\n * @returns {Promise<void>}\n */\nexport const DEFAULT_JITTER = where => {\n  const jitter = randomBackoff(DEFAULT_JITTER_SECONDS * 1_000);\n  console.warn(`jittering ${where} by ${Math.ceil(jitter)}ms`);\n  return delay(jitter);\n};\n\n/**\n * Report an error, then retry the leader operation after a second or two.\n *\n * @param {string} where\n * @param {any} err\n * @param {number} [attempt]\n * @returns {Promise<void>}\n */\nexport const DEFAULT_RETRY_CALLBACK = (where, err, attempt = 0) => {\n  const backoff = exponentialBackoff(attempt);\n  console.warn(\n    `retrying ${where} in ${Math.ceil(backoff)}ms after attempt #${attempt}`,\n    err,\n  );\n  return delay(backoff);\n};\n\n/**\n * Return true after we want to be sure we received latest state something.\n *\n * @returns {Promise<boolean>}\n */\nexport const DEFAULT_KEEP_POLLING = () =>\n  delay(randomBackoff(DEFAULT_KEEP_POLLING_SECONDS * 1_000)).then(() => true);\n\nexport const MAKE_DEFAULT_DECODER = () => {\n  /**\n   * Parse JSON.\n   *\n   * @param {string} str\n   */\n  return harden(str => {\n    try {\n      return harden(JSON.parse(str));\n    } catch (error) {\n      throw new Error(`Cannot decode alleged JSON (${error.message}): ${str}`);\n    }\n  });\n};\n\n/**\n * Unserialize the JSONable data.\n *\n * @type {() => import('./types').Unserializer}\n */\nexport const MAKE_DEFAULT_UNSERIALIZER = () => {\n  const ifaceAllegedPrefix = 'Alleged: ';\n  const ifaceInaccessiblePrefix = 'SEVERED: ';\n  const seen = new Map();\n  const slotToVal = (slot, iface) => {\n    // Private object.\n    if (seen.has(slot)) {\n      return seen.get(slot);\n    }\n    if (typeof iface === 'string' && iface.startsWith(ifaceAllegedPrefix)) {\n      iface = iface.slice(ifaceAllegedPrefix.length);\n    }\n    const obj = Far(`${ifaceInaccessiblePrefix}${iface}`, {});\n    seen.set(slot, obj);\n    return obj;\n  };\n  return Far('marshal unserializer', {\n    unserialize: makeMarshal(undefined, slotToVal).unserialize,\n  });\n};\n","// @ts-check\n\n/**\n * Modern version of Fisher-Yates shuffle algorithm (in-place).\n *\n * @template T\n * @param {Array<T>} a\n */\nexport const shuffle = a => {\n  for (let i = a.length - 1; i > 0; i -= 1) {\n    const j = Math.floor(Math.random() * (i + 1));\n    const x = a[i];\n    a[i] = a[j];\n    a[j] = x;\n  }\n};\n","// @ts-check\nimport { E, Far } from '@endo/far';\nimport { DEFAULT_KEEP_POLLING } from './defaults.js';\n\n/**\n * Just return an unspecified allegedValue every poll period.\n *\n * @param {import('./types').Leader} leader\n * @returns {Promise<import('./types.js').Follower<import('./types').CastingChange>>}\n */\nexport const makePollingChangeFollower = async leader => {\n  const { keepPolling = DEFAULT_KEEP_POLLING } = await E(leader).getOptions();\n\n  const iterable = Far('polling change follower iterable', {\n    [Symbol.asyncIterator]: () => {\n      /** @type {Promise<boolean> | undefined} */\n      let nextPollPromise;\n      return Far('polling change follower iterator', {\n        next: async () => {\n          if (!nextPollPromise) {\n            nextPollPromise = keepPolling('polling change follower').then(\n              cont => {\n                if (cont) {\n                  return E(leader)\n                    .jitter('polling change follower')\n                    .then(() => cont);\n                }\n                return cont;\n              },\n            );\n          }\n          const keepGoing = await nextPollPromise;\n          nextPollPromise = undefined;\n          const change = harden({\n            // Make no warrant as to the values.\n            values: [],\n          });\n          return harden({\n            value: change,\n            done: !keepGoing,\n          });\n        },\n      });\n    },\n  });\n\n  return Far('polling change follower', {\n    getLatestIterable: async () => iterable,\n    getEachIterable: async () => iterable,\n    getReverseIterable: async () => {\n      throw Error('not implemented for polling change follower');\n    },\n  });\n};\n","// @ts-check\n/* global fetch */\nimport { makeRoundRobinLeader } from './leader.js';\nimport {\n  DEFAULT_BOOTSTRAP,\n  DEFAULT_JITTER,\n  DEFAULT_RETRY_CALLBACK,\n} from './defaults.js';\n\nconst { details: X } = assert;\n\n/**\n * @param {string[]} rpcAddrs\n * @param {import('./types.js').LeaderOptions} [leaderOptions]\n * @returns {import('./types.js').Leader}\n */\nexport const makeLeaderFromRpcAddresses = (rpcAddrs, leaderOptions) => {\n  assert(Array.isArray(rpcAddrs), X`rpcAddrs ${rpcAddrs} must be an array`);\n\n  const rpcHrefs = rpcAddrs.map(rpcAddr => {\n    assert.typeof(rpcAddr, 'string', X`rpcAddr ${rpcAddr} must be a string`);\n    // Don't remove explicit port numbers from the URL, because the Cosmos\n    // `--node=xxx` flag requires them (it doesn't just assume that\n    // `--node=https://testnet.rpc.agoric.net` is the same as\n    // `--node=https://testnet.rpc.agoric.net:443`)\n    return rpcAddr.includes('://') ? rpcAddr : `http://${rpcAddr}`;\n  });\n\n  return makeRoundRobinLeader(rpcHrefs, leaderOptions);\n};\n\n/**\n * @param {string} netconfigURL\n * @param {import('./types.js').LeaderOptions} [options]\n */\nexport const makeLeaderFromNetworkConfig = (netconfigURL, options = {}) => {\n  const { retryCallback = DEFAULT_RETRY_CALLBACK, jitter = DEFAULT_JITTER } =\n    options;\n  /** @type {import('./types.js').LeaderOptions['retryCallback']} */\n  const retry = async (where, err, attempt) => {\n    if (retryCallback) {\n      return retryCallback(where, err, attempt);\n    }\n    throw err;\n  };\n  let attempt = 0;\n  const where = 'Network config leader';\n  return new Promise((resolve, reject) => {\n    const makeLeader = async () => {\n      const response = await fetch(netconfigURL, {\n        headers: { accept: 'application/json' },\n      });\n      const { rpcAddrs } = await response.json();\n      // Our part succeeded, so reset the attempt counter.\n      attempt = 0;\n      return makeLeaderFromRpcAddresses(rpcAddrs, options);\n    };\n    const retryLeader = async err => {\n      retry(where, err, attempt)\n        .then(() => jitter(where))\n        .then(() => makeLeader().then(resolve, retryLeader))\n        .catch(reject);\n      attempt += 1;\n    };\n    makeLeader().then(resolve, retryLeader);\n  });\n};\n\n/**\n * @param {string} [bootstrap]\n * @param {import('./types.js').LeaderOptions} [options]\n * @returns {ERef<import('./types.js').Leader>}\n */\nexport const makeLeader = (bootstrap = DEFAULT_BOOTSTRAP, options) => {\n  if (bootstrap.includes('network-config')) {\n    return makeLeaderFromNetworkConfig(bootstrap, options);\n  }\n  return makeLeaderFromRpcAddresses([bootstrap], options);\n};\n/** @typedef {ReturnType<typeof makeLeader>} Leader */\n","// @ts-check\nimport { E, Far } from '@endo/far';\nimport { DEFAULT_RETRY_CALLBACK, DEFAULT_JITTER } from './defaults.js';\nimport { shuffle } from './shuffle.js';\nimport { makePollingChangeFollower } from './change-follower.js';\n\n/**\n * Create a chain leader that rotates through a list of endpoints.\n *\n * @param {string[]} endpoints\n * @param {import('./types.js').LeaderOptions} leaderOptions\n */\nexport const makeRoundRobinLeader = (endpoints, leaderOptions = {}) => {\n  const { retryCallback = DEFAULT_RETRY_CALLBACK, jitter = DEFAULT_JITTER } =\n    leaderOptions;\n\n  // Shuffle the RPC addresses, so that we don't always hit the same one as all\n  // our peers.\n  shuffle(endpoints);\n\n  let lastRespondingEndpointIndex = 0;\n  let thisAttempt = 0;\n  let retrying;\n\n  /** @type {import('./types.js').Leader} */\n  const leader = Far('round robin leader', {\n    getOptions: () => leaderOptions,\n    jitter: async where => jitter && jitter(where),\n    retry: async (where, err, attempt) => {\n      if (retryCallback) {\n        return retryCallback(where, err, attempt);\n      }\n      throw err;\n    },\n    // eslint-disable-next-line no-use-before-define\n    watchCasting: _castingSpecP => pollingChangeFollower,\n    /**\n     * @template T\n     * @param {string} where\n     * @param {(endpoint: string) => Promise<T>} callback\n     */\n    mapEndpoints: async (where, callback) => {\n      where = `${where} (round-robin endpoints)`;\n      /** @type {Promise<T[]>} */\n      const p = new Promise((resolve, reject) => {\n        let endpointIndex = lastRespondingEndpointIndex;\n\n        const retry = err => {\n          if (!retrying) {\n            const attempt = thisAttempt;\n            retrying = E(leader)\n              .retry(where, err, attempt)\n              .then(() => {\n                endpointIndex = (endpointIndex + 1) % endpoints.length;\n                retrying = null;\n              });\n          }\n\n          retrying\n            .then(() => jitter && jitter(where))\n            // eslint-disable-next-line no-use-before-define\n            .then(applyOne, reject);\n          thisAttempt += 1;\n        };\n\n        const applyOne = () => {\n          Promise.resolve()\n            .then(() => callback(endpoints[endpointIndex]))\n            .then(res => {\n              resolve(harden([res]));\n              lastRespondingEndpointIndex = endpointIndex;\n              thisAttempt = 0;\n            }, retry);\n\n          // Don't return to prevent a promise chain.\n        };\n\n        applyOne();\n      });\n      return p;\n    },\n  });\n\n  const pollingChangeFollower = makePollingChangeFollower(leader);\n  return leader;\n};\n","// @ts-check\nimport { E, Far } from '@endo/far';\nimport { makeNotifier } from '@agoric/notifier';\n\n/**\n * @template T\n * @param {ERef<Notifier<T>>} notifier\n * @returns {ConsistentAsyncIterable<T>}\n */\nexport const makeNotifierIterable = notifier =>\n  makeNotifier(E(notifier).getSharableNotifierInternals());\n\n/**\n * TODO: Remove this function when we have `makePublisherKit`.\n *\n * @template T\n * @param {ERef<PublicationRecord<T>>} tailP\n * @returns {AsyncIterator<T>}\n */\nconst makeSubscriptionIterator = tailP => {\n  // To understand the implementation, start with\n  // https://web.archive.org/web/20160404122250/http://wiki.ecmascript.org/doku.php?id=strawman:concurrency#infinite_queue\n  return Far('SubscriptionIterator', {\n    next: async () => {\n      const resultP = E.get(tailP).head;\n      tailP = E.get(tailP).tail;\n      return resultP;\n    },\n  });\n};\n\n/**\n * TODO: Remove this function when we have `makePublisherKit`.\n *\n * @template T\n * @param {ERef<Subscription<T>>} subscription\n * @returns {ConsistentAsyncIterable<T>}\n */\nexport const makeSubscriptionIterable = subscription =>\n  harden({\n    [Symbol.asyncIterator]: () =>\n      makeSubscriptionIterator(\n        E(subscription).getSharableSubscriptionInternals(),\n      ),\n  });\n\n/**\n * @template TIn\n * @template TOut\n * @param {AsyncIterable<TIn>} iterable\n * @param {(value: TIn) => TOut} transform\n * @returns {AsyncIterable<TOut>}\n */\nexport const mapAsyncIterable = (iterable, transform) => {\n  async function* transformGenerator() {\n    for await (const value of iterable) {\n      yield transform(value);\n    }\n  }\n  return transformGenerator();\n};\n\n/**\n * TODO: Remove this function when we have `makePublisherKit`.\n *\n * @template T\n * @param {ERef<import('./types').Follower<T>>} follower\n */\nexport const iterateLatest = follower =>\n  // For now, just pass through the iterable.\n  Far('iterateLatest iterable', {\n    /** @returns {AsyncIterator<T>} */\n    [Symbol.asyncIterator]: () => {\n      const latestIterable = E(follower).getLatestIterable();\n      const iterator = E(latestIterable)[Symbol.asyncIterator]();\n      return Far('iterateLatest iterator', {\n        next: () => E(iterator).next(),\n      });\n    },\n  });\n\n/**\n * TODO: Remove this function when we have `makePublisherKit`.\n *\n * @template T\n * @param {ERef<import('./types.js').Follower<T>>} follower\n * @param {import('./types.js').IterateEachOptions} [options]\n */\nexport const iterateEach = (follower, options) =>\n  // For now, just pass through the iterable.\n  Far('iterateEach iterable', {\n    /** @returns {AsyncIterator<T>} */\n    [Symbol.asyncIterator]: () => {\n      const eachIterable = E(follower).getEachIterable(options);\n      const iterator = E(eachIterable)[Symbol.asyncIterator]();\n      return Far('iterateEach iterator', {\n        next: () => E(iterator).next(),\n      });\n    },\n  });\n\n/**\n * @template T\n * @param {ERef<import('./types.js').Follower<T>>} follower\n * @param {import('./types.js').IterateEachOptions} [options]\n */\nexport const iterateReverse = (follower, options) =>\n  // For now, just pass through the iterable.\n  Far('iterateReverse iterable', {\n    /** @returns {AsyncIterator<T>} */\n    [Symbol.asyncIterator]: () => {\n      const eachIterable = E(follower).getReverseIterable(options);\n      const iterator = E(eachIterable)[Symbol.asyncIterator]();\n      return Far('iterateEach iterator', {\n        next: () => E(iterator).next(),\n      });\n    },\n  });\n","// @ts-check\nimport * as encodingStar from '@cosmjs/encoding';\nimport { E, getInterfaceOf } from '@endo/far';\n\nimport './types.js';\n\nconst { toAscii } = encodingStar;\n\n/**\n * @param {string} storagePath\n * @returns {import('./types').CastingSpec}\n */\nconst swingsetPathToCastingSpec = storagePath =>\n  harden({\n    storeName: 'swingset',\n    storeSubkey: toAscii(`swingset/data:${storagePath}`),\n  });\n\nconst PATH_SEPARATOR_BYTE = '.'.charCodeAt(0);\nconst DATA_PREFIX_BYTES = new Uint8Array([0]);\n\n/**\n * @param {string} storagePath\n * @param {string} [storeName]\n * @returns {import('./types').CastingSpec}\n */\nconst vstoragePathToCastingSpec = (storagePath, storeName = 'vstorage') => {\n  const elems = storagePath ? storagePath.split('.') : [];\n  const buf = toAscii(`${elems.length}.${storagePath}`);\n  return harden({\n    storeName,\n    storeSubkey: buf.map(b => (b === PATH_SEPARATOR_BYTE ? 0 : b)),\n    dataPrefixBytes: DATA_PREFIX_BYTES,\n  });\n};\n\nexport const DEFAULT_PATH_CONVERTER = vstoragePathToCastingSpec;\n\n/**\n * @type {Record<string, (path: string) => import('./types').CastingSpec>}\n */\nexport const pathPrefixToConverters = harden({\n  'swingset:': swingsetPathToCastingSpec,\n  'vstore:': vstoragePathToCastingSpec,\n  ':': DEFAULT_PATH_CONVERTER,\n});\n\n/**\n * @param {string} specString\n * @returns {import('./types').CastingSpec}\n */\nexport const makeCastingSpecFromString = specString => {\n  assert.typeof(specString, 'string');\n  const match = specString.match(/^([^:.]*:)(.*)/);\n  assert(\n    match,\n    `spec string ${specString} does not match 'PREFIX:PATH' or ':PATH'`,\n  );\n  const kind = match[1];\n  const storePath = match[2];\n  const converter = pathPrefixToConverters[kind];\n  assert(converter, `Unknown pathKind ${kind}`);\n  return converter(storePath);\n};\n\nconst te = new TextEncoder();\n\n/**\n * @param {any} specObj\n * @returns {import('./types').CastingSpec}\n */\nexport const makeCastingSpecFromObject = specObj => {\n  const { storeName, storeSubkey, dataPrefixBytes, subscription, notifier } =\n    specObj;\n  if (subscription || notifier) {\n    return harden({\n      subscription,\n      notifier,\n    });\n  }\n  let subkey = storeSubkey;\n  if (typeof storeSubkey === 'string') {\n    subkey = te.encode(storeSubkey);\n  }\n  let dataPrefix = dataPrefixBytes;\n  if (typeof dataPrefixBytes === 'string') {\n    dataPrefix = te.encode(dataPrefixBytes);\n  }\n  return harden({\n    storeName,\n    storeSubkey: subkey,\n    dataPrefixBytes: dataPrefix,\n  });\n};\n\n/**\n * @param {ERef<any>} specCap\n * @returns {Promise<import('./types').CastingSpec>}\n */\nexport const makeCastingSpecFromRef = async specCap => {\n  const specObj = await E(specCap).getStoreKey();\n  return makeCastingSpecFromObject(specObj);\n};\n\n/**\n * Create an abstract type from a given source representation\n *\n * @param {ERef<unknown>} sourceP\n * @returns {Promise<import('./types').CastingSpec>}\n */\nexport const makeCastingSpec = async sourceP => {\n  const spec = await sourceP;\n  if (typeof spec === 'string') {\n    return makeCastingSpecFromString(spec);\n  }\n  // @ts-expect-error type detection\n  const { storeName, subscription, notifier } = spec;\n  if (storeName || subscription || notifier) {\n    return makeCastingSpecFromObject(spec);\n  }\n  if (getInterfaceOf(spec)) {\n    return makeCastingSpecFromRef(spec);\n  }\n  assert.fail(`CastingSpec ${spec} is not a string, object, or ref`);\n};\n/** @typedef {ReturnType<typeof makeCastingSpec>} CastingSpec */\n","// @ts-check\n/// <reference types=\"ses\"/>\n/* eslint-disable no-await-in-loop, no-continue, @jessie.js/no-nested-await */\n\nimport { E, Far } from '@endo/far';\nimport * as tendermintRpcStar from '@cosmjs/tendermint-rpc';\nimport * as stargateStar from '@cosmjs/stargate';\n\nimport { MAKE_DEFAULT_DECODER, MAKE_DEFAULT_UNSERIALIZER } from './defaults.js';\nimport { makeCastingSpec } from './casting-spec.js';\nimport { makeLeader as defaultMakeLeader } from './leader-netconfig.js';\n\nconst { QueryClient } = stargateStar;\nconst { Tendermint34Client } = tendermintRpcStar;\nconst { details: X, quote: q } = assert;\nconst textDecoder = new TextDecoder();\n\n/** @template T @typedef {import('./types.js').StreamCell<T>} StreamCell */\n/** @template T @typedef {import('./types.js').FollowerElement<T>} FollowerElement */\n/** @template T @typedef {import('./types.js').Follower<T>} Follower */\n\n/**\n * This is an imperfect heuristic to navigate the migration from value cells to\n * stream cells.\n * At time of writing, no legacy cells have the same shape as a stream cell,\n * and we do not intend to create any more legacy value cells.\n *\n * @param {any} cell\n */\nconst isStreamCell = cell =>\n  cell &&\n  typeof cell === 'object' &&\n  Array.isArray(cell.values) &&\n  typeof cell.blockHeight === 'string' &&\n  /^0$|^[1-9][0-9]*$/.test(cell.blockHeight);\n\n/**\n * @param {Uint8Array} a\n * @param {Uint8Array} b\n */\nconst arrayEqual = (a, b) => {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i += 1) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst defaultDataPrefixBytes = new Uint8Array();\n\n/**\n * @template T\n * @param {Iterable<T>} values\n * @returns {T}\n */\nconst collectSingle = values => {\n  /** @type {T[]} */\n  const head = [];\n  let count = 0;\n  for (const value of values) {\n    count += 1;\n    if (count === 1) {\n      head.push(value);\n    } else {\n      assert.fail(`expected single value, got at least ${count}`);\n    }\n  }\n\n  assert.equal(head.length, 1, 'expected single value');\n  return head[0];\n};\n\n// Coordinate with switch/case of tryGetDataAtHeight.\nconst proofs = ['strict', 'none', 'optimistic'];\n\n/**\n * @template T\n * @param {any} sourceP\n * @param {import('./types').LeaderOrMaker} [leaderOrMaker]\n * @param {import('./types').FollowerOptions} [options]\n * @returns {Follower<FollowerElement<T>>}\n */\nexport const makeCosmjsFollower = (\n  sourceP,\n  leaderOrMaker = defaultMakeLeader,\n  options = {},\n) => {\n  const {\n    decode = MAKE_DEFAULT_DECODER(),\n    unserializer = MAKE_DEFAULT_UNSERIALIZER(),\n    proof = 'optimistic',\n    crasher = null,\n  } = options;\n\n  /**\n   * @param {any} err\n   */\n  const crash = err => {\n    if (crasher) {\n      E(crasher)\n        .crash(`PROOF VERIFICATION FAILURE; crashing follower`, err)\n        .catch(e => assert.fail(X`crashing follower failed: ${e}`));\n    }\n    throw err;\n  };\n\n  assert(proofs.includes(proof), X`unrecognized follower proof mode ${proof}`);\n\n  const where = 'CosmJS follower';\n  const castingSpecP = makeCastingSpec(sourceP);\n\n  const leader =\n    typeof leaderOrMaker === 'function' ? leaderOrMaker() : leaderOrMaker;\n\n  const tendermintClientPs = new Map();\n  /**\n   * @param {string} endpoint\n   */\n  const provideTendermintClient = endpoint => {\n    let clientP = tendermintClientPs.get(endpoint);\n    if (!clientP) {\n      clientP = Tendermint34Client.connect(endpoint);\n      tendermintClientPs.set(endpoint, clientP);\n    }\n    return clientP;\n  };\n\n  const getBlockHeight = async () => {\n    const values = await E(leader).mapEndpoints(where, async endpoint => {\n      const client = await provideTendermintClient(endpoint);\n      const info = await client.abciInfo();\n      const { lastBlockHeight } = info;\n      assert.typeof(lastBlockHeight, 'number');\n      return lastBlockHeight;\n    });\n    return collectSingle(values);\n  };\n\n  /** @type {Map<string, import('@cosmjs/stargate').QueryClient>} */\n  const endpointToQueryClient = new Map();\n\n  /**\n   * @param {string} endpoint\n   */\n  const provideQueryClient = async endpoint => {\n    if (endpointToQueryClient.has(endpoint)) {\n      // Cache hit.\n      const queryClient = endpointToQueryClient.get(endpoint);\n      assert(queryClient);\n      return queryClient;\n    }\n    // Create a new client.  They retry automatically.\n    const rpcClient = await provideTendermintClient(endpoint);\n    const queryClient = QueryClient.withExtensions(rpcClient);\n    endpointToQueryClient.set(endpoint, queryClient);\n    return queryClient;\n  };\n\n  /**\n   * @param {(endpoint: string, storeName: string, storeSubkey: Uint8Array) => Promise<Uint8Array>} tryGetPrefixedData\n   */\n  const retryGetDataAndStripPrefix = async tryGetPrefixedData => {\n    const {\n      storeName,\n      storeSubkey,\n      dataPrefixBytes = defaultDataPrefixBytes,\n    } = await castingSpecP;\n\n    assert.typeof(\n      storeName,\n      'string',\n      X`storeName must be a string, got ${storeName}`,\n    );\n    assert(\n      storeSubkey,\n      X`storeSubkey must be a Uint8Array, got ${storeSubkey}`,\n    );\n\n    // mapEndpoints is our retry loop.\n    const values = await E(leader).mapEndpoints(where, async endpoint =>\n      tryGetPrefixedData(endpoint, storeName, storeSubkey).then(\n        result => {\n          return { result, error: null };\n        },\n        error => {\n          return { result: null, error };\n        },\n      ),\n    );\n\n    const { result, error } = collectSingle(values);\n    if (error !== null) {\n      throw error;\n    }\n    assert(result);\n\n    if (result.length === 0) {\n      // No data.\n      return result;\n    }\n\n    // Handle the data prefix if any.\n    assert(\n      result.length >= dataPrefixBytes.length,\n      X`result too short for data prefix ${dataPrefixBytes}`,\n    );\n    assert(\n      arrayEqual(result.subarray(0, dataPrefixBytes.length), dataPrefixBytes),\n      X`${result} doesn't start with data prefix ${dataPrefixBytes}`,\n    );\n    return result.slice(dataPrefixBytes.length);\n  };\n\n  /**\n   * @param {number} [height]\n   * @returns {Promise<Uint8Array>}\n   */\n  const getProvenDataAtHeight = async height => {\n    return retryGetDataAndStripPrefix(\n      async (endpoint, storeName, storeSubkey) => {\n        const queryClient = await provideQueryClient(endpoint);\n        return E(queryClient).queryVerified(storeName, storeSubkey, height);\n      },\n    );\n  };\n\n  /**\n   * @param {number} height\n   */\n  const getUnprovenDataAtHeight = async height => {\n    return retryGetDataAndStripPrefix(\n      async (endpoint, storeName, storeSubkey) => {\n        const client = await provideTendermintClient(endpoint);\n        const response = await client.abciQuery({\n          path: `store/${storeName}/key`,\n          data: storeSubkey,\n          height,\n          prove: false,\n        });\n        if (response.code !== 0) {\n          throw new Error(`Tendermint ABCI query failed: ${response.log}`);\n        }\n        const { value } = response;\n        return value;\n      },\n    );\n  };\n\n  /**\n   * @param {number} blockHeight\n   */\n  const tryGetDataAtHeight = async blockHeight => {\n    if (proof === 'strict') {\n      // Crash hard if we can't prove.\n      return getProvenDataAtHeight(blockHeight).catch(crash);\n    } else if (proof === 'none') {\n      // Fast and loose.\n      return getUnprovenDataAtHeight(blockHeight);\n    } else if (proof === 'optimistic') {\n      const allegedData = await getUnprovenDataAtHeight(blockHeight);\n\n      // Prove later, since it may take time we say we can't afford.\n      getProvenDataAtHeight(blockHeight).then(provenData => {\n        if (arrayEqual(provenData, allegedData)) {\n          return;\n        }\n        crash(\n          assert.error(\n            X`Alleged value ${allegedData} did not match proof ${provenData}`,\n          ),\n        );\n      }, crash);\n\n      // Speculate that we got the right value.\n      return allegedData;\n    }\n\n    assert.fail(\n      X`Unrecognized proof option ${q(\n        proof,\n      )}, must be one of strict, none, or optimistic`,\n    );\n  };\n\n  /**\n   * @param {number} blockHeight\n   */\n  const getDataAtHeight = async blockHeight => {\n    for (let attempt = 0; ; attempt += 1) {\n      try {\n        // AWAIT\n        return await tryGetDataAtHeight(blockHeight);\n      } catch (error) {\n        // We expect occasionally to see an error here if the chain has not\n        // reached the requested blockHeight.\n        await E(leader).retry(where, error, attempt);\n        continue;\n      }\n    }\n  };\n\n  /**\n   * @param {number} blockHeight\n   * @param {Uint8Array} data\n   */\n  const streamCellForData = (blockHeight, data) => {\n    const text = textDecoder.decode(data);\n    try {\n      const cell = JSON.parse(text);\n      if (isStreamCell(cell)) {\n        return harden({\n          blockHeight: Number(cell.blockHeight),\n          values: cell.values.map(decode),\n        });\n      }\n\n      // This is JSON but not the shape of a stream cell.\n      // Fall through...\n    } catch {\n      // This is not even JSON, so it must be a legacy value cell.\n      // Fall through...\n    }\n\n    // Coerce legacy value cells to stream cells at their given height.\n    // Since this is either the first iteration or the data varies bytewise\n    // from the data on the previous block, we can assume the blockHeight is\n    // the current block.\n    return harden({\n      blockHeight,\n      values: [decode(text)],\n    });\n  };\n\n  /**\n   * @param {any} data\n   * @param {number} blockHeight\n   * @param {number} currentBlockHeight\n   * @returns {Promise<FollowerElement<T>>}\n   */\n  const followerElementFromStreamCellValue = async (\n    data,\n    blockHeight,\n    currentBlockHeight,\n  ) => {\n    // AWAIT\n    const value = await /** @type {T} */ (\n      unserializer ? E(unserializer).unserialize(data) : data\n    );\n    return { value, blockHeight, currentBlockHeight };\n  };\n\n  /**\n   * @param {StreamCell<T>} streamCell\n   * @param {number} currentBlockHeight\n   * @yields {FollowerElement<T>}\n   */\n  function* allValuesFromCell(streamCell, currentBlockHeight) {\n    for (const data of streamCell.values) {\n      yield followerElementFromStreamCellValue(\n        data,\n        streamCell.blockHeight,\n        currentBlockHeight,\n      );\n    }\n  }\n\n  /**\n   * @param {StreamCell<T>} streamCell\n   * @param {number} currentBlockHeight\n   * @yields {FollowerElement<T>}\n   */\n  function* reverseValuesFromCell(streamCell, currentBlockHeight) {\n    for (let i = streamCell.values.length - 1; i >= 0; i -= 1) {\n      yield followerElementFromStreamCellValue(\n        streamCell.values[i],\n        streamCell.blockHeight,\n        currentBlockHeight,\n      );\n    }\n  }\n\n  /**\n   * @param {StreamCell<T>} streamCell\n   * @param {number} currentBlockHeight\n   * @yields {FollowerElement<T>}\n   */\n  function* lastValueFromCell(streamCell, currentBlockHeight) {\n    const { values } = streamCell;\n    if (values.length > 0) {\n      const last = values[values.length - 1];\n      yield followerElementFromStreamCellValue(\n        last,\n        streamCell.blockHeight,\n        currentBlockHeight,\n      );\n    }\n  }\n\n  /**\n   * @yields {FollowerElement<T>}\n   */\n  async function* getLatestIterable() {\n    let blockHeight;\n    let data;\n    for (;;) {\n      const currentBlockHeight = await getBlockHeight();\n      if (currentBlockHeight === blockHeight) {\n        // TODO Long-poll for next block\n        // https://github.com/Agoric/agoric-sdk/issues/6154\n        await E(leader).jitter(where);\n        continue;\n      }\n\n      const currentData = await getDataAtHeight(currentBlockHeight);\n      if (currentData.length === 0) {\n        // TODO Long-poll for block data change\n        // https://github.com/Agoric/agoric-sdk/issues/6154\n        await E(leader).jitter(where);\n        continue;\n      }\n      const currentStreamCell = streamCellForData(\n        currentBlockHeight,\n        currentData,\n      );\n\n      blockHeight = currentBlockHeight;\n\n      // Ignore adjacent duplicates.\n      // This can only occur for legacy cells.\n      // It is possible that the data changed from and back to the last\n      // sampled data, but ignoring intermediate changes is consistent with\n      // the semantics of getLatestIterable.\n      if (data !== undefined && arrayEqual(data, currentData)) {\n        continue;\n      }\n      // However, streamCells that vacillate will reemit, since each iteration\n      // at a unique block height is considered distinct.\n\n      yield* lastValueFromCell(currentStreamCell, currentBlockHeight);\n      data = currentData;\n    }\n  }\n\n  /**\n   * @param {number} cursorBlockHeight\n   * @yields {FollowerElement<T>}\n   */\n  async function* getEachIterableAtHeight(cursorBlockHeight) {\n    // Track the data for the last emitted cell (the cell at the\n    // cursorBlockHeight) so we know not to emit duplicates\n    // of that cell.\n    let cursorData;\n    // Initially yield *all* the values that were most recently stored in a\n    // block.\n    // If the block has no corresponding data, wait for the first block to\n    // contain data.\n    for (;;) {\n      cursorData = await getDataAtHeight(cursorBlockHeight);\n      if (cursorData.length !== 0) {\n        const cursorStreamCell = streamCellForData(\n          cursorBlockHeight,\n          cursorData,\n        );\n        yield* allValuesFromCell(cursorStreamCell, cursorBlockHeight);\n        break;\n      }\n      // TODO Long-poll for next block\n      // https://github.com/Agoric/agoric-sdk/issues/6154\n      await E(leader).jitter(where);\n      cursorBlockHeight = await getBlockHeight();\n    }\n\n    // For each subsequent iteration, yield every value that has been\n    // published since the last iteration and advance the cursor.\n    for (;;) {\n      const currentBlockHeight = await getBlockHeight();\n      // Wait until the chain has added at least one block.\n      if (currentBlockHeight <= cursorBlockHeight) {\n        // TODO Long-poll for next block\n        // https://github.com/Agoric/agoric-sdk/issues/6154\n        await E(leader).jitter(where);\n        continue;\n      }\n\n      // Scan backward for all changes since the last observed block and yield\n      // them in forward order.\n      // Stream cells allow us to skip blocks that did not change.\n      // We walk backward through all blocks with legacy cells, only yielding\n      // the value for cells that changed.\n      // This does imply accumulating a potentially large number of values if\n      // the eachIterable gets sampled infrequently.\n      let rightBlockHeight = currentBlockHeight;\n      let rightData = await getDataAtHeight(rightBlockHeight);\n      if (rightData.length === 0) {\n        // TODO Long-poll for next block\n        // https://github.com/Agoric/agoric-sdk/issues/6154\n        await E(leader).jitter(where);\n        continue;\n      }\n      let rightStreamCell = streamCellForData(rightBlockHeight, rightData);\n\n      // Compare block cell data pairwise (left, right) and accumulate\n      // a stack of each cell we encounter.\n      const currentData = rightData;\n      const cells = [];\n      while (rightBlockHeight > cursorBlockHeight) {\n        if (rightStreamCell.blockHeight > rightBlockHeight) {\n          const { storeName, storeSubkey } = await castingSpecP;\n          throw new Error(\n            `Corrupt storage cell for ${storeName} under key ${storeSubkey} at block-height ${rightBlockHeight} claims to being published at a later block height ${rightStreamCell.blockHeight}`,\n          );\n        }\n        const leftBlockHeight = rightStreamCell.blockHeight - 1;\n        // Do not scan behind the cusor.\n        if (leftBlockHeight <= cursorBlockHeight) {\n          break;\n        }\n        const leftData = await getDataAtHeight(leftBlockHeight);\n        // Do not scan behind a cell with no data.\n        // This should not happen but can be tolerated.\n        if (leftData.length === 0) {\n          break;\n        }\n        const leftStreamCell = streamCellForData(leftBlockHeight, leftData);\n\n        // Stream cells include a block height that is guaranteed to change\n        // between iterations even if the values are identical.\n        // We can rely on this difference to ensure that we yield\n        // every iteration, including duplicates.\n        // Legacy cells do not contain a block height to distingish versions,\n        // so we simply assume that the value must change between iterations\n        // for a cell to be worthy of notice.\n        if (!arrayEqual(leftData, rightData)) {\n          cells.push(rightStreamCell);\n        }\n\n        // Prepare for next iteration by moving left to right.\n        rightData = leftData;\n        rightStreamCell = leftStreamCell;\n        rightBlockHeight = leftBlockHeight;\n      }\n\n      // At the end of a sequence of identical value cells, we emit the value\n      // only if it differs from the last reported cell.\n      if (!arrayEqual(rightData, cursorData)) {\n        cells.push(rightStreamCell);\n      }\n\n      // Yield collected cells in forward order.\n      // They were collected by scanning blocks backward.\n      for (;;) {\n        const cell = cells.pop();\n        if (cell === undefined) {\n          break;\n        }\n        yield* allValuesFromCell(cell, currentBlockHeight);\n      }\n\n      // Advance the cursor.\n      cursorBlockHeight = currentBlockHeight;\n      cursorData = currentData;\n    }\n  }\n\n  /**\n   * @param {number} cursorBlockHeight\n   * @yields {FollowerElement<T>}\n   */\n  async function* getReverseIterableAtHeight(cursorBlockHeight) {\n    // Track the data for the last emitted cell (the cell at the\n    // cursorBlockHeight) so we know not to emit duplicates\n    // of that cell.\n    let cursorData;\n    while (cursorBlockHeight > 0) {\n      cursorData = await getDataAtHeight(cursorBlockHeight);\n      if (cursorData.length === 0) {\n        // No data at the cursor height, so signal beginning of stream.\n        return;\n      }\n      const cursorStreamCell = streamCellForData(cursorBlockHeight, cursorData);\n      yield* reverseValuesFromCell(cursorStreamCell, cursorBlockHeight);\n      cursorBlockHeight = cursorStreamCell.blockHeight - 1;\n    }\n  }\n\n  /** @type {Follower<FollowerElement<T>>} */\n  return Far('chain follower', {\n    async getLatestIterable() {\n      return getLatestIterable();\n    },\n    async getEachIterable({ height = undefined } = {}) {\n      if (height === undefined) {\n        height = await getBlockHeight();\n      }\n      return getEachIterableAtHeight(height);\n    },\n    async getReverseIterable({ height = undefined } = {}) {\n      if (height === undefined) {\n        height = await getBlockHeight();\n      }\n      return getReverseIterableAtHeight(height);\n    },\n  });\n};\n","// @ts-check\n\nimport { Far } from '@endo/far';\nimport {\n  mapAsyncIterable,\n  makeNotifierIterable,\n  makeSubscriptionIterable,\n} from './iterable.js';\nimport { makeCosmjsFollower } from './follower-cosmjs.js';\nimport { makeCastingSpec } from './casting-spec.js';\n\n/**\n * @template T\n * @param {ERef<import('./types').CastingSpec>} spec\n */\nconst makeSubscriptionFollower = spec => {\n  const transform = value =>\n    harden({ value, blockHeight: NaN, currentBlockHeight: NaN });\n  /** @type {import('./types').Follower<import('./types.js').FollowerElement<T>>} */\n  const follower = Far('subscription/notifier follower', {\n    getLatestIterable: async () => {\n      const { notifier, subscription } = await spec;\n      let ai;\n      if (notifier) {\n        ai = makeNotifierIterable(notifier);\n      } else {\n        assert(subscription);\n        ai = makeSubscriptionIterable(subscription);\n      }\n      return mapAsyncIterable(ai, transform);\n    },\n\n    getEachIterable: async () => {\n      const { notifier, subscription } = await spec;\n      let ai;\n      if (subscription) {\n        ai = makeSubscriptionIterable(subscription);\n      } else {\n        assert(notifier);\n        ai = makeNotifierIterable(notifier);\n      }\n      return mapAsyncIterable(ai, transform);\n    },\n\n    getReverseIterable: async () => {\n      throw Error(\n        'reverse iteration not implemented for subscription follower',\n      );\n    },\n  });\n  return follower;\n};\n\n/**\n * @template T\n * @param {ERef<import('./types').CastingSpec> | string} specP\n * @param {import('./types').LeaderOrMaker} [leaderOrMaker]\n * @param {import('./types').FollowerOptions} [options]\n * @returns {Promise<import('./types').Follower<import('./types').FollowerElement<T>>>}\n */\nexport const makeFollower = async (specP, leaderOrMaker, options) => {\n  const spec = await makeCastingSpec(specP);\n  const { storeName } = spec;\n  if (storeName) {\n    return makeCosmjsFollower(spec, leaderOrMaker, options);\n  }\n  return makeSubscriptionFollower(spec);\n};\n","// @ts-check\nimport { makeScalarMap } from '@agoric/store';\nimport { Far, makeMarshal, Remotable } from '@endo/marshal';\nimport { HandledPromise } from '@endo/eventual-send'; // TODO: convince tsc this isn't needed\n\nconst { details: X, quote: q } = assert;\n\n/**\n * For a value with a known id in the board, we can use\n * that board id as a slot to preserve identity when marshaling.\n *\n * @typedef {`board${Digits}`} BoardId\n */\n\n/**\n * @param {unknown} specimen\n * @returns {specimen is BoardId}\n */\nconst isBoardId = specimen => {\n  return typeof specimen === 'string' && !!specimen.match(/^board[^:]/);\n};\n\n/**\n * When marshaling a purse, payment, etc. we partition the slots\n * using prefixes.\n *\n * @template {Record<string, IdTable<*,*>>} T\n * @typedef {`${string & keyof T}:${Digits}`} WalletSlot<T>\n */\n/**\n * @template {string} K\n * @typedef {`${K}:${Digits}`} KindSlot<K>\n */\n\n/**\n * @template {Record<string, IdTable<*,*>>} T\n * @param {T} _tables\n * @param {string & keyof T} kind\n * @param {number} id\n * @returns {WalletSlot<T>}\n */\nconst makeWalletSlot = (_tables, kind, id) => {\n  const digits = /** @type {Digits} */ (`${id}`);\n  return `${kind}:${digits}`;\n};\n\n/**\n * @template {Record<string, IdTable<*,*>>} T\n * @param {T} record\n * @param {(value: string, index: number, obj: string[]) => boolean} predicate\n * @returns {string & keyof T | undefined}\n */\nconst findKey = (record, predicate) => {\n  const key = Object.keys(record).find(predicate);\n  return key;\n};\n\n/**\n * @template {Record<string, IdTable<*,*>>} T\n * @param {T} tables\n * @param {string} slot\n * @returns {{ kind: undefined | string & keyof T, id: number }}\n */\nconst parseWalletSlot = (tables, slot) => {\n  const kind = findKey(tables, k => slot.startsWith(`${k}:`));\n  const id = kind ? Number(slot.slice(kind.length + 1)) : NaN;\n  return { kind, id };\n};\n\n/**\n * Since KindSlots always include a colon and BoardIds never do,\n * we an mix them without confusion.\n *\n * @template {Record<string, IdTable<*,*>>} T\n * @typedef {WalletSlot<T> | BoardId} MixedSlot<T>\n */\n/**\n * @typedef {`1` | `12` | `123`} Digits - 1 or more digits.\n * NOTE: the typescript definition here is more restrictive than\n * actual usage.\n */\n\n/**\n * @template Slot\n * @template Val\n *\n * @typedef {{\n *   bySlot: MapStore<Slot, Val>,\n *   byVal: MapStore<Val, Slot>,\n * }} IdTable<Value>\n */\n\n/**\n * @template Slot\n * @template Val\n * @param {IdTable<Slot, Val>} table\n * @param {Slot} slot\n * @param {Val} val\n */\nconst initSlotVal = (table, slot, val) => {\n  table.bySlot.init(slot, val);\n  table.byVal.init(val, slot);\n};\n\n/**\n * Make context for exporting wallet data where brands etc. can be recognized by boardId.\n * Export for use outside the smart wallet.\n *\n * When serializing wallet state for, there's a tension between\n *\n *  - keeping purses etc. closely held\n *  - recognizing identity of brands also referenced in the state of contracts such as the AMM\n *\n * `makeMarshal()` is parameterized by the type of slots. Here we use a disjoint union of\n *   - board ids for widely shared objects\n *   - kind:seq ids for closely held objects; for example purse:123\n */\nexport const makeExportContext = () => {\n  const walletObjects = {\n    /** @type {IdTable<number, Purse>} */\n    purse: {\n      bySlot: makeScalarMap(),\n      byVal: makeScalarMap(),\n    },\n    /** @type {IdTable<number, Payment>} */\n    payment: {\n      bySlot: makeScalarMap(),\n      byVal: makeScalarMap(),\n    },\n    // TODO: offer, contact, dapp\n    /** @type {IdTable<number, unknown>} */\n    unknown: {\n      bySlot: makeScalarMap(),\n      byVal: makeScalarMap(),\n    },\n  };\n  /** @type {IdTable<BoardId, unknown>} */\n  const boardObjects = {\n    bySlot: makeScalarMap(),\n    byVal: makeScalarMap(),\n  };\n\n  /**\n   * Look up the slot in mappings from published data\n   * else try walletObjects that we have seen.\n   *\n   * @throws if not found (a slotToVal function typically\n   *         conjures a new identity)\n   *\n   * @param {MixedSlot<typeof walletObjects>} slot\n   * @param {string} _iface\n   */\n  const slotToVal = (slot, _iface) => {\n    if (isBoardId(slot) && boardObjects.bySlot.has(slot)) {\n      return boardObjects.bySlot.get(slot);\n    }\n    const { kind, id } = parseWalletSlot(walletObjects, slot);\n    assert(kind, X`bad slot kind: ${slot}`);\n    const val = walletObjects[kind].bySlot.get(id); // or throw\n    return val;\n  };\n\n  let unknownNonce = 0;\n\n  /**\n   * @param {unknown} val\n   * @returns {MixedSlot<typeof walletObjects>}\n   */\n  const valToSlot = val => {\n    if (boardObjects.byVal.has(val)) {\n      return boardObjects.byVal.get(val);\n    }\n    const kind = findKey(walletObjects, k => walletObjects[k].byVal.has(val));\n    if (kind) {\n      // @ts-expect-error has(val) above ensures val has the right type\n      const id = walletObjects[kind].byVal.get(val);\n      return makeWalletSlot(walletObjects, kind, id);\n    }\n    unknownNonce += 1;\n    const slot = makeWalletSlot(walletObjects, 'unknown', unknownNonce);\n    initSlotVal(walletObjects.unknown, unknownNonce, val);\n    return slot;\n  };\n\n  /**\n   * @template V\n   * @param {string & keyof typeof walletObjects} kind\n   * @param {IdTable<number, V>} table\n   */\n  const makeSaver = (kind, table) => {\n    let nonce = 0;\n    /** @param {V} val */\n    const saver = val => {\n      nonce += 1;\n      initSlotVal(table, nonce, val);\n    };\n    return saver;\n  };\n\n  return harden({\n    savePurseActions: makeSaver('purse', walletObjects.purse),\n    savePaymentActions: makeSaver('payment', walletObjects.payment),\n    /**\n     * @param {number} id\n     * @param {Purse} purse\n     */\n    initPurseId: (id, purse) => {\n      initSlotVal(walletObjects.purse, id, purse);\n    },\n    purseEntries: walletObjects.purse.bySlot.entries,\n    /**\n     * @param {BoardId} id\n     * @param {unknown} val\n     */\n    initBoardId: (id, val) => {\n      initSlotVal(boardObjects, id, val);\n    },\n    /**\n     * @param {BoardId} id\n     * @param {unknown} val\n     */\n    ensureBoardId: (id, val) => {\n      if (boardObjects.byVal.has(val)) {\n        assert.equal(boardObjects.byVal.get(val), id);\n        return;\n      }\n      initSlotVal(boardObjects, id, val);\n    },\n    ...makeMarshal(valToSlot, slotToVal),\n  });\n};\n\nconst defaultMakePresence = iface => {\n  const severed = `SEVERED: ${iface.replace(/^Alleged: /, '')}`;\n  return Far(severed, {});\n};\n\n/**\n * Make context for marshalling wallet or board data.\n * To be imported into the client, which never exports objects.\n *\n * @param {(iface: string) => unknown} [makePresence]\n */\nexport const makeImportContext = (makePresence = defaultMakePresence) => {\n  const walletObjects = {\n    /** @type {IdTable<number, unknown>} */\n    purse: {\n      bySlot: makeScalarMap(),\n      byVal: makeScalarMap(),\n    },\n    /** @type {IdTable<number, unknown>} */\n    payment: {\n      bySlot: makeScalarMap(),\n      byVal: makeScalarMap(),\n    },\n    /** @type {IdTable<number, unknown>} */\n    unknown: {\n      bySlot: makeScalarMap(),\n      byVal: makeScalarMap(),\n    },\n  };\n  /** @type {IdTable<BoardId, unknown>} */\n  const boardObjects = {\n    bySlot: makeScalarMap(),\n    byVal: makeScalarMap(),\n  };\n\n  /**\n   * @template Slot\n   * @template Val\n   * @param {IdTable<Slot, Val>} table\n   * @param {Slot} slot\n   * @param {string} iface\n   */\n  const provideVal = (table, slot, iface) => {\n    if (table.bySlot.has(slot)) {\n      return table.bySlot.get(slot);\n    }\n    const val = makePresence(iface);\n    initSlotVal(table, slot, val);\n    return val;\n  };\n\n  const slotToVal = {\n    /**\n     * @param {string} slot\n     * @param {string} iface\n     */\n    fromBoard: (slot, iface) => {\n      assert(isBoardId(slot), X`bad board slot ${q(slot)}`);\n      return provideVal(boardObjects, slot, iface);\n    },\n\n    /**\n     * @param {string} slot\n     * @param {string} iface\n     */\n    fromMyWallet: (slot, iface) => {\n      if (!slot) {\n        // Empty or null slots are neither in the wallet nor the board.\n        return makePresence(`${slot}`);\n      }\n      const { kind, id } = parseWalletSlot(walletObjects, slot);\n      return kind\n        ? provideVal(walletObjects[kind], id, iface)\n        : slotToVal.fromBoard(slot, iface);\n    },\n  };\n\n  const valToSlot = {\n    fromBoard: val => boardObjects.byVal.get(val),\n    /** @param {unknown} val */\n    fromMyWallet: val => {\n      const kind = findKey(walletObjects, k => walletObjects[k].byVal.has(val));\n      assert(kind, X`cannot serialize unregistered ${val}`);\n\n      const id = walletObjects[kind].byVal.get(val);\n      return makeWalletSlot(walletObjects, kind, id);\n    },\n  };\n\n  const marshal = {\n    fromBoard: makeMarshal(valToSlot.fromBoard, slotToVal.fromBoard, {\n      marshalName: 'fromBoard',\n    }),\n    fromMyWallet: makeMarshal(valToSlot.fromMyWallet, slotToVal.fromMyWallet, {\n      marshalName: 'fromMyWallet',\n    }),\n  };\n\n  return harden({\n    /**\n     * @param {BoardId} id\n     * @param {unknown} val\n     */\n    initBoardId: (id, val) => {\n      initSlotVal(boardObjects, id, val);\n    },\n    /**\n     * @param {BoardId} id\n     * @param {unknown} val\n     */\n    ensureBoardId: (id, val) => {\n      if (boardObjects.byVal.has(val)) {\n        assert.equal(boardObjects.byVal.get(val), id);\n        return;\n      }\n      initSlotVal(boardObjects, id, val);\n    },\n    fromMyWallet: Far('wallet marshaller', { ...marshal.fromMyWallet }),\n    fromBoard: Far('board marshaller', { ...marshal.fromBoard }),\n  });\n};\n\n/**\n * @param {string} iface\n * @param {{\n *   applyMethod: (target: unknown, method: string | symbol, args: unknown[]) => void,\n *   applyFunction: (target: unknown, args: unknown[]) => void,\n * }} handler\n */\nconst makePresence = (iface, handler) => {\n  let obj;\n  // eslint-disable-next-line no-new\n  new HandledPromise((resolve, reject, resolveWithPresence) => {\n    obj = resolveWithPresence(handler);\n  });\n  assert(obj);\n  return Remotable(iface, undefined, obj);\n};\n\n/**\n * @param {string} iface\n * @param {(parts: unknown[]) => void} log\n */\nexport const makeLoggingPresence = (iface, log) => {\n  /** @type {any} */ // TODO: solve types puzzle\n  const it = makePresence(iface, {\n    applyMethod: (target, method, args) => {\n      log(harden(['applyMethod', target, method, args]));\n    },\n    applyFunction: (target, args) => {\n      log(harden(['applyFunction', target, args]));\n    },\n  });\n  return it;\n};\n","import { Far } from '@endo/captp';\n\nexport const getScopedBridge = (origin, suggestedDappPetname, bridge) => {\n  const {\n    getPursesNotifier,\n    dappService,\n    offerService,\n    issuerService,\n    unserializer,\n    networkConfig,\n  } = bridge;\n\n  const { dapps, addDapp, setDappPetname, deleteDapp, enableDapp } =\n    dappService;\n\n  const setPetname = petname => setDappPetname(origin, petname);\n\n  let dapp = dapps.get(origin);\n  if (!dapp) {\n    let enableAction;\n    const approvedP = new Promise(res => {\n      enableAction = () => {\n        enableDapp(origin);\n        res();\n      };\n    });\n\n    dapp = {\n      id: origin,\n      meta: { id: origin },\n      petname: suggestedDappPetname,\n      origin,\n      enable: false,\n      actions: {\n        enable: enableAction,\n        setPetname,\n        delete: () => deleteDapp(origin),\n      },\n      approvedP,\n    };\n    addDapp(dapp);\n  }\n\n  return Far('scoped bridge', {\n    async addOffer(config) {\n      const currentTime = new Date().getTime();\n      const id = `${currentTime}`;\n      await dapp.approvedP;\n      offerService.addOffer({\n        id,\n        instancePetname: `instance@${config.instanceHandleBoardId}`,\n        requestContext: { dappOrigin: origin, origin },\n        meta: {\n          id: `${currentTime}`,\n          creationStamp: currentTime,\n        },\n        status: 'proposed',\n        ...config,\n      });\n      return id;\n    },\n    async suggestIssuer(petname, boardId) {\n      await dapp.approvedP;\n      issuerService.addSuggestion(petname, boardId);\n    },\n    async suggestInstallation(petname, boardId) {\n      await dapp.approvedP;\n      console.log('TODO: suggest installation', petname, boardId);\n    },\n    async suggestInstance(petname, boardId) {\n      await dapp.approvedP;\n      console.log('TODO: suggest instance', petname, boardId);\n    },\n    async getPursesNotifier() {\n      await dapp.approvedP;\n      // TODO: attenuate purses? maybe not needed if they're from follower\n      return getPursesNotifier();\n    },\n    async getOffersNotifier() {\n      await dapp.approvedP;\n      // TODO: filter offers by dapp origin\n      return offerService.notifier;\n    },\n    async getUnserializer() {\n      await dapp.approvedP;\n      return unserializer;\n    },\n    async getNetConfig() {\n      await dapp.approvedP;\n      return networkConfig;\n    },\n  });\n};\n","import { maybeLoad, maybeSave } from '../util/storage.js';\n\nconst DAPPS_KEY_PREFIX = 'DAPPS';\n\nexport const loadDapps = publicAddress =>\n  maybeLoad([DAPPS_KEY_PREFIX, publicAddress]) ?? [];\n\nexport const upsertDapp = (publicAddress, dapp) => {\n  const { origin, enable, petname } = dapp;\n\n  const dapps = loadDapps(publicAddress) ?? [];\n  maybeSave(\n    [DAPPS_KEY_PREFIX, publicAddress],\n    [\n      ...dapps.filter(d => d.origin !== origin),\n      { origin, enable, petname, id: origin, meta: { id: origin } },\n    ],\n  );\n};\n\nexport const removeDapp = (publicAddress, origin) => {\n  const dapps = loadDapps(publicAddress) ?? [];\n  maybeSave(\n    [DAPPS_KEY_PREFIX, publicAddress],\n    dapps.filter(d => d.origin !== origin),\n  );\n};\n","import { makeNotifierKit } from '@agoric/notifier';\nimport {\n  loadDapps as load,\n  removeDapp as remove,\n  upsertDapp as upsert,\n} from '../store/Dapps.js';\n\n/**\n * @param {string} publicAddress\n */\nexport const getDappService = publicAddress => {\n  const dapps = new Map();\n  const { notifier, updater } = makeNotifierKit();\n  const broadcastUpdates = () => updater.updateState([...dapps.values()]);\n\n  const upsertDapp = dapp => {\n    dapps.set(dapp.origin, dapp);\n    upsert(publicAddress, dapp);\n    broadcastUpdates();\n  };\n\n  const deleteDapp = origin => {\n    dapps.delete(origin);\n    remove(publicAddress, origin);\n    broadcastUpdates();\n  };\n\n  const setDappPetname = (origin, petname) => {\n    const dapp = dapps.get(origin);\n    assert(dapp, `Tried to set petname on undefined dapp ${origin}`);\n    upsertDapp({ ...dapp, petname });\n  };\n\n  const enableDapp = origin => {\n    const dapp = dapps.get(origin);\n    assert(dapp, `Tried to enable undefined dapp ${origin}`);\n    upsertDapp({ ...dapp, enable: true });\n  };\n\n  const storedDapps = load(publicAddress);\n  storedDapps.forEach(d => {\n    let enableAction;\n    const approvedP = new Promise(res => {\n      enableAction = () => {\n        enableDapp(d.origin);\n        res();\n      };\n    });\n\n    dapps.set(d.origin, {\n      ...d,\n      approvedP,\n      actions: {\n        enable: enableAction,\n        setPetname: petname => setDappPetname(d.origin, petname),\n        delete: () => deleteDapp(d.origin),\n      },\n    });\n\n    if (d.enable) {\n      enableAction();\n    }\n  });\n  broadcastUpdates();\n\n  return {\n    dapps,\n    notifier,\n    addDapp: upsertDapp,\n    setDappPetname,\n    deleteDapp,\n    enableDapp,\n  };\n};\n","import { maybeLoad, maybeSave } from '../util/storage.js';\n\nconst OFFERS_KEY_PREFIX = 'OFFERS';\n\nexport const loadOffers = publicAddress =>\n  maybeLoad([OFFERS_KEY_PREFIX, publicAddress]) ?? [];\n\nexport const addOffer = (publicAddress, offer) => {\n  const offers = loadOffers(publicAddress) ?? [];\n  maybeSave(\n    [OFFERS_KEY_PREFIX, publicAddress],\n    [...offers.filter(o => o.id !== offer.id), offer],\n  );\n};\n\nexport const removeOffer = (publicAddress, id) => {\n  const offers = loadOffers(publicAddress) ?? [];\n  maybeSave(\n    [OFFERS_KEY_PREFIX, publicAddress],\n    offers.filter(o => o.id !== id),\n  );\n};\n","import {\n  makeNotifierKit,\n  makeAsyncIterableFromNotifier,\n} from '@agoric/notifier';\nimport {\n  loadOffers as load,\n  removeOffer as remove,\n  addOffer as add,\n} from '../store/Offers.js';\n\n/**\n * @param {string} publicAddress\n * @param {(data: string) => Promise<any>} signSpendAction\n * @param {Notifier<any>} chainOffersNotifier\n */\nexport const getOfferService = (\n  publicAddress,\n  signSpendAction,\n  chainOffersNotifier,\n) => {\n  const offers = new Map();\n  let chainOffers = [];\n  const { notifier, updater } = makeNotifierKit();\n  const broadcastUpdates = () =>\n    updater.updateState([...offers.values(), ...chainOffers]);\n\n  const upsertOffer = offer => {\n    offers.set(offer.id, offer);\n    add(publicAddress, offer);\n    broadcastUpdates();\n  };\n\n  const declineOffer = id => {\n    const offer = offers.get(id);\n    assert(offer, `Tried to decline undefined offer ${id}`);\n    upsertOffer({ ...offer, status: 'decline' });\n    broadcastUpdates();\n  };\n\n  const acceptOffer = async id => {\n    const offer = offers.get(id);\n    assert(offer, `Tried to accept undefined offer ${id}`);\n    return signSpendAction(offer.spendAction);\n  };\n\n  const cancelOffer = _id => {\n    console.log('TODO: cancel offer');\n  };\n\n  const storedOffers = load(publicAddress);\n  storedOffers.forEach(o => {\n    if (o.status === 'decline') {\n      remove(publicAddress, o.id);\n    }\n    offers.set(o.id, {\n      ...o,\n    });\n  });\n  broadcastUpdates();\n\n  const watchChainOffers = async () => {\n    for await (const state of makeAsyncIterableFromNotifier(\n      chainOffersNotifier,\n    )) {\n      state?.forEach(offer => {\n        console.log('chain offer', offer);\n        const splitId = offer.id.split('#');\n        const rawId = splitId[splitId.length - 1];\n        if (offers.has(rawId)) {\n          offers.delete(rawId);\n          remove(publicAddress, rawId);\n        }\n        chainOffers = state;\n        broadcastUpdates();\n      });\n    }\n  };\n  watchChainOffers();\n\n  return {\n    offers,\n    notifier,\n    addOffer: upsertOffer,\n    acceptOffer,\n    cancelOffer,\n    declineOffer,\n  };\n};\n","import { makeNotifierKit } from '@agoric/notifier';\n\n/**\n * @param {(data: string) => Promise<any>} signSpendAction\n */\nexport const getIssuerService = signSpendAction => {\n  const suggestions = new Map();\n  // TODO: Upgrade to `makePublishKit`.\n  const { notifier, updater } = makeNotifierKit();\n  const broadcastUpdates = () => updater.updateState([...suggestions.values()]);\n\n  const deleteSuggestion = boardId => {\n    assert(\n      suggestions.has(boardId),\n      `Tried to delete undefined issuer suggestion ${boardId}`,\n    );\n    suggestions.delete(boardId);\n    broadcastUpdates();\n  };\n\n  const addSuggestion = (petname, boardId) => {\n    suggestions.set(boardId, {\n      boardId,\n      petname,\n      actions: {\n        delete: () => deleteSuggestion(boardId),\n        accept: async suggestedPetname => {\n          const action = JSON.stringify({\n            type: 'suggestIssuer',\n            data: { boardId, petname: suggestedPetname },\n          });\n          try {\n            await signSpendAction(action);\n            deleteSuggestion(boardId);\n          } catch (e) {\n            console.error('Sign spend action failed', action);\n          }\n        },\n      },\n    });\n    broadcastUpdates();\n  };\n\n  return {\n    notifier,\n    addSuggestion,\n  };\n};\n","import { E } from '@endo/eventual-send';\nimport { Far } from '@endo/marshal';\nimport {\n  makeAsyncIterableFromNotifier,\n  makeNotifierKit,\n} from '@agoric/notifier';\nimport { iterateEach, iterateReverse } from '@agoric/casting';\nimport { getScopedBridge } from '../service/ScopedBridge.js';\nimport { getDappService } from '../service/Dapps.js';\nimport { getOfferService } from '../service/Offers.js';\nimport { getIssuerService } from '../service/Issuers.js';\n\nconst newId = kind => `${kind}${Math.random()}`;\n\nexport const makeBackendFromWalletBridge = walletBridge => {\n  /**\n   * @template T\n   * @param {ERef<Notifier<T>>} notifier\n   */\n  const iterateNotifier = async notifier =>\n    makeAsyncIterableFromNotifier(notifier)[Symbol.asyncIterator]();\n\n  const { notifier: servicesNotifier } = makeNotifierKit(\n    harden({\n      board: E(walletBridge).getBoard(),\n    }),\n  );\n\n  /**\n   * @param {AsyncIterator<any[], any[], undefined>} offersMembers\n   */\n  const wrapOffersIterator = offersMembers =>\n    harden({\n      next: async () => {\n        const { done, value } = await E(offersMembers).next();\n        return harden({\n          done,\n          value:\n            value &&\n            value.map(({ id, ...rest }) =>\n              harden({\n                id,\n                ...rest,\n                actions: Far('offerActions', {\n                  // Provide these synthetic actions since offers don't have any yet.\n                  accept: () => E(walletBridge).acceptOffer(id),\n                  decline: () => E(walletBridge).declineOffer(id),\n                  cancel: () => E(walletBridge).cancelOffer(id),\n                }),\n              }),\n            ),\n        });\n      },\n      return: offersMembers.return,\n      throw: offersMembers.throw,\n    });\n\n  const firstSchema = harden({\n    actions: Far('schemaActions', {\n      createPurse: (issuer, id = newId('Purse')) =>\n        E(walletBridge).makeEmptyPurse(issuer?.issuerPetname, id),\n      createContact: (depositFacet, id = newId('Contact')) =>\n        E(walletBridge).addContact(id, depositFacet),\n      createIssuer: (issuer, id = newId('Issuer')) =>\n        E(walletBridge).addIssuer(id, issuer, true),\n    }),\n    services: iterateNotifier(servicesNotifier),\n    contacts: iterateNotifier(E(walletBridge).getContactsNotifier()),\n    dapps: iterateNotifier(E(walletBridge).getDappsNotifier()),\n    issuers: iterateNotifier(E(walletBridge).getIssuersNotifier()),\n    offers: wrapOffersIterator(\n      iterateNotifier(E(walletBridge).getOffersNotifier()),\n    ),\n    payments: iterateNotifier(E(walletBridge).getPaymentsNotifier()),\n    purses: iterateNotifier(E(walletBridge).getPursesNotifier()),\n    issuerSuggestions: iterateNotifier(\n      E(walletBridge).getIssuerSuggestionsNotifier(),\n    ),\n  });\n\n  // Just produce a single update for the initial backend.\n  // TODO: allow further updates.\n  const { notifier: backendNotifier, updater: backendUpdater } =\n    makeNotifierKit(firstSchema);\n\n  const backendIt = iterateNotifier(backendNotifier);\n\n  const cancel = e => {\n    backendUpdater.fail(e);\n  };\n\n  return { backendIt, cancel };\n};\n\n/**\n * @param {import('@agoric/casting').Follower<any>} follower\n * @param {import('@agoric/casting').Leader} leader\n * @param {ReturnType<import('@endo/marshal').makeMarshal>} marshaller\n * @param {string} publicAddress\n * @param {object} keplrConnection\n * @param {string} networkConfig\n * @param {(e: unknown) => void} [errorHandler]\n * @param {() => void} [firstCallback]\n */\nexport const makeWalletBridgeFromFollower = (\n  follower,\n  leader,\n  marshaller,\n  publicAddress,\n  keplrConnection,\n  networkConfig,\n  errorHandler = e => {\n    // Make an unhandled rejection.\n    throw e;\n  },\n  firstCallback = () => {},\n) => {\n  const notifiers = {\n    getPursesNotifier: 'purses',\n    getContactsNotifier: 'contacts',\n    getIssuersNotifier: 'issuers',\n    getOffersNotifier: 'offers',\n    getPaymentsNotifier: 'payments',\n  };\n\n  const notifierKits = Object.fromEntries(\n    Object.entries(notifiers).map(([_method, stateName]) => [\n      stateName,\n      makeNotifierKit(null),\n    ]),\n  );\n\n  // We assume just one cosmos purse per brand.\n  const offers = {};\n  const brandToPurse = new Map();\n  const pursePetnameToBrand = new Map();\n\n  const updatePurses = () => {\n    const purses = [];\n    for (const [brand, purse] of brandToPurse.entries()) {\n      if (purse.currentAmount && purse.brandPetname) {\n        pursePetnameToBrand.set(purse.pursePetname, brand);\n        purses.push(purse);\n      }\n    }\n    notifierKits.purses.updater.updateState(harden(purses));\n  };\n\n  const followLatest = async () => {\n    /** @type {number} */\n    let firstHeight;\n    for await (const { blockHeight } of iterateReverse(follower)) {\n      // TODO: Only set firstHeight and break if the value contains all our state.\n      firstHeight = blockHeight;\n    }\n    for await (const { value } of iterateEach(follower, {\n      height: firstHeight,\n    })) {\n      /** @type {import('@agoric/smart-wallet/src/smartWallet').UpdateRecord} */\n      const updateRecord = value;\n      if (firstCallback) {\n        firstCallback();\n        Object.values(notifierKits).forEach(({ updater }) =>\n          updater.updateState([]),\n        );\n        firstCallback = undefined;\n      }\n      switch (updateRecord.updated) {\n        case 'brand': {\n          const { descriptor } = updateRecord;\n          const purseObj = {\n            ...brandToPurse.get(descriptor.brand),\n            brand: descriptor.brand,\n            brandPetname: descriptor.petname,\n            pursePetname: descriptor.petname,\n            displayInfo: descriptor.displayInfo,\n          };\n          brandToPurse.set(descriptor.brand, purseObj);\n          updatePurses();\n          break;\n        }\n        case 'balance': {\n          // TODO: Don't assume just one purse per brand.\n          // https://github.com/Agoric/agoric-sdk/issues/6126\n          const { currentAmount } = updateRecord;\n          const purseObj = {\n            ...brandToPurse.get(currentAmount.brand),\n            currentAmount,\n            value: currentAmount.value,\n          };\n          brandToPurse.set(currentAmount.brand, purseObj);\n          updatePurses();\n          break;\n        }\n        case 'offerStatus': {\n          const { status } = updateRecord;\n          console.log('offerStatus', { status, offers });\n          const oldOffer = offers[status.id];\n          if (\n            oldOffer &&\n            oldOffer.status !== 'accept' &&\n            'numWantsSatisfied' in status\n          ) {\n            offers[status.id] = {\n              ...oldOffer,\n              id: `${status.id}`,\n              status: 'accept',\n            };\n            notifierKits.offers.updater.updateState(\n              harden(Object.values(offers)),\n            );\n          }\n          break;\n        }\n        default: {\n          throw Error(`Unknown updateRecord ${updateRecord.updated}`);\n        }\n      }\n    }\n  };\n\n  followLatest().catch(errorHandler);\n\n  const getNotifierMethods = Object.fromEntries(\n    Object.entries(notifiers).map(([method, stateName]) => {\n      const { notifier } = notifierKits[stateName];\n      return [method, () => notifier];\n    }),\n  );\n\n  const makeEmptyPurse = () => {\n    console.log('make empty purse');\n  };\n\n  const addContact = () => {\n    console.log('add contact');\n  };\n\n  const addIssuer = () => {\n    console.log('add issuer');\n  };\n\n  const signSpendAction = data => {\n    const {\n      signers: { interactiveSigner },\n    } = keplrConnection;\n    if (!interactiveSigner) {\n      throw new Error(\n        'Cannot sign a transaction in read only mode, connect to keplr.',\n      );\n    }\n    return interactiveSigner.submitSpendAction(data);\n  };\n\n  const issuerService = getIssuerService(signSpendAction);\n  const dappService = getDappService(publicAddress);\n  const offerService = getOfferService(\n    publicAddress,\n    signSpendAction,\n    getNotifierMethods.getOffersNotifier(),\n  );\n  const { acceptOffer, declineOffer, cancelOffer } = offerService;\n\n  // We override addOffer to adapt the old proposalTemplate format to the new\n  // smart-wallet format.\n  const addOfferPSMHack = async details => {\n    const {\n      id,\n      instanceHandleBoardId: instance, // This actually is the instance handle, not an ID.\n      invitationMaker: { method },\n      proposalTemplate: { give, want },\n    } = details;\n\n    const mapPurses = obj =>\n      Object.fromEntries(\n        Object.entries(obj).map(([kw, { brand, pursePetname, value }]) => [\n          kw,\n          {\n            brand: brand || pursePetnameToBrand.get(pursePetname),\n            value: BigInt(value),\n          },\n        ]),\n      );\n    const offer = {\n      id: new Date().getTime(),\n      invitationSpec: {\n        source: 'contract',\n        instance,\n        publicInvitationMaker: method,\n      },\n      proposal: {\n        give: mapPurses(give),\n        want: mapPurses(want),\n      },\n    };\n    const spendAction = await E(marshaller).serialize(\n      harden({\n        method: 'executeOffer',\n        offer,\n      }),\n    );\n\n    // Recover the instance's boardId.\n    const {\n      slots: [instanceBoardId],\n    } = await E(marshaller).serialize(instance);\n\n    const fullOffer = {\n      ...details,\n      instancePetname: `instance@${instanceBoardId}`,\n      spendAction: JSON.stringify(spendAction),\n    };\n    offerService.addOffer(fullOffer);\n    offers[id] = fullOffer;\n    return id;\n  };\n\n  const walletBridge = Far('follower wallet bridge', {\n    ...getNotifierMethods,\n    getDappsNotifier: () => dappService.notifier,\n    getOffersNotifier: () => offerService.notifier,\n    getIssuerSuggestionsNotifier: () => issuerService.notifier,\n    acceptOffer,\n    declineOffer,\n    cancelOffer,\n    makeEmptyPurse,\n    addContact,\n    addIssuer,\n    getScopedBridge: (origin, suggestedDappPetname) =>\n      getScopedBridge(origin, suggestedDappPetname, {\n        dappService,\n        offerService: { ...offerService, addOffer: addOfferPSMHack },\n        leader,\n        unserializer: marshaller,\n        publicAddress,\n        issuerService,\n        networkConfig,\n        ...getNotifierMethods,\n      }),\n  });\n\n  return walletBridge;\n};\n","import { makeCapTP } from '@endo/captp';\nimport { E } from '@endo/eventual-send';\n\nexport const bridgeStorageMessages = bridge => {\n  /** @type {Map<string,[ReturnType<typeof makeCapTP>, number]>} */\n  const dappToConn = new Map();\n\n  const handleStorageMessage = (key, newValue) => {\n    const keyParts = JSON.parse(key);\n    assert(Array.isArray(keyParts));\n    const [tag, origin, epoch, _ix] = /** @type {unknown[]} */ (keyParts);\n    const payload = JSON.parse(newValue);\n    if (tag !== 'out' || !payload || typeof payload.type !== 'string') {\n      return;\n    }\n\n    const obj = {\n      ...payload,\n      dappOrigin: origin,\n    };\n    const dappKey = JSON.stringify([origin, epoch]);\n    /** @type {ReturnType<typeof makeCapTP>}  */\n    let conn;\n    /** @type {number} */\n    let ix;\n    if (dappToConn.has(dappKey)) {\n      [conn, ix] = dappToConn.get(dappKey) || assert.fail();\n    } else {\n      /** @param {unknown} payloadOut */\n      const send = payloadOut => {\n        console.debug('WalletConnect: message -> storage', payloadOut);\n        window.localStorage.setItem(\n          JSON.stringify(['in', origin, epoch, ix]),\n          JSON.stringify(payloadOut),\n        );\n        ix += 1; // ISSUE: overflow?\n      };\n      const makeBoot = () => E(bridge).getScopedBridge(origin, origin);\n      console.debug('new capTP connection', { origin, epoch });\n      conn = makeCapTP(`from ${origin} at ${epoch}`, send, makeBoot);\n      ix = 0;\n    }\n    dappToConn.set(dappKey, [conn, ix + 1]);\n    console.debug('WalletConnect: storage -> dispatch', obj);\n    conn.dispatch(obj);\n    window.localStorage.removeItem(key);\n  };\n\n  const storageListener = ev => {\n    const { key, newValue } = ev;\n    // removeItem causes an event where newValue is null\n    if (key && newValue) {\n      handleStorageMessage(key, newValue);\n    }\n  };\n  window.addEventListener('storage', storageListener);\n\n  return () => {\n    window.removeEventListener('storage', storageListener);\n    for (const [conn, _ix] of dappToConn.values()) {\n      // @ts-expect-error capTP abort has wrong type?\n      conn.abort(Error('wallet connection cancelled'));\n    }\n  };\n};\n","import { makeFollower, makeLeader } from '@agoric/casting';\nimport React, { useEffect, useState } from 'react';\nimport Snackbar from '@mui/material/Snackbar';\nimport MuiAlert from '@mui/material/Alert';\nimport { observeIterator } from '@agoric/notifier';\nimport { makeImportContext } from '@agoric/wallet/api/src/marshal-contexts';\n\nimport { withApplicationContext } from '../contexts/Application';\nimport {\n  makeBackendFromWalletBridge,\n  makeWalletBridgeFromFollower,\n} from '../util/WalletBackendAdapter';\nimport { SmartConnectionMethod } from '../util/connections';\nimport { bridgeStorageMessages } from '../util/BridgeStorage';\n\nconst Alert = React.forwardRef(function Alert({ children, ...props }, ref) {\n  return (\n    <MuiAlert elevation={6} ref={ref} variant=\"filled\" {...props}>\n      {children}\n    </MuiAlert>\n  );\n});\n\nconst SmartWalletConnection = ({\n  connectionConfig,\n  setConnectionState,\n  setBackend,\n  setBackendErrorHandler,\n  keplrConnection,\n}) => {\n  const [snackbarMessages, setSnackbarMessages] = useState([]);\n  setConnectionState('connecting');\n\n  const handleSnackbarClose = (_, reason) => {\n    if (reason === 'clickaway') {\n      return;\n    }\n\n    setSnackbarMessages(sm => sm.slice(1));\n  };\n\n  const showError = (message, e, severity = 'error') => {\n    if (e) {\n      console.error(`${message}:`, e);\n      message += `: ${e.message}`;\n    }\n    if (severity === 'error') {\n      setConnectionState('error');\n    }\n    setSnackbarMessages(sm => [...sm, { severity, message }]);\n  };\n\n  useEffect(() => {\n    if (\n      !connectionConfig ||\n      (connectionConfig.smartConnectionMethod === SmartConnectionMethod.KEPLR &&\n        !keplrConnection)\n    ) {\n      return undefined;\n    }\n\n    let cancelIterator;\n    let cleanupStorageBridge;\n    const follow = async () => {\n      const { href, smartConnectionMethod } = connectionConfig;\n      let publicAddress;\n      if (smartConnectionMethod === SmartConnectionMethod.KEPLR) {\n        publicAddress = keplrConnection.address;\n      } else {\n        publicAddress = connectionConfig.publicAddress;\n      }\n\n      const backendError = e => {\n        showError('Error in wallet backend', e);\n        setBackend(null);\n        setConnectionState('error');\n      };\n\n      const context = makeImportContext();\n      const leader = makeLeader(href);\n      const follower = makeFollower(\n        `:published.wallet.${publicAddress}`,\n        leader,\n        { unserializer: context.fromMyWallet },\n      );\n      // TODO try making a smart-wallet version of this\n      const bridge = makeWalletBridgeFromFollower(\n        follower,\n        leader,\n        context.fromBoard,\n        publicAddress,\n        keplrConnection,\n        href,\n        backendError,\n        () => setConnectionState('bridged'),\n      );\n      const { backendIt, cancel } = await makeBackendFromWalletBridge(bridge);\n      cleanupStorageBridge = bridgeStorageMessages(bridge);\n      cancelIterator = cancel;\n      // Need to thunk the error handler, or it gets called immediately.\n      setBackendErrorHandler(() => backendError);\n      return observeIterator(backendIt, {\n        updateState: be => {\n          cancelIterator && setBackend(be);\n        },\n        fail: e => {\n          cancelIterator && backendError(e);\n        },\n        finish: be => {\n          cancelIterator && setBackend(be);\n        },\n      });\n    };\n    follow().catch(e => showError('Cannot read Smart Wallet casting', e));\n\n    return () => {\n      cancelIterator && cancelIterator();\n      cancelIterator = undefined;\n      cleanupStorageBridge && cleanupStorageBridge();\n      cleanupStorageBridge = undefined;\n    };\n  }, [connectionConfig, keplrConnection]);\n\n  return (\n    <div>\n      <Snackbar open={snackbarMessages.length > 0}>\n        <Alert\n          onClose={handleSnackbarClose}\n          severity={snackbarMessages[0]?.severity}\n          sx={{ width: '100%' }}\n        >\n          {snackbarMessages[0]?.message}\n        </Alert>\n      </Snackbar>\n    </div>\n  );\n};\n\nexport default withApplicationContext(SmartWalletConnection, context => ({\n  connectionConfig: context.connectionConfig,\n  setConnectionState: context.setConnectionState,\n  setBackend: context.setBackend,\n  setBackendErrorHandler: context.setBackendErrorHandler,\n  keplrConnection: context.keplrConnection,\n}));\n"],"names":["DEFAULT_BOOTSTRAP","delay","ms","Promise","resolve","setTimeout","randomBackoff","range","cap","Math","random","min","exponentialBackoff","attempt","base","DEFAULT_JITTER","where","jitter","DEFAULT_JITTER_SECONDS","console","warn","ceil","DEFAULT_RETRY_CALLBACK","err","backoff","DEFAULT_KEEP_POLLING","DEFAULT_KEEP_POLLING_SECONDS","then","MAKE_DEFAULT_DECODER","harden","str","JSON","parse","error","Error","message","MAKE_DEFAULT_UNSERIALIZER","ifaceAllegedPrefix","seen","Map","Far","unserialize","makeMarshal","undefined","slot","iface","has","get","startsWith","slice","length","obj","set","shuffle","a","i","j","floor","x","makePollingChangeFollower","async","keepPolling","E","leader","getOptions","iterable","Symbol","asyncIterator","nextPollPromise","next","cont","keepGoing","change","values","value","done","getLatestIterable","getEachIterable","getReverseIterable","details","X","assert","makeLeaderFromRpcAddresses","rpcAddrs","leaderOptions","Array","isArray","endpoints","retryCallback","retrying","lastRespondingEndpointIndex","thisAttempt","retry","watchCasting","_castingSpecP","pollingChangeFollower","mapEndpoints","callback","reject","endpointIndex","applyOne","res","makeRoundRobinLeader","map","rpcAddr","typeof","includes","makeLeaderFromNetworkConfig","netconfigURL","options","makeLeader","response","fetch","headers","accept","json","retryLeader","catch","bootstrap","makeNotifierIterable","notifier","makeNotifier","getSharableNotifierInternals","makeSubscriptionIterable","subscription","makeSubscriptionIterator","tailP","getSharableSubscriptionInternals","resultP","head","tail","mapAsyncIterable","transform","transformGenerator","iterateEach","follower","eachIterable","iterator","iterateReverse","toAscii","encodingStar","PATH_SEPARATOR_BYTE","charCodeAt","DATA_PREFIX_BYTES","Uint8Array","vstoragePathToCastingSpec","storagePath","storeName","elems","split","buf","storeSubkey","b","dataPrefixBytes","pathPrefixToConverters","te","TextEncoder","makeCastingSpecFromObject","specObj","subkey","encode","dataPrefix","makeCastingSpec","spec","sourceP","specString","match","kind","storePath","converter","makeCastingSpecFromString","getInterfaceOf","specCap","getStoreKey","makeCastingSpecFromRef","fail","QueryClient","stargateStar","Tendermint34Client","tendermintRpcStar","quote","q","textDecoder","TextDecoder","isStreamCell","cell","blockHeight","test","arrayEqual","defaultDataPrefixBytes","collectSingle","count","push","equal","proofs","makeFollower","specP","leaderOrMaker","defaultMakeLeader","decode","unserializer","proof","crasher","crash","e","castingSpecP","tendermintClientPs","provideTendermintClient","endpoint","clientP","connect","getBlockHeight","client","info","abciInfo","lastBlockHeight","endpointToQueryClient","provideQueryClient","queryClient","rpcClient","withExtensions","retryGetDataAndStripPrefix","tryGetPrefixedData","result","subarray","getProvenDataAtHeight","queryVerified","height","getUnprovenDataAtHeight","abciQuery","path","data","prove","code","log","tryGetDataAtHeight","allegedData","provenData","getDataAtHeight","streamCellForData","text","Number","followerElementFromStreamCellValue","currentBlockHeight","allValuesFromCell","streamCell","reverseValuesFromCell","lastValueFromCell","last","currentData","currentStreamCell","getEachIterableAtHeight","cursorBlockHeight","cursorData","cursorStreamCell","rightBlockHeight","rightData","rightStreamCell","cells","leftBlockHeight","leftData","leftStreamCell","pop","getReverseIterableAtHeight","makeCosmjsFollower","NaN","ai","makeSubscriptionFollower","isBoardId","specimen","makeWalletSlot","_tables","id","findKey","record","predicate","Object","keys","find","parseWalletSlot","tables","k","initSlotVal","table","val","bySlot","init","byVal","defaultMakePresence","severed","replace","getScopedBridge","origin","suggestedDappPetname","bridge","getPursesNotifier","dappService","offerService","issuerService","networkConfig","dapps","addDapp","setDappPetname","deleteDapp","enableDapp","setPetname","petname","dapp","enableAction","approvedP","meta","enable","actions","delete","config","currentTime","Date","getTime","addOffer","instancePetname","instanceHandleBoardId","requestContext","dappOrigin","creationStamp","status","boardId","addSuggestion","DAPPS_KEY_PREFIX","loadDapps","publicAddress","maybeLoad","getDappService","updater","makeNotifierKit","broadcastUpdates","updateState","upsertDapp","maybeSave","filter","d","upsert","remove","load","forEach","OFFERS_KEY_PREFIX","loadOffers","removeOffer","offers","o","getOfferService","signSpendAction","chainOffersNotifier","chainOffers","upsertOffer","offer","add","state","makeAsyncIterableFromNotifier","splitId","rawId","watchChainOffers","acceptOffer","spendAction","cancelOffer","_id","declineOffer","getIssuerService","suggestions","deleteSuggestion","action","stringify","type","suggestedPetname","newId","bridgeStorageMessages","dappToConn","storageListener","ev","key","newValue","keyParts","tag","epoch","_ix","payload","dappKey","conn","ix","send","payloadOut","debug","window","localStorage","setItem","makeBoot","makeCapTP","dispatch","removeItem","handleStorageMessage","addEventListener","removeEventListener","abort","Alert","React","ref","children","props","elevation","variant","withApplicationContext","connectionConfig","setConnectionState","setBackend","setBackendErrorHandler","keplrConnection","snackbarMessages","setSnackbarMessages","useState","showError","severity","sm","useEffect","smartConnectionMethod","SmartConnectionMethod","cancelIterator","cleanupStorageBridge","href","address","backendError","context","makePresence","walletObjects","purse","makeScalarMap","payment","unknown","boardObjects","provideVal","slotToVal","fromBoard","fromMyWallet","valToSlot","marshal","marshalName","initBoardId","ensureBoardId","makeImportContext","marshaller","errorHandler","firstCallback","notifiers","getContactsNotifier","getIssuersNotifier","getOffersNotifier","getPaymentsNotifier","notifierKits","fromEntries","entries","_method","stateName","brandToPurse","pursePetnameToBrand","updatePurses","purses","brand","currentAmount","brandPetname","pursePetname","firstHeight","updateRecord","updated","descriptor","purseObj","displayInfo","oldOffer","followLatest","getNotifierMethods","method","makeEmptyPurse","addContact","addIssuer","signers","interactiveSigner","submitSpendAction","addOfferPSMHack","instance","invitationMaker","proposalTemplate","give","want","mapPurses","kw","BigInt","invitationSpec","source","publicInvitationMaker","proposal","serialize","slots","instanceBoardId","fullOffer","getDappsNotifier","getIssuerSuggestionsNotifier","makeWalletBridgeFromFollower","backendIt","cancel","walletBridge","iterateNotifier","servicesNotifier","board","getBoard","firstSchema","createPurse","issuer","issuerPetname","createContact","depositFacet","createIssuer","services","contacts","issuers","offersMembers","rest","decline","return","throw","payments","issuerSuggestions","backendNotifier","backendUpdater","makeBackendFromWalletBridge","observeIterator","be","finish","follow","Snackbar","open","onClose","_","reason","sx","width"],"sourceRoot":""}