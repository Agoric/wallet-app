{"version":3,"file":"static/js/633.009687a0.chunk.js","mappings":"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","sources":["util/BridgeStorage.js","service/ScopedBridge.js","store/Dapps.js","service/Dapps.js","store/Offers.js","service/Offers.js","service/Issuers.js","util/WalletBackendAdapter.js","../../../casting/src/defaults.js","../../../casting/src/shuffle.js","../../../casting/src/change-follower.js","../../../casting/src/leader-netconfig.js","../../../casting/src/leader.js","../../../casting/src/iterable.js","../../../casting/src/casting-spec.js","../../../casting/src/follower-cosmjs.js","../../../casting/src/follower.js"],"sourcesContent":["import { makeCapTP } from '@endo/captp';\nimport { E } from '@endo/eventual-send';\n\nexport const bridgeStorageMessages = bridge => {\n  /** @type {Map<string,[ReturnType<typeof makeCapTP>, number]>} */\n  const dappToConn = new Map();\n\n  const handleStorageMessage = (key, newValue) => {\n    const keyParts = JSON.parse(key);\n    assert(Array.isArray(keyParts));\n    const [tag, origin, epoch, _ix] = /** @type {unknown[]} */ (keyParts);\n    const payload = JSON.parse(newValue);\n    if (tag !== 'out' || !payload || typeof payload.type !== 'string') {\n      return;\n    }\n\n    const obj = {\n      ...payload,\n      dappOrigin: origin,\n    };\n    const dappKey = JSON.stringify([origin, epoch]);\n    /** @type {ReturnType<typeof makeCapTP>}  */\n    let conn;\n    /** @type {number} */\n    let ix;\n    if (dappToConn.has(dappKey)) {\n      [conn, ix] = dappToConn.get(dappKey) || assert.fail();\n    } else {\n      /** @param {unknown} payloadOut */\n      const send = payloadOut => {\n        console.debug('WalletConnect: message -> storage', payloadOut);\n        window.localStorage.setItem(\n          JSON.stringify(['in', origin, epoch, ix]),\n          JSON.stringify(payloadOut),\n        );\n        ix += 1; // ISSUE: overflow?\n      };\n      const makeBoot = () => E(bridge).getScopedBridge(origin, origin);\n      console.debug('new capTP connection', { origin, epoch });\n      conn = makeCapTP(`from ${origin} at ${epoch}`, send, makeBoot);\n      ix = 0;\n    }\n    dappToConn.set(dappKey, [conn, ix + 1]);\n    console.debug('WalletConnect: storage -> dispatch', obj);\n    conn.dispatch(obj);\n    window.localStorage.removeItem(key);\n  };\n\n  const storageListener = ev => {\n    const { key, newValue } = ev;\n    // removeItem causes an event where newValue is null\n    if (key && newValue) {\n      handleStorageMessage(key, newValue);\n    }\n  };\n  window.addEventListener('storage', storageListener);\n\n  return () => {\n    window.removeEventListener('storage', storageListener);\n    for (const [conn, _ix] of dappToConn.values()) {\n      // @ts-expect-error capTP abort has wrong type?\n      conn.abort(Error('wallet connection cancelled'));\n    }\n  };\n};\n","import { Far } from '@endo/captp';\n\nexport const getScopedBridge = (origin, suggestedDappPetname, bridge) => {\n  const {\n    getPursesNotifier,\n    dappService,\n    offerService,\n    issuerService,\n    unserializer,\n  } = bridge;\n\n  const { dapps, addDapp, setDappPetname, deleteDapp, enableDapp } =\n    dappService;\n\n  const setPetname = petname => setDappPetname(origin, petname);\n\n  let dapp = dapps.get(origin);\n  if (!dapp) {\n    let enableAction;\n    const approvedP = new Promise(res => {\n      enableAction = () => {\n        enableDapp(origin);\n        res();\n      };\n    });\n\n    dapp = {\n      id: origin,\n      meta: { id: origin },\n      petname: suggestedDappPetname,\n      origin,\n      enable: false,\n      actions: {\n        enable: enableAction,\n        setPetname,\n        delete: () => deleteDapp(origin),\n      },\n      approvedP,\n    };\n    addDapp(dapp);\n  }\n\n  return Far('scoped bridge', {\n    async addOffer(config) {\n      const currentTime = new Date().getTime();\n      const id = `${currentTime}`;\n      await dapp.approvedP;\n      offerService.addOffer({\n        id,\n        instancePetname: `instance@${config.instanceHandleBoardId}`,\n        requestContext: { dappOrigin: origin, origin },\n        meta: {\n          id: `${currentTime}`,\n          creationStamp: currentTime,\n        },\n        status: 'proposed',\n        ...config,\n      });\n      return id;\n    },\n    async suggestIssuer(petname, boardId) {\n      await dapp.approvedP;\n      issuerService.addSuggestion(petname, boardId);\n    },\n    async suggestInstallation(petname, boardId) {\n      await dapp.approvedP;\n      console.log('TODO: suggest installation', petname, boardId);\n    },\n    async suggestInstance(petname, boardId) {\n      await dapp.approvedP;\n      console.log('TODO: suggest instance', petname, boardId);\n    },\n    async getPursesNotifier() {\n      await dapp.approvedP;\n      // TODO: attenuate purses? maybe not needed if they're from follower\n      return getPursesNotifier();\n    },\n    async getOffersNotifier() {\n      await dapp.approvedP;\n      // TODO: filter offers by dapp origin\n      return offerService.notifier;\n    },\n    async getUnserializer() {\n      await dapp.approvedP;\n      return unserializer;\n    },\n  });\n};\n","import { maybeLoad, maybeSave } from '../util/storage.js';\n\nconst DAPPS_KEY_PREFIX = 'DAPPS';\n\nexport const loadDapps = publicAddress =>\n  maybeLoad([DAPPS_KEY_PREFIX, publicAddress]) ?? [];\n\nexport const upsertDapp = (publicAddress, dapp) => {\n  const { origin, enable, petname } = dapp;\n\n  const dapps = loadDapps(publicAddress) ?? [];\n  maybeSave(\n    [DAPPS_KEY_PREFIX, publicAddress],\n    [\n      ...dapps.filter(d => d.origin !== origin),\n      { origin, enable, petname, id: origin, meta: { id: origin } },\n    ],\n  );\n};\n\nexport const removeDapp = (publicAddress, origin) => {\n  const dapps = loadDapps(publicAddress) ?? [];\n  maybeSave(\n    [DAPPS_KEY_PREFIX, publicAddress],\n    dapps.filter(d => d.origin !== origin),\n  );\n};\n","import { makeNotifierKit } from '@agoric/notifier';\nimport {\n  loadDapps as load,\n  removeDapp as remove,\n  upsertDapp as upsert,\n} from '../store/Dapps.js';\n\n/**\n * @param {string} publicAddress\n */\nexport const getDappService = publicAddress => {\n  const dapps = new Map();\n  const { notifier, updater } = makeNotifierKit();\n  const broadcastUpdates = () => updater.updateState([...dapps.values()]);\n\n  const upsertDapp = dapp => {\n    dapps.set(dapp.origin, dapp);\n    upsert(publicAddress, dapp);\n    broadcastUpdates();\n  };\n\n  const deleteDapp = origin => {\n    dapps.delete(origin);\n    remove(publicAddress, origin);\n    broadcastUpdates();\n  };\n\n  const setDappPetname = (origin, petname) => {\n    const dapp = dapps.get(origin);\n    assert(dapp, `Tried to set petname on undefined dapp ${origin}`);\n    upsertDapp({ ...dapp, petname });\n  };\n\n  const enableDapp = origin => {\n    const dapp = dapps.get(origin);\n    assert(dapp, `Tried to enable undefined dapp ${origin}`);\n    upsertDapp({ ...dapp, enable: true });\n  };\n\n  const storedDapps = load(publicAddress);\n  storedDapps.forEach(d => {\n    let enableAction;\n    const approvedP = new Promise(res => {\n      enableAction = () => {\n        enableDapp(d.origin);\n        res();\n      };\n    });\n\n    dapps.set(d.origin, {\n      ...d,\n      approvedP,\n      actions: {\n        enable: enableAction,\n        setPetname: petname => setDappPetname(d.origin, petname),\n        delete: () => deleteDapp(d.origin),\n      },\n    });\n\n    if (d.enable) {\n      enableAction();\n    }\n  });\n  broadcastUpdates();\n\n  return {\n    dapps,\n    notifier,\n    addDapp: upsertDapp,\n    setDappPetname,\n    deleteDapp,\n    enableDapp,\n  };\n};\n","import { maybeLoad, maybeSave } from '../util/storage.js';\n\nconst OFFERS_KEY_PREFIX = 'OFFERS';\n\nexport const loadOffers = publicAddress =>\n  maybeLoad([OFFERS_KEY_PREFIX, publicAddress]) ?? [];\n\nexport const addOffer = (publicAddress, offer) => {\n  const offers = loadOffers(publicAddress) ?? [];\n  maybeSave(\n    [OFFERS_KEY_PREFIX, publicAddress],\n    [...offers.filter(o => o.id !== offer.id), offer],\n  );\n};\n\nexport const removeOffer = (publicAddress, id) => {\n  const offers = loadOffers(publicAddress) ?? [];\n  maybeSave(\n    [OFFERS_KEY_PREFIX, publicAddress],\n    offers.filter(o => o.id !== id),\n  );\n};\n","import {\n  makeNotifierKit,\n  makeAsyncIterableFromNotifier,\n} from '@agoric/notifier';\nimport {\n  loadOffers as load,\n  removeOffer as remove,\n  addOffer as add,\n} from '../store/Offers.js';\n\n/**\n * @param {string} publicAddress\n * @param {(data: string) => Promise<any>} signSpendAction\n * @param {Notifier<any>} chainOffersNotifier\n */\nexport const getOfferService = (\n  publicAddress,\n  signSpendAction,\n  chainOffersNotifier,\n) => {\n  const offers = new Map();\n  let chainOffers = [];\n  const { notifier, updater } = makeNotifierKit();\n  const broadcastUpdates = () =>\n    updater.updateState([...offers.values(), ...chainOffers]);\n\n  const upsertOffer = offer => {\n    offers.set(offer.id, offer);\n    add(publicAddress, offer);\n    broadcastUpdates();\n  };\n\n  const declineOffer = id => {\n    const offer = offers.get(id);\n    assert(offer, `Tried to decline undefined offer ${id}`);\n    upsertOffer({ ...offer, status: 'decline' });\n    broadcastUpdates();\n  };\n\n  const acceptOffer = async id => {\n    const offer = offers.get(id);\n    assert(offer, `Tried to accept undefined offer ${id}`);\n    const action = JSON.stringify({ type: 'acceptOffer', data: offer });\n    return signSpendAction(action);\n  };\n\n  const cancelOffer = _id => {\n    console.log('TODO: cancel offer');\n  };\n\n  const storedOffers = load(publicAddress);\n  storedOffers.forEach(o => {\n    if (o.status === 'decline') {\n      remove(publicAddress, o.id);\n    }\n    offers.set(o.id, {\n      ...o,\n    });\n  });\n  broadcastUpdates();\n\n  const watchChainOffers = async () => {\n    for await (const state of makeAsyncIterableFromNotifier(\n      chainOffersNotifier,\n    )) {\n      state?.forEach(offer => {\n        const splitId = offer.id.split('#');\n        const rawId = splitId[splitId.length - 1];\n        if (offers.has(rawId)) {\n          offers.delete(rawId);\n          remove(publicAddress, rawId);\n        }\n        chainOffers = state;\n        broadcastUpdates();\n      });\n    }\n  };\n  watchChainOffers();\n\n  return {\n    offers,\n    notifier,\n    addOffer: upsertOffer,\n    acceptOffer,\n    cancelOffer,\n    declineOffer,\n  };\n};\n","import { makeNotifierKit } from '@agoric/notifier';\n\n/**\n * @param {(data: string) => Promise<any>} signSpendAction\n */\nexport const getIssuerService = signSpendAction => {\n  const suggestions = new Map();\n  // TODO: Upgrade to `makePublishKit`.\n  const { notifier, updater } = makeNotifierKit();\n  const broadcastUpdates = () => updater.updateState([...suggestions.values()]);\n\n  const deleteSuggestion = boardId => {\n    assert(\n      suggestions.has(boardId),\n      `Tried to delete undefined issuer suggestion ${boardId}`,\n    );\n    suggestions.delete(boardId);\n    broadcastUpdates();\n  };\n\n  const addSuggestion = (petname, boardId) => {\n    suggestions.set(boardId, {\n      boardId,\n      petname,\n      actions: {\n        delete: () => deleteSuggestion(boardId),\n        accept: async suggestedPetname => {\n          const action = JSON.stringify({\n            type: 'suggestIssuer',\n            data: { boardId, petname: suggestedPetname },\n          });\n          try {\n            await signSpendAction(action);\n            deleteSuggestion(boardId);\n          } catch (e) {\n            console.error('Sign spend action failed', action);\n          }\n        },\n      },\n    });\n    broadcastUpdates();\n  };\n\n  return {\n    notifier,\n    addSuggestion,\n  };\n};\n","import { E } from '@endo/eventual-send';\nimport { Far } from '@endo/marshal';\nimport {\n  makeAsyncIterableFromNotifier,\n  makeNotifierKit,\n} from '@agoric/notifier';\nimport { iterateLatest } from '@agoric/casting';\nimport { getScopedBridge } from '../service/ScopedBridge.js';\nimport { getDappService } from '../service/Dapps.js';\nimport { getOfferService } from '../service/Offers.js';\nimport { getIssuerService } from '../service/Issuers.js';\n\nconst newId = kind => `${kind}${Math.random()}`;\n\nexport const makeBackendFromWalletBridge = walletBridge => {\n  /**\n   * @template T\n   * @param {ERef<Notifier<T>>} notifier\n   */\n  const iterateNotifier = async notifier =>\n    makeAsyncIterableFromNotifier(notifier)[Symbol.asyncIterator]();\n\n  const { notifier: servicesNotifier } = makeNotifierKit(\n    harden({\n      board: E(walletBridge).getBoard(),\n    }),\n  );\n\n  /**\n   * @param {AsyncIterator<any[], any[], undefined>} offersMembers\n   */\n  const wrapOffersIterator = offersMembers =>\n    harden({\n      next: async () => {\n        const { done, value } = await E(offersMembers).next();\n        return harden({\n          done,\n          value:\n            value &&\n            value.map(({ id, ...rest }) =>\n              harden({\n                id,\n                ...rest,\n                actions: Far('offerActions', {\n                  // Provide these synthetic actions since offers don't have any yet.\n                  accept: () => E(walletBridge).acceptOffer(id),\n                  decline: () => E(walletBridge).declineOffer(id),\n                  cancel: () => E(walletBridge).cancelOffer(id),\n                }),\n              }),\n            ),\n        });\n      },\n      return: offersMembers.return,\n      throw: offersMembers.throw,\n    });\n\n  const firstSchema = harden({\n    actions: Far('schemaActions', {\n      createPurse: (issuer, id = newId('Purse')) =>\n        E(walletBridge).makeEmptyPurse(issuer?.issuerPetname, id),\n      createContact: (depositFacet, id = newId('Contact')) =>\n        E(walletBridge).addContact(id, depositFacet),\n      createIssuer: (issuer, id = newId('Issuer')) =>\n        E(walletBridge).addIssuer(id, issuer, true),\n    }),\n    services: iterateNotifier(servicesNotifier),\n    contacts: iterateNotifier(E(walletBridge).getContactsNotifier()),\n    dapps: iterateNotifier(E(walletBridge).getDappsNotifier()),\n    issuers: iterateNotifier(E(walletBridge).getIssuersNotifier()),\n    offers: wrapOffersIterator(\n      iterateNotifier(E(walletBridge).getOffersNotifier()),\n    ),\n    payments: iterateNotifier(E(walletBridge).getPaymentsNotifier()),\n    purses: iterateNotifier(E(walletBridge).getPursesNotifier()),\n    issuerSuggestions: iterateNotifier(\n      E(walletBridge).getIssuerSuggestionsNotifier(),\n    ),\n  });\n\n  // Just produce a single update for the initial backend.\n  // TODO: allow further updates.\n  const { notifier: backendNotifier, updater: backendUpdater } =\n    makeNotifierKit(firstSchema);\n\n  const backendIt = iterateNotifier(backendNotifier);\n\n  const cancel = e => {\n    backendUpdater.fail(e);\n  };\n\n  return { backendIt, cancel };\n};\n\n/**\n * @param {import('@agoric/casting').Follower} follower\n * @param {import('@agoric/casting').Leader} leader\n * @param {import('@agoric/casting').Unserializer} unserializer\n * @param {string} publicAddress\n * @param {object} keplrConnection\n * @param {(e: unknown) => void} [errorHandler]\n * @param {() => void} [firstCallback]\n */\nexport const makeWalletBridgeFromFollower = (\n  follower,\n  leader,\n  unserializer,\n  publicAddress,\n  keplrConnection,\n  errorHandler = e => {\n    // Make an unhandled rejection.\n    throw e;\n  },\n  firstCallback,\n) => {\n  const notifiers = {\n    getPursesNotifier: 'purses',\n    getContactsNotifier: 'contacts',\n    getIssuersNotifier: 'issuers',\n    getOffersNotifier: 'offers',\n    getPaymentsNotifier: 'payments',\n  };\n\n  const notifierKits = Object.fromEntries(\n    Object.entries(notifiers).map(([_method, stateName]) => [\n      stateName,\n      makeNotifierKit(null),\n    ]),\n  );\n\n  const followLatest = async () => {\n    for await (const { value: state } of iterateLatest(follower)) {\n      if (firstCallback) {\n        firstCallback();\n        firstCallback = undefined;\n      }\n      Object.entries(notifierKits).forEach(([stateName, { updater }]) => {\n        updater.updateState(state[stateName]);\n      });\n    }\n  };\n\n  followLatest().catch(errorHandler);\n\n  const getNotifierMethods = Object.fromEntries(\n    Object.entries(notifiers).map(([method, stateName]) => {\n      const { notifier } = notifierKits[stateName];\n      return [method, () => notifier];\n    }),\n  );\n\n  const makeEmptyPurse = () => {\n    console.log('make empty purse');\n  };\n\n  const addContact = () => {\n    console.log('add contact');\n  };\n\n  const addIssuer = () => {\n    console.log('add issuer');\n  };\n\n  const signSpendAction = data => {\n    const {\n      signers: { interactiveSigner },\n    } = keplrConnection;\n    if (!interactiveSigner) {\n      throw new Error(\n        'Cannot sign a transaction in read only mode, connect to keplr.',\n      );\n    }\n    return interactiveSigner.submitSpendAction(data);\n  };\n\n  const issuerService = getIssuerService(signSpendAction);\n  const dappService = getDappService(publicAddress);\n  const offerService = getOfferService(\n    publicAddress,\n    signSpendAction,\n    getNotifierMethods.getOffersNotifier(),\n  );\n  const { acceptOffer, declineOffer, cancelOffer } = offerService;\n\n  const walletBridge = Far('follower wallet bridge', {\n    ...getNotifierMethods,\n    getDappsNotifier: () => dappService.notifier,\n    getOffersNotifier: () => offerService.notifier,\n    getIssuerSuggestionsNotifier: () => issuerService.notifier,\n    acceptOffer,\n    declineOffer,\n    cancelOffer,\n    makeEmptyPurse,\n    addContact,\n    addIssuer,\n    getScopedBridge: (origin, suggestedDappPetname) =>\n      getScopedBridge(origin, suggestedDappPetname, {\n        dappService,\n        offerService,\n        leader,\n        unserializer,\n        publicAddress,\n        issuerService,\n        ...getNotifierMethods,\n      }),\n  });\n\n  return walletBridge;\n};\n","// @ts-check\n/* global setTimeout */\nimport { Far } from '@endo/far';\nimport { makeMarshal } from '@endo/marshal';\n\n/**\n * Default to the local chain.\n */\nexport const DEFAULT_BOOTSTRAP = 'http://localhost:26657';\n\nexport const DEFAULT_JITTER_SECONDS = 5;\n\nexport const DEFAULT_POLL_WITH_EVENTS_SECONDS = 600;\n\nexport const DEFAULT_KEEP_POLLING_SECONDS = 5;\n\n/**\n * Resolve a Promise after a given number of milliseconds.\n *\n * @param {number} ms\n * @returns {Promise<void>}\n */\nexport const delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n/**\n * @param {number} range\n * @param {number} [cap]\n */\nexport const randomBackoff = (range, cap = range) => {\n  return Math.random() * Math.min(cap, range);\n};\n\n/**\n * @param {number} [attempt]\n * @param {number} [base]\n * @param {number} [cap]\n */\nexport const exponentialBackoff = (attempt = 0, base = 1_000, cap = 30_000) => {\n  return randomBackoff(2 ** attempt * base, cap);\n};\n\n/**\n * Add a little to the retry delay to avoid a thundering herd.\n *\n * @param {string} where\n * @returns {Promise<void>}\n */\nexport const DEFAULT_JITTER = where => {\n  const jitter = randomBackoff(DEFAULT_JITTER_SECONDS * 1_000);\n  console.warn(`jittering ${where} by ${Math.ceil(jitter)}ms`);\n  return delay(jitter);\n};\n\n/**\n * Report an error, then retry the leader operation after a second or two.\n *\n * @param {string} where\n * @param {any} err\n * @param {number} [attempt]\n * @returns {Promise<void>}\n */\nexport const DEFAULT_RETRY_CALLBACK = (where, err, attempt = 0) => {\n  const backoff = exponentialBackoff(attempt);\n  console.warn(\n    `retrying ${where} in ${Math.ceil(backoff)}ms after attempt #${attempt}`,\n    err,\n  );\n  return delay(backoff);\n};\n\n/**\n * Return true after we want to be sure we received latest state something.\n *\n * @returns {Promise<boolean>}\n */\nexport const DEFAULT_KEEP_POLLING = () =>\n  delay(randomBackoff(DEFAULT_KEEP_POLLING_SECONDS * 1_000)).then(() => true);\n\nexport const MAKE_DEFAULT_DECODER = () => {\n  const td = new TextDecoder();\n  /**\n   * Decode utf-8 bytes, then parse the resulting JSON.\n   *\n   * @param {Uint8Array} buf\n   */\n  return harden(buf => {\n    const str = td.decode(buf);\n    return harden(JSON.parse(str));\n  });\n};\n\n/**\n * Unserialize the JSONable data.\n *\n * @type {() => import('./types').Unserializer}\n */\nexport const MAKE_DEFAULT_UNSERIALIZER = () => {\n  const ifaceAllegedPrefix = 'Alleged: ';\n  const ifaceInaccessiblePrefix = 'SEVERED: ';\n  const seen = new Map();\n  const slotToVal = (slot, iface) => {\n    // Private object.\n    if (seen.has(slot)) {\n      return seen.get(slot);\n    }\n    if (typeof iface === 'string' && iface.startsWith(ifaceAllegedPrefix)) {\n      iface = iface.slice(ifaceAllegedPrefix.length);\n    }\n    const obj = Far(`${ifaceInaccessiblePrefix}${iface}`, {});\n    seen.set(slot, obj);\n    return obj;\n  };\n  return Far('marshal unserializer', {\n    unserialize: makeMarshal(undefined, slotToVal).unserialize,\n  });\n};\n","// @ts-check\n\n/**\n * Modern version of Fisher-Yates shuffle algorithm (in-place).\n *\n * @template T\n * @param {Array<T>} a\n */\nexport const shuffle = a => {\n  for (let i = a.length - 1; i > 0; i -= 1) {\n    const j = Math.floor(Math.random() * (i + 1));\n    const x = a[i];\n    a[i] = a[j];\n    a[j] = x;\n  }\n};\n","// @ts-check\nimport { E, Far } from '@endo/far';\nimport { DEFAULT_KEEP_POLLING } from './defaults.js';\n\n/**\n * Just return an unspecified allegedValue every poll period.\n *\n * @param {import('./types').Leader} leader\n * @returns {Promise<import('./types.js').Follower<import('./types').CastingChange>>}\n */\nexport const makePollingChangeFollower = async leader => {\n  const { keepPolling = DEFAULT_KEEP_POLLING } = await E(leader).getOptions();\n\n  const iterable = Far('polling change follower iterable', {\n    [Symbol.asyncIterator]: () => {\n      /** @type {Promise<boolean> | undefined} */\n      let nextPollPromise;\n      return Far('polling change follower iterator', {\n        next: async () => {\n          if (!nextPollPromise) {\n            nextPollPromise = keepPolling('polling change follower').then(\n              cont => {\n                if (cont) {\n                  return E(leader)\n                    .jitter('polling change follower')\n                    .then(() => cont);\n                }\n                return cont;\n              },\n            );\n          }\n          const keepGoing = await nextPollPromise;\n          nextPollPromise = undefined;\n          const change = harden({\n            // Make no warrant as to the values.\n            values: [],\n          });\n          return harden({\n            value: change,\n            done: !keepGoing,\n          });\n        },\n      });\n    },\n  });\n\n  return Far('polling change follower', {\n    getLatestIterable: async () => iterable,\n    getEachIterable: async () => iterable,\n  });\n};\n","// @ts-check\n/* global fetch */\nimport { makeRoundRobinLeader } from './leader.js';\nimport {\n  DEFAULT_BOOTSTRAP,\n  DEFAULT_JITTER,\n  DEFAULT_RETRY_CALLBACK,\n} from './defaults.js';\n\nconst { details: X } = assert;\n\n/**\n * @param {string[]} rpcAddrs\n * @param {import('./types.js').LeaderOptions} [leaderOptions]\n * @returns {import('./types.js').Leader}\n */\nexport const makeLeaderFromRpcAddresses = (rpcAddrs, leaderOptions) => {\n  assert(Array.isArray(rpcAddrs), X`rpcAddrs ${rpcAddrs} must be an array`);\n\n  const rpcHrefs = rpcAddrs.map(rpcAddr => {\n    assert.typeof(rpcAddr, 'string', X`rpcAddr ${rpcAddr} must be a string`);\n    // Don't remove explicit port numbers from the URL, because the Cosmos\n    // `--node=xxx` flag requires them (it doesn't just assume that\n    // `--node=https://testnet.rpc.agoric.net` is the same as\n    // `--node=https://testnet.rpc.agoric.net:443`)\n    return rpcAddr.includes('://') ? rpcAddr : `http://${rpcAddr}`;\n  });\n\n  return makeRoundRobinLeader(rpcHrefs, leaderOptions);\n};\n\n/**\n * @param {string} netconfigURL\n * @param {import('./types.js').LeaderOptions} [options]\n */\nexport const makeLeaderFromNetworkConfig = (netconfigURL, options = {}) => {\n  const { retryCallback = DEFAULT_RETRY_CALLBACK, jitter = DEFAULT_JITTER } =\n    options;\n  /** @type {import('./types.js').LeaderOptions['retryCallback']} */\n  const retry = async (where, err, attempt) => {\n    if (retryCallback) {\n      return retryCallback(where, err, attempt);\n    }\n    throw err;\n  };\n  let attempt = 0;\n  const where = 'Network config leader';\n  return new Promise((resolve, reject) => {\n    const makeLeader = async () => {\n      const response = await fetch(netconfigURL, {\n        headers: { accept: 'application/json' },\n      });\n      const { rpcAddrs } = await response.json();\n      // Our part succeeded, so reset the attempt counter.\n      attempt = 0;\n      return makeLeaderFromRpcAddresses(rpcAddrs, options);\n    };\n    const retryLeader = async err => {\n      retry(where, err, attempt)\n        .then(() => jitter(where))\n        .then(() => makeLeader().then(resolve, retryLeader))\n        .catch(reject);\n      attempt += 1;\n    };\n    makeLeader().then(resolve, retryLeader);\n  });\n};\n\n/**\n * @param {string} [bootstrap]\n * @param {import('./types.js').LeaderOptions} [options]\n * @returns {ERef<import('./types.js').Leader>}\n */\nexport const makeLeader = (bootstrap = DEFAULT_BOOTSTRAP, options) => {\n  if (bootstrap.includes('network-config')) {\n    return makeLeaderFromNetworkConfig(bootstrap, options);\n  }\n  return makeLeaderFromRpcAddresses([bootstrap], options);\n};\n/** @typedef {ReturnType<typeof makeLeader>} Leader */\n","// @ts-check\nimport { E, Far } from '@endo/far';\nimport { DEFAULT_RETRY_CALLBACK, DEFAULT_JITTER } from './defaults.js';\nimport { shuffle } from './shuffle.js';\nimport { makePollingChangeFollower } from './change-follower.js';\n\n/**\n * Create a chain leader that rotates through a list of endpoints.\n *\n * @param {string[]} endpoints\n * @param {import('./types.js').LeaderOptions} leaderOptions\n */\nexport const makeRoundRobinLeader = (endpoints, leaderOptions = {}) => {\n  const { retryCallback = DEFAULT_RETRY_CALLBACK, jitter = DEFAULT_JITTER } =\n    leaderOptions;\n\n  // Shuffle the RPC addresses, so that we don't always hit the same one as all\n  // our peers.\n  shuffle(endpoints);\n\n  let lastRespondingEndpointIndex = 0;\n  let thisAttempt = 0;\n  let retrying;\n\n  /** @type {import('./types.js').Leader} */\n  const leader = Far('round robin leader', {\n    getOptions: () => leaderOptions,\n    jitter: async where => jitter && jitter(where),\n    retry: async (where, err, attempt) => {\n      if (retryCallback) {\n        return retryCallback(where, err, attempt);\n      }\n      throw err;\n    },\n    // eslint-disable-next-line no-use-before-define\n    watchCasting: _castingSpecP => pollingChangeFollower,\n    /**\n     * @template T\n     * @param {string} where\n     * @param {(endpoint: string) => Promise<T>} callback\n     */\n    mapEndpoints: async (where, callback) => {\n      where = `${where} (round-robin endpoints)`;\n      /** @type {Promise<T[]>} */\n      const p = new Promise((resolve, reject) => {\n        let endpointIndex = lastRespondingEndpointIndex;\n\n        const retry = err => {\n          if (!retrying) {\n            const attempt = thisAttempt;\n            retrying = E(leader)\n              .retry(where, err, attempt)\n              .then(() => {\n                endpointIndex = (endpointIndex + 1) % endpoints.length;\n                retrying = null;\n              });\n          }\n\n          retrying\n            .then(() => jitter && jitter(where))\n            // eslint-disable-next-line no-use-before-define\n            .then(applyOne, reject);\n          thisAttempt += 1;\n        };\n\n        const applyOne = () => {\n          Promise.resolve()\n            .then(() => callback(endpoints[endpointIndex]))\n            .then(res => {\n              resolve(harden([res]));\n              lastRespondingEndpointIndex = endpointIndex;\n              thisAttempt = 0;\n            }, retry);\n\n          // Don't return to prevent a promise chain.\n        };\n\n        applyOne();\n      });\n      return p;\n    },\n  });\n\n  const pollingChangeFollower = makePollingChangeFollower(leader);\n  return leader;\n};\n","// @ts-check\nimport { E, Far } from '@endo/far';\nimport { makeNotifier } from '@agoric/notifier';\n\n/**\n * @template T\n * @param {ERef<Notifier<T>>} notifier\n * @returns {ConsistentAsyncIterable<T>}\n */\nexport const makeNotifierIterable = notifier =>\n  makeNotifier(E(notifier).getSharableNotifierInternals());\n\n/**\n * TODO: Remove this function when we have `makePublisherKit`.\n *\n * @template T\n * @param {ERef<PublicationRecord<T>>} tailP\n * @returns {AsyncIterator<T>}\n */\nconst makeSubscriptionIterator = tailP => {\n  // To understand the implementation, start with\n  // https://web.archive.org/web/20160404122250/http://wiki.ecmascript.org/doku.php?id=strawman:concurrency#infinite_queue\n  return Far('SubscriptionIterator', {\n    next: async () => {\n      const resultP = E.get(tailP).head;\n      tailP = E.get(tailP).tail;\n      return resultP;\n    },\n  });\n};\n\n/**\n * TODO: Remove this function when we have `makePublisherKit`.\n *\n * @template T\n * @param {ERef<Subscription<T>>} subscription\n * @returns {ConsistentAsyncIterable<T>}\n */\nexport const makeSubscriptionIterable = subscription =>\n  harden({\n    [Symbol.asyncIterator]: () =>\n      makeSubscriptionIterator(\n        E(subscription).getSharableSubscriptionInternals(),\n      ),\n  });\n\n/**\n * @template TIn\n * @template TOut\n * @param {AsyncIterable<TIn>} iterable\n * @param {(value: TIn) => TOut} transform\n * @returns {AsyncIterable<TOut>}\n */\nexport const mapAsyncIterable = (iterable, transform) => {\n  async function* transformGenerator() {\n    for await (const value of iterable) {\n      yield transform(value);\n    }\n  }\n  return transformGenerator();\n};\n\n/**\n * TODO: Remove this function when we have `makePublisherKit`.\n *\n * @template T\n * @param {ERef<import('./types').Follower<T>>} follower\n */\nexport const iterateLatest = follower =>\n  // For now, just pass through the iterable.\n  Far('iterateLatest iterable', {\n    /** @returns {AsyncIterator<T>} */\n    [Symbol.asyncIterator]: () => {\n      const latestIterable = E(follower).getEachIterable();\n      const iterator = E(latestIterable)[Symbol.asyncIterator]();\n      return Far('iterateLatest iterator', {\n        next: () => E(iterator).next(),\n      });\n    },\n  });\n\n/**\n * TODO: Remove this function when we have `makePublisherKit`.\n *\n * @template T\n * @param {ERef<import('./types').Follower<T>>} follower\n */\nexport const iterateEach = follower =>\n  // For now, just pass through the iterable.\n  Far('iterateEach iterable', {\n    /** @returns {AsyncIterator<T>} */\n    [Symbol.asyncIterator]: () => {\n      const eachIterable = E(follower).getEachIterable();\n      const iterator = E(eachIterable)[Symbol.asyncIterator]();\n      return Far('iterateEach iterator', {\n        next: () => E(iterator).next(),\n      });\n    },\n  });\n","// @ts-check\nimport * as encodingStar from '@cosmjs/encoding';\nimport { E, getInterfaceOf } from '@endo/far';\n\nimport './types.js';\n\nconst { toAscii } = encodingStar;\n\n/**\n * @param {string} storagePath\n * @returns {import('./types').CastingSpec}\n */\nconst swingsetPathToCastingSpec = storagePath =>\n  harden({\n    storeName: 'swingset',\n    storeSubkey: toAscii(`swingset/data:${storagePath}`),\n  });\n\nconst PATH_SEPARATOR_BYTE = '.'.charCodeAt(0);\nconst DATA_PREFIX_BYTES = new Uint8Array([0]);\n\n/**\n * @param {string} storagePath\n * @param {string} [storeName]\n * @returns {import('./types').CastingSpec}\n */\nconst vstoragePathToCastingSpec = (storagePath, storeName = 'vstorage') => {\n  const elems = storagePath ? storagePath.split('.') : [];\n  const buf = toAscii(`${elems.length}.${storagePath}`);\n  return harden({\n    storeName,\n    storeSubkey: buf.map(b => (b === PATH_SEPARATOR_BYTE ? 0 : b)),\n    dataPrefixBytes: DATA_PREFIX_BYTES,\n  });\n};\n\nexport const DEFAULT_PATH_CONVERTER = vstoragePathToCastingSpec;\n\n/**\n * @type {Record<string, (path: string) => import('./types').CastingSpec>}\n */\nexport const pathPrefixToConverters = harden({\n  'swingset:': swingsetPathToCastingSpec,\n  'vstore:': vstoragePathToCastingSpec,\n  ':': DEFAULT_PATH_CONVERTER,\n});\n\n/**\n * @param {string} specString\n * @returns {import('./types').CastingSpec}\n */\nexport const makeCastingSpecFromString = specString => {\n  assert.typeof(specString, 'string');\n  const match = specString.match(/^([^:.]*:)(.*)/);\n  assert(\n    match,\n    `spec string ${specString} does not match 'PREFIX:PATH' or ':PATH'`,\n  );\n  const kind = match[1];\n  const storePath = match[2];\n  const converter = pathPrefixToConverters[kind];\n  assert(converter, `Unknown pathKind ${kind}`);\n  return converter(storePath);\n};\n\nconst te = new TextEncoder();\n\n/**\n * @param {any} specObj\n * @returns {import('./types').CastingSpec}\n */\nexport const makeCastingSpecFromObject = specObj => {\n  const { storeName, storeSubkey, dataPrefixBytes, subscription, notifier } =\n    specObj;\n  if (subscription || notifier) {\n    return harden({\n      subscription,\n      notifier,\n    });\n  }\n  let subkey = storeSubkey;\n  if (typeof storeSubkey === 'string') {\n    subkey = te.encode(storeSubkey);\n  }\n  let dataPrefix = dataPrefixBytes;\n  if (typeof dataPrefixBytes === 'string') {\n    dataPrefix = te.encode(dataPrefixBytes);\n  }\n  return harden({\n    storeName,\n    storeSubkey: subkey,\n    dataPrefixBytes: dataPrefix,\n  });\n};\n\n/**\n * @param {ERef<any>} specCap\n * @returns {Promise<import('./types').CastingSpec>}\n */\nexport const makeCastingSpecFromRef = async specCap => {\n  const specObj = await E(specCap).getStoreKey();\n  return makeCastingSpecFromObject(specObj);\n};\n\n/**\n * Create an abstract type from a given source representation\n *\n * @param {ERef<unknown>} sourceP\n * @returns {Promise<import('./types').CastingSpec>}\n */\nexport const makeCastingSpec = async sourceP => {\n  const spec = await sourceP;\n  if (typeof spec === 'string') {\n    return makeCastingSpecFromString(spec);\n  }\n  // @ts-expect-error type detection\n  const { storeName, subscription, notifier } = spec;\n  if (storeName || subscription || notifier) {\n    return makeCastingSpecFromObject(spec);\n  }\n  if (getInterfaceOf(spec)) {\n    return makeCastingSpecFromRef(spec);\n  }\n  assert.fail(`CastingSpec ${spec} is not a string, object, or ref`);\n};\n/** @typedef {ReturnType<typeof makeCastingSpec>} CastingSpec */\n","// @ts-check\nimport { E, Far } from '@endo/far';\nimport { makeNotifierKit, makeSubscriptionKit } from '@agoric/notifier';\nimport * as tendermintRpcStar from '@cosmjs/tendermint-rpc';\nimport * as stargateStar from '@cosmjs/stargate';\n\nimport {\n  iterateLatest,\n  makeSubscriptionIterable,\n  makeNotifierIterable,\n} from './iterable.js';\nimport { MAKE_DEFAULT_DECODER, MAKE_DEFAULT_UNSERIALIZER } from './defaults.js';\nimport { makeCastingSpec } from './casting-spec.js';\nimport { makeLeader as defaultMakeLeader } from './leader-netconfig.js';\n\nconst { QueryClient } = stargateStar;\nconst { Tendermint34Client } = tendermintRpcStar;\nconst { details: X } = assert;\n\n/** @template T @typedef {import('./types.js').FollowerElement<T>} FollowerElement */\n/** @template T @typedef {import('./types.js').Follower<T>} Follower */\n\n/**\n * @template T\n * @param {Iterable<T>} values\n * @returns {T}\n */\nconst collectSingle = values => {\n  /** @type {T[]} */\n  const head = [];\n  let count = 0;\n  for (const value of values) {\n    count += 1;\n    if (count === 1) {\n      head.push(value);\n    } else {\n      assert.fail(`expected single value, got at least ${count}`);\n    }\n  }\n\n  assert.equal(head.length, 1, 'expected single value');\n  return head[0];\n};\n\n/**\n * @callback QueryVerifier\n * @param {() => Promise<Uint8Array>} getProvenValue\n * @param {(reason?: unknown) => void} crash\n * @param {() => Promise<Uint8Array>} getAllegedValue\n */\n\n/**\n * @type {Record<Required<import('./types').FollowerOptions>['proof'], QueryVerifier>}\n */\nexport const proofToQueryVerifier = harden({\n  strict: async (getProvenValue, crash, _getAllegedValue) => {\n    // Just ignore the alleged value.\n    // Crash hard if we can't prove.\n    return getProvenValue().catch(crash);\n  },\n  none: async (_getProvenValue, _crash, getAllegedValue) => {\n    // Fast and loose.\n    return getAllegedValue();\n  },\n  optimistic: async (getProvenValue, crash, getAllegedValue) => {\n    const allegedValue = await getAllegedValue();\n    // Prove later, since it may take time we say we can't afford.\n    getProvenValue().then(provenValue => {\n      if (provenValue.length === allegedValue.length) {\n        if (provenValue.every((proven, i) => proven === allegedValue[i])) {\n          return;\n        }\n      }\n      crash(\n        assert.error(\n          X`Alleged value ${allegedValue} did not match proof ${provenValue}`,\n        ),\n      );\n    }, crash);\n\n    // Speculate that we got the right value.\n    return allegedValue;\n  },\n});\n\n/**\n * @template T\n * @param {any} sourceP\n * @param {import('./types').LeaderOrMaker} [leaderOrMaker]\n * @param {import('./types').FollowerOptions} [options]\n * @returns {Follower<FollowerElement<T>>}\n */\nexport const makeCosmjsFollower = (\n  sourceP,\n  leaderOrMaker = defaultMakeLeader,\n  options = {},\n) => {\n  const {\n    decode = MAKE_DEFAULT_DECODER(),\n    unserializer = MAKE_DEFAULT_UNSERIALIZER(),\n    proof = 'optimistic',\n    crasher = null,\n  } = options;\n\n  /** @type {QueryVerifier} */\n  const queryVerifier = proofToQueryVerifier[proof];\n  assert(queryVerifier, X`unrecognized follower proof mode ${proof}`);\n\n  const where = 'CosmJS follower';\n  const castingSpecP = makeCastingSpec(sourceP);\n\n  const leader =\n    typeof leaderOrMaker === 'function' ? leaderOrMaker() : leaderOrMaker;\n\n  /** @type {Map<string, import('@cosmjs/stargate').QueryClient>} */\n  const endpointToQueryClient = new Map();\n\n  /**\n   * @param {string} endpoint\n   */\n  const getOrCreateQueryClient = async endpoint => {\n    if (endpointToQueryClient.has(endpoint)) {\n      // Cache hit.\n      const queryClient = endpointToQueryClient.get(endpoint);\n      assert(queryClient);\n      return queryClient;\n    }\n    // Create a new client.  They retry automatically.\n    const rpcClient = await Tendermint34Client.connect(endpoint);\n    const queryClient = QueryClient.withExtensions(rpcClient);\n    endpointToQueryClient.set(endpoint, queryClient);\n    return queryClient;\n  };\n\n  /**\n   * @param {'queryVerified' | 'queryUnverified'} method\n   */\n  const makeQuerier =\n    method =>\n    /**\n     * @param {number} [height]\n     * @returns {Promise<Uint8Array>}\n     */\n    async height => {\n      const {\n        storeName,\n        storeSubkey,\n        dataPrefixBytes = new Uint8Array(),\n      } = await castingSpecP;\n      assert.typeof(storeName, 'string');\n      assert(storeSubkey);\n      let queryPath;\n      switch (method) {\n        case 'queryVerified': {\n          queryPath = storeName;\n          break;\n        }\n        case 'queryUnverified': {\n          queryPath = `store/${storeName}/key`;\n          break;\n        }\n        default: {\n          assert.fail(X`unrecognized method ${method}`);\n        }\n      }\n      const values = await E(leader).mapEndpoints(where, async endpoint => {\n        const queryClient = await getOrCreateQueryClient(endpoint);\n        return E(queryClient)\n          [method](queryPath, storeSubkey, height)\n          .then(\n            result => {\n              return { result, error: null };\n            },\n            error => {\n              return { result: null, error };\n            },\n          );\n      });\n      const { result, error } = collectSingle(values);\n      if (error !== null) {\n        throw error;\n      }\n      assert(result);\n\n      if (result.length === 0) {\n        // No data.\n        return result;\n      }\n\n      // Handle the data prefix if any.\n      assert(\n        result.length >= dataPrefixBytes.length,\n        X`result too short for data prefix ${dataPrefixBytes}`,\n      );\n      assert(\n        dataPrefixBytes.every((v, i) => v === result[i]),\n        X`${result} doesn't start with data prefix ${dataPrefixBytes}`,\n      );\n      return result.slice(dataPrefixBytes.length);\n    };\n\n  const getProvenValueAtHeight = makeQuerier('queryVerified');\n  const getUnprovenValueAtHeight = makeQuerier('queryUnverified');\n\n  /**\n   * @param {IterationObserver<FollowerElement<T>>} updater\n   * @param {AsyncIterable<FollowerElement<T>>} iterable\n   */\n  const getIterable = async (updater, iterable) => {\n    let finished = false;\n\n    const fail = err => {\n      finished = true;\n      updater.fail(err);\n      return false;\n    };\n\n    const crash = err => {\n      fail(err);\n      if (crasher) {\n        E(crasher)\n          .crash(`PROOF VERIFICATION FAILURE; crashing follower`, err)\n          .catch(e => assert(false, X`crashing follower failed: ${e}`));\n      } else {\n        console.error(`PROOF VERIFICATION FAILURE; crashing follower`, err);\n      }\n    };\n\n    let attempt = 0;\n    let retrying;\n\n    /**\n     * @param {import('./types.js').CastingChange} castingChange\n     * @returns {Promise<void>}\n     */\n    const queryAndUpdateOnce = castingChange =>\n      new Promise((resolve, reject) => {\n        const retry = async err => {\n          attempt += 1;\n          if (!retrying) {\n            retrying = E(leader)\n              .retry(where, err, attempt)\n              .then(() => (retrying = null));\n          }\n          await retrying;\n          await E(leader).jitter(where);\n\n          // eslint-disable-next-line no-use-before-define\n          tryQueryAndUpdate(castingChange).then(success, retryOrFail);\n        };\n\n        const success = fulfillment => {\n          attempt = 0;\n          resolve(fulfillment);\n        };\n\n        const retryOrFail = err => {\n          retry(err).catch(e => {\n            reject(e);\n            fail(e);\n          });\n        };\n\n        // eslint-disable-next-line no-use-before-define\n        tryQueryAndUpdate(castingChange).then(success, retryOrFail);\n      });\n\n    /**\n     * These semantics are to ensure that later queries are not committed\n     * ahead of earlier ones.\n     *\n     * @template T\n     * @param {(...args: T[]) => void} commitAction\n     */\n    const makePrepareInOrder = commitAction => {\n      let lastPrepareTicket = 0n;\n      let lastCommitTicket = 0n;\n\n      const prepareInOrder = () => {\n        lastPrepareTicket += 1n;\n        const ticket = lastPrepareTicket;\n        assert(ticket > lastCommitTicket);\n        const committer = Far('committer', {\n          isValid: () => ticket > lastCommitTicket,\n          /**\n           * @type {(...args: T[]) => void}\n           */\n          commit: (...args) => {\n            assert(committer.isValid());\n            lastCommitTicket = ticket;\n            commitAction(...args);\n          },\n        });\n        return committer;\n      };\n      return prepareInOrder;\n    };\n\n    const prepareUpdateInOrder = makePrepareInOrder(updater.updateState);\n\n    /** @type {Uint8Array} */\n    let lastBuf;\n\n    /**\n     * @param {import('./types').CastingChange} allegedChange\n     */\n    const tryQueryAndUpdate = async allegedChange => {\n      const committer = prepareUpdateInOrder();\n\n      // Make an unproven query if we have no alleged value.\n      const { values: allegedValues, blockHeight: allegedBlockHeight } =\n        allegedChange;\n      const getAllegedValue =\n        allegedValues.length > 0\n          ? () => Promise.resolve(allegedValues[allegedValues.length - 1])\n          : () => getUnprovenValueAtHeight(allegedBlockHeight);\n      const getProvenValue = () => getProvenValueAtHeight(allegedBlockHeight);\n\n      const buf = await queryVerifier(getProvenValue, crash, getAllegedValue);\n      if (buf.length === 0) {\n        fail(Error('No query results'));\n        return;\n      }\n      attempt = 0;\n      if (!committer.isValid()) {\n        return;\n      }\n      if (lastBuf) {\n        if (buf.length === lastBuf.length) {\n          if (buf.every((v, i) => v === lastBuf[i])) {\n            // Duplicate!\n            return;\n          }\n        }\n      }\n      lastBuf = buf;\n      const data = decode(buf);\n      if (!unserializer) {\n        /** @type {T} */\n        const value = data;\n        committer.commit({ value });\n        return;\n      }\n      const value = await E(unserializer).unserialize(data);\n      if (!committer.isValid()) {\n        return;\n      }\n      committer.commit({ value });\n    };\n\n    const changeFollower = E(leader).watchCasting(castingSpecP);\n    const queryWhenKeyChanges = async () => {\n      // Initial query to get the first value from the store.\n      await queryAndUpdateOnce(harden({ values: [] }));\n      if (finished) {\n        return;\n      }\n\n      // Only query when there are changes reported.\n      for await (const allegedChange of iterateLatest(changeFollower)) {\n        if (finished) {\n          return;\n        }\n        harden(allegedChange);\n        await queryAndUpdateOnce(allegedChange);\n      }\n    };\n\n    queryWhenKeyChanges().catch(fail);\n\n    return iterable;\n  };\n\n  // Enable the periodic fetch.\n  /** @type {Follower<FollowerElement<T>>} */\n  return Far('chain follower', {\n    getLatestIterable: () => {\n      const { updater, notifier } = makeNotifierKit();\n      return getIterable(updater, makeNotifierIterable(notifier));\n    },\n    getEachIterable: () => {\n      const { subscription, publication } = makeSubscriptionKit();\n      return getIterable(publication, makeSubscriptionIterable(subscription));\n    },\n  });\n};\n","// @ts-check\n\nimport { Far } from '@endo/far';\nimport {\n  mapAsyncIterable,\n  makeNotifierIterable,\n  makeSubscriptionIterable,\n} from './iterable.js';\nimport { makeCosmjsFollower } from './follower-cosmjs.js';\nimport { makeCastingSpec } from './casting-spec.js';\n\n/**\n * @template T\n * @param {ERef<import('./types').CastingSpec>} spec\n */\nconst makeSubscriptionFollower = spec => {\n  const transform = value => harden({ value });\n  /** @type {import('./types').Follower<{ value: T }>} */\n  const follower = Far('subscription/notifier follower', {\n    getLatestIterable: async () => {\n      const { notifier, subscription } = await spec;\n      let ai;\n      if (notifier) {\n        ai = makeNotifierIterable(notifier);\n      } else {\n        assert(subscription);\n        ai = makeSubscriptionIterable(subscription);\n      }\n      return mapAsyncIterable(ai, transform);\n    },\n\n    getEachIterable: async () => {\n      const { notifier, subscription } = await spec;\n      let ai;\n      if (subscription) {\n        ai = makeSubscriptionIterable(subscription);\n      } else {\n        assert(notifier);\n        ai = makeNotifierIterable(notifier);\n      }\n      return mapAsyncIterable(ai, transform);\n    },\n  });\n  return follower;\n};\n\n/**\n * @template T\n * @param {ERef<import('./types').CastingSpec> | string} specP\n * @param {import('./types').LeaderOrMaker} [leaderOrMaker]\n * @param {import('./types').FollowerOptions} [options]\n * @returns {Promise<import('./types').Follower<import('./types').FollowerElement<T>>>}\n */\nexport const makeFollower = async (specP, leaderOrMaker, options) => {\n  const spec = await makeCastingSpec(specP);\n  const { storeName } = spec;\n  if (storeName) {\n    return makeCosmjsFollower(spec, leaderOrMaker, options);\n  }\n  return makeSubscriptionFollower(spec);\n};\n"],"names":["bridgeStorageMessages","bridge","dappToConn","Map","storageListener","ev","key","newValue","keyParts","JSON","parse","assert","Array","isArray","tag","origin","epoch","_ix","payload","type","obj","dappOrigin","dappKey","stringify","conn","ix","has","get","fail","send","payloadOut","console","debug","window","localStorage","setItem","makeBoot","E","getScopedBridge","makeCapTP","set","dispatch","removeItem","handleStorageMessage","addEventListener","removeEventListener","values","abort","Error","suggestedDappPetname","getPursesNotifier","dappService","offerService","issuerService","unserializer","dapps","addDapp","setDappPetname","deleteDapp","enableDapp","setPetname","petname","dapp","enableAction","approvedP","Promise","res","id","meta","enable","actions","delete","Far","async","config","currentTime","Date","getTime","addOffer","instancePetname","instanceHandleBoardId","requestContext","creationStamp","status","boardId","addSuggestion","log","notifier","DAPPS_KEY_PREFIX","loadDapps","publicAddress","maybeLoad","getDappService","updater","makeNotifierKit","broadcastUpdates","updateState","upsertDapp","maybeSave","filter","d","upsert","remove","load","forEach","OFFERS_KEY_PREFIX","loadOffers","removeOffer","offers","o","getOfferService","signSpendAction","chainOffersNotifier","chainOffers","upsertOffer","offer","add","state","makeAsyncIterableFromNotifier","splitId","split","rawId","length","watchChainOffers","acceptOffer","action","data","cancelOffer","_id","declineOffer","getIssuerService","suggestions","deleteSuggestion","accept","suggestedPetname","e","error","newId","kind","Math","random","makeBackendFromWalletBridge","walletBridge","iterateNotifier","Symbol","asyncIterator","servicesNotifier","harden","board","getBoard","firstSchema","createPurse","issuer","makeEmptyPurse","issuerPetname","createContact","depositFacet","addContact","createIssuer","addIssuer","services","contacts","getContactsNotifier","getDappsNotifier","issuers","getIssuersNotifier","offersMembers","getOffersNotifier","next","done","value","map","rest","decline","cancel","return","throw","payments","getPaymentsNotifier","purses","issuerSuggestions","getIssuerSuggestionsNotifier","backendNotifier","backendUpdater","backendIt","makeWalletBridgeFromFollower","follower","leader","keplrConnection","errorHandler","firstCallback","notifiers","notifierKits","Object","fromEntries","entries","_method","stateName","followLatest","iterateLatest","undefined","catch","getNotifierMethods","method","signers","interactiveSigner","submitSpendAction","DEFAULT_BOOTSTRAP","delay","ms","resolve","setTimeout","randomBackoff","range","cap","min","exponentialBackoff","attempt","base","DEFAULT_JITTER","where","jitter","DEFAULT_JITTER_SECONDS","warn","ceil","DEFAULT_RETRY_CALLBACK","err","backoff","DEFAULT_KEEP_POLLING","DEFAULT_KEEP_POLLING_SECONDS","then","MAKE_DEFAULT_DECODER","td","TextDecoder","buf","str","decode","MAKE_DEFAULT_UNSERIALIZER","ifaceAllegedPrefix","seen","unserialize","makeMarshal","slot","iface","startsWith","slice","shuffle","a","i","j","floor","x","makePollingChangeFollower","keepPolling","getOptions","iterable","nextPollPromise","cont","keepGoing","change","getLatestIterable","getEachIterable","details","X","makeLeaderFromRpcAddresses","rpcAddrs","leaderOptions","endpoints","retryCallback","retrying","lastRespondingEndpointIndex","thisAttempt","retry","watchCasting","_castingSpecP","pollingChangeFollower","mapEndpoints","callback","reject","endpointIndex","applyOne","makeRoundRobinLeader","rpcAddr","typeof","includes","makeLeaderFromNetworkConfig","netconfigURL","options","makeLeader","response","fetch","headers","json","retryLeader","bootstrap","makeNotifierIterable","makeNotifier","getSharableNotifierInternals","makeSubscriptionIterable","subscription","makeSubscriptionIterator","tailP","getSharableSubscriptionInternals","resultP","head","tail","mapAsyncIterable","transform","transformGenerator","latestIterable","iterator","toAscii","encodingStar","PATH_SEPARATOR_BYTE","charCodeAt","DATA_PREFIX_BYTES","Uint8Array","vstoragePathToCastingSpec","storagePath","storeName","elems","storeSubkey","b","dataPrefixBytes","pathPrefixToConverters","te","TextEncoder","makeCastingSpecFromObject","specObj","subkey","encode","dataPrefix","makeCastingSpec","spec","sourceP","specString","match","storePath","converter","makeCastingSpecFromString","getInterfaceOf","specCap","getStoreKey","makeCastingSpecFromRef","QueryClient","stargateStar","Tendermint34Client","tendermintRpcStar","collectSingle","count","push","equal","proofToQueryVerifier","strict","getProvenValue","crash","_getAllegedValue","none","_getProvenValue","_crash","getAllegedValue","optimistic","allegedValue","provenValue","every","proven","makeCosmjsFollower","leaderOrMaker","defaultMakeLeader","proof","crasher","queryVerifier","castingSpecP","endpointToQueryClient","getOrCreateQueryClient","endpoint","queryClient","rpcClient","connect","withExtensions","makeQuerier","queryPath","height","result","v","getProvenValueAtHeight","getUnprovenValueAtHeight","getIterable","finished","queryAndUpdateOnce","castingChange","success","fulfillment","retryOrFail","tryQueryAndUpdate","prepareUpdateInOrder","commitAction","lastPrepareTicket","lastCommitTicket","ticket","committer","isValid","commit","makePrepareInOrder","lastBuf","allegedValues","blockHeight","allegedBlockHeight","allegedChange","changeFollower","queryWhenKeyChanges","publication","makeSubscriptionKit","makeFollower","specP","ai","makeSubscriptionFollower"],"sourceRoot":""}