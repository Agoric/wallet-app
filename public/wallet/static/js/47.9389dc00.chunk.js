"use strict";(globalThis.webpackChunk_agoric_wallet_ui=globalThis.webpackChunk_agoric_wallet_ui||[]).push([[47],{7047:(e,t,r)=>{r.r(t),r.d(t,{default:()=>Je});var n=r(3876),a=r(7017),o=r(2765);const s="http://localhost:26657",i=e=>new Promise((t=>setTimeout(t,e))),c=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e;return Math.random()*Math.min(t,e)},l=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3e4;return c(2**e*t,r)},d=e=>{const t=c(5e3);return console.debug(`jittering ${e} by ${Math.ceil(t)}ms`),i(t)},u=function(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const n=l(r);return console.log(`retrying ${e} in ${Math.ceil(n)}ms after attempt #${r}`,t),i(n)},f=()=>i(c(5e3)).then((()=>!0)),g=()=>harden((e=>{try{return harden(JSON.parse(e))}catch(t){throw new Error(`Cannot decode alleged JSON (${t.message}): ${e}`)}})),p=()=>{const e="Alleged: ",t=new Map;return(0,a.cI)("marshal unserializer",{unserialize:(0,o.AU)(void 0,((r,n)=>{if(t.has(r))return t.get(r);"string"===typeof n&&n.startsWith(e)&&(n=n.slice(e.length));const o=(0,a.cI)(`SEVERED: ${n}`,{});return t.set(r,o),o})).unserialize})},h=e=>{for(let t=e.length-1;t>0;t-=1){const r=Math.floor(Math.random()*(t+1)),n=e[t];e[t]=e[r],e[r]=n}},m=async e=>{const{keepPolling:t=f}=await(0,a.E)(e).getOptions(),r=(0,a.cI)("polling change follower iterable",{[Symbol.asyncIterator]:()=>{let r;return(0,a.cI)("polling change follower iterator",{next:async()=>{r||(r=t("polling change follower").then((t=>t?(0,a.E)(e).jitter("polling change follower").then((()=>t)):t)));const n=await r;r=void 0;const o=harden({values:[]});return harden({value:o,done:!n})}})}});return(0,a.cI)("polling change follower",{getLatestIterable:async()=>r,getEachIterable:async()=>r,getReverseIterable:async()=>{throw Error("not implemented for polling change follower")}})},{details:y}=assert,b=(e,t)=>{assert(Array.isArray(e),y`rpcAddrs ${e} must be an array`);return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{retryCallback:r=u,jitter:n=d}=t;h(e);let o,s=0,i=0;const c=(0,a.cI)("round robin leader",{getOptions:()=>t,jitter:async e=>n&&n(e),retry:async(e,t,n)=>{if(r)return r(e,t,n);throw t},watchCasting:e=>l,mapEndpoints:async(t,r)=>(t=`${t} (round-robin endpoints)`,new Promise(((l,d)=>{let u=s;const f=r=>{if(!o){const n=i;o=(0,a.E)(c).retry(t,r,n).then((()=>{u=(u+1)%e.length,o=null}))}o.then((()=>n&&n(t))).then(g,d),i+=1},g=()=>{Promise.resolve().then((()=>r(e[u]))).then((e=>{l(harden([e])),s=u,i=0}),f)};g()})))}),l=m(c);return c}(e.map((e=>(assert.typeof(e,"string",y`rpcAddr ${e} must be a string`),e.includes("://")?e:`http://${e}`))),t)},w=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{retryCallback:r=u,jitter:n=d}=t,a=async(e,t,n)=>{if(r)return r(e,t,n);throw t};let o=0;const s="Network config leader";return new Promise(((r,i)=>{const c=async()=>{const r=await fetch(e,{headers:{accept:"application/json"}}),{rpcAddrs:n}=await r.json();return o=0,b(n,t)},l=async e=>{a(s,e,o).then((()=>n(s))).then((()=>c().then(r,l))).catch(i),o+=1};c().then(r,l)}))},v=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:s,t=arguments.length>1?arguments[1]:void 0;return e.includes("network-config")?w(e,t):b([e],t)},E=e=>(0,n.a2)((0,a.E)(e).getSharableNotifierInternals()),S=e=>harden({[Symbol.asyncIterator]:()=>{return t=(0,a.E)(e).getSharableSubscriptionInternals(),(0,a.cI)("SubscriptionIterator",{next:async()=>{const e=a.E.get(t).head;return t=a.E.get(t).tail,e}});var t}}),k=(e,t)=>async function*(){for await(const r of e)yield t(r)}(),I=(e,t)=>(0,a.cI)("iterateEach iterable",{[Symbol.asyncIterator]:()=>{const r=(0,a.E)(e).getEachIterable(t),n=(0,a.E)(r)[Symbol.asyncIterator]();return(0,a.cI)("iterateEach iterator",{next:()=>(0,a.E)(n).next()})}});var $=r(2039),P=r.t($,2),x=r(6578),O=r.t(x,2),C=r(2363),N=r.t(C,2);const{toAscii:j}=N,A=".".charCodeAt(0),B=new Uint8Array([0]),M=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"vstorage";const r=e?e.split("."):[],n=j(`${r.length}.${e}`);return harden({storeName:t,storeSubkey:n.map((e=>e===A?0:e)),dataPrefixBytes:B})},T=harden({"swingset:":e=>harden({storeName:"swingset",storeSubkey:j(`swingset/data:${e}`)}),"vstore:":M,":":M}),W=new TextEncoder,H=e=>{const{storeName:t,storeSubkey:r,dataPrefixBytes:n,subscription:a,notifier:o}=e;if(a||o)return harden({subscription:a,notifier:o});let s=r;"string"===typeof r&&(s=W.encode(r));let i=n;return"string"===typeof n&&(i=W.encode(n)),harden({storeName:t,storeSubkey:s,dataPrefixBytes:i})},D=async e=>{const t=await e;if("string"===typeof t)return(e=>{assert.typeof(e,"string");const t=e.match(/^([^:.]*:)(.*)/);assert(t,`spec string ${e} does not match 'PREFIX:PATH' or ':PATH'`);const r=t[1],n=t[2],a=T[r];return assert(a,`Unknown pathKind ${r}`),a(n)})(t);const{storeName:r,subscription:n,notifier:o}=t;return r||n||o?H(t):(0,a.mY)(t)?(async e=>{const t=await(0,a.E)(e).getStoreKey();return H(t)})(t):void assert.fail(`CastingSpec ${t} is not a string, object, or ref`)},{QueryClient:Z}=O,{Tendermint34Client:z}=P,{details:V,quote:U}=assert,L=new TextDecoder,R=e=>e&&"object"===typeof e&&Array.isArray(e.values)&&"string"===typeof e.blockHeight&&/^0$|^[1-9][0-9]*$/.test(e.blockHeight),J=(e,t)=>{if(e.length!==t.length)return!1;for(let r=0;r<e.length;r+=1)if(e[r]!==t[r])return!1;return!0},q=new Uint8Array,K=e=>{const t=[];let r=0;for(const n of e)r+=1,1===r?t.push(n):assert.fail(`expected single value, got at least ${r}`);return assert.equal(t.length,1,"expected single value"),t[0]},F=["strict","none","optimistic"],G=async(e,t,r)=>{const n=await D(e),{storeName:o}=n;return o?function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:v,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const{decode:n=g(),unserializer:o=p(),proof:s="optimistic",crasher:i=null}=r,c=e=>{throw i&&(0,a.E)(i).crash("PROOF VERIFICATION FAILURE; crashing follower",e).catch((e=>assert.fail(V`crashing follower failed: ${e}`))),e};assert(F.includes(s),V`unrecognized follower proof mode ${s}`);const l="CosmJS follower",d=D(e),u="function"===typeof t?t():t,f=new Map,h=e=>{let t=f.get(e);return t||(t=z.connect(e),f.set(e,t)),t},m=async()=>{const e=await(0,a.E)(u).mapEndpoints(l,(async e=>{const t=await h(e),r=await t.abciInfo(),{lastBlockHeight:n}=r;return assert.typeof(n,"number"),n}));return K(e)},y=new Map,b=async e=>{if(y.has(e)){const t=y.get(e);return assert(t),t}const t=await h(e),r=Z.withExtensions(t);return y.set(e,r),r},w=async e=>{const{storeName:t,storeSubkey:r,dataPrefixBytes:n=q}=await d;assert.typeof(t,"string",V`storeName must be a string, got ${t}`),assert(r,V`storeSubkey must be a Uint8Array, got ${r}`);const o=await(0,a.E)(u).mapEndpoints(l,(async n=>e(n,t,r).then((e=>({result:e,error:null})),(e=>({result:null,error:e}))))),{result:s,error:i}=K(o);if(null!==i)throw i;return assert(s),0===s.length?s:(assert(s.length>=n.length,V`result too short for data prefix ${n}`),assert(J(s.subarray(0,n.length),n),V`${s} doesn't start with data prefix ${n}`),s.slice(n.length))},E=async e=>w((async(t,r,n)=>{const o=await b(t);return(0,a.E)(o).queryVerified(r,n,e)})),S=async e=>w((async(t,r,n)=>{const a=await h(t),o=await a.abciQuery({path:`store/${r}/key`,data:n,height:e,prove:!1});if(0!==o.code)throw new Error(`Tendermint ABCI query failed: ${o.log}`);const{value:s}=o;return s})),k=async e=>{if("strict"===s)return E(e).catch(c);if("none"===s)return S(e);if("optimistic"===s){const t=await S(e);return E(e).then((e=>{J(e,t)||c(assert.error(V`Alleged value ${t} did not match proof ${e}`))}),c),t}assert.fail(V`Unrecognized proof option ${U(s)}, must be one of strict, none, or optimistic`)},I=async e=>{assert.typeof(e,"number");for(let r=0;;r+=1)try{return await k(e)}catch(t){await(0,a.E)(u).retry(l,t,r);continue}},$=(e,t)=>{const r=L.decode(t);try{const e=JSON.parse(r);if(R(e))return harden({blockHeight:Number(e.blockHeight),values:e.values.map(n)})}catch{}return harden({blockHeight:e,values:[n(r)]})},P=async(e,t,r)=>({value:await(o?(0,a.E)(o).unserialize(e):e),blockHeight:t,currentBlockHeight:r});function*x(e,t){for(const r of e.values)yield P(r,e.blockHeight,t)}function*O(e,t){for(let r=e.values.length-1;r>=0;r-=1)yield P(e.values[r],e.blockHeight,t)}function*C(e,t){const{values:r}=e;if(r.length>0){const n=r[r.length-1];yield P(n,e.blockHeight,t)}}async function*N(){let e,t;for(;;){const r=await m();if(r===e){await(0,a.E)(u).jitter(l);continue}const n=await I(r);if(0===n.length){await(0,a.E)(u).jitter(l);continue}const o=$(r,n);e=r,void 0!==t&&J(t,n)||(yield*C(o,r),t=n)}}async function*j(e){let t;for(assert.typeof(e,"number");;){if(t=await I(e),0!==t.length){const r=$(e,t);yield*x(r,e);break}await(0,a.E)(u).jitter(l),e=await m()}for(;;){const r=await m();if(r<=e){await(0,a.E)(u).jitter(l);continue}let n=r,o=await I(n);if(0===o.length){await(0,a.E)(u).jitter(l);continue}let s=$(n,o);const i=o,c=[];for(;n>e;){if(s.blockHeight>n){const{storeName:e,storeSubkey:t}=await d;throw new Error(`Corrupt storage cell for ${e} under key ${t} at block-height ${n} claims to being published at a later block height ${s.blockHeight}`)}const t=s.blockHeight-1;if(t<=e)break;const r=await I(t);if(0===r.length)break;const a=$(t,r);J(r,o)||c.push(s),o=r,s=a,n=t}for(J(o,t)||c.push(s);;){const e=c.pop();if(void 0===e)break;yield*x(e,r)}e=r,t=i}}async function*A(e){let t;for(;e>0;){if(t=await I(e),0===t.length)return;const r=$(e,t);yield*O(r,e),e=r.blockHeight-1}}return(0,a.cI)("chain follower",{getLatestIterable:async()=>N(),async getEachIterable(){let{height:e}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return void 0===e&&(e=await m()),j(e)},async getReverseIterable(){let{height:e}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return void 0===e&&(e=await m()),A(e)}})}(n,t,r):(e=>{const t=e=>harden({value:e,blockHeight:NaN,currentBlockHeight:NaN});return(0,a.cI)("subscription/notifier follower",{getLatestIterable:async()=>{const{notifier:r,subscription:n}=await e;let a;return r?a=E(r):(assert(n),a=S(n)),k(a,t)},getEachIterable:async()=>{const{notifier:r,subscription:n}=await e;let a;return n?a=S(n):(assert(r),a=E(r)),k(a,t)},getReverseIterable:async()=>{throw Error("reverse iteration not implemented for subscription follower")}})})(n)},_="no smart wallet",Q=async e=>{const t=(0,a.E)(e).getReverseIterable(),r=await(0,a.E)(t)[Symbol.asyncIterator](),n=await r.next();n.done&&!n.value&&assert.fail(_)};var X=r(7092),Y=r(603);const{details:ee,quote:te}=assert,re=e=>"string"===typeof e&&!!e.match(/^board[^:]/),ne=(e,t,r)=>`${t}:${`${r}`}`,ae=(e,t)=>Object.keys(e).find(t),oe=(e,t)=>{const r=ae(e,(e=>t.startsWith(`${e}:`)));return{kind:r,id:r?Number(t.slice(r.length+1)):NaN}},se=(e,t,r)=>{e.bySlot.init(t,r),e.byVal.init(r,t)},ie=e=>{const t=`SEVERED: ${e.replace(/^Alleged: /,"")}`;return(0,o.cI)(t,{})},ce=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:ie;const t={purse:{bySlot:(0,X.WS)(),byVal:(0,X.WS)()},payment:{bySlot:(0,X.WS)(),byVal:(0,X.WS)()},unknown:{bySlot:(0,X.WS)(),byVal:(0,X.WS)()}},r={bySlot:(0,X.WS)(),byVal:(0,X.WS)()},n=(t,r,n)=>{if(t.bySlot.has(r))return t.bySlot.get(r);const a=e(n);return se(t,r,a),a},a={fromBoard:(e,t)=>(assert(re(e),ee`bad board slot ${te(e)}`),n(r,e,t)),fromMyWallet:(r,o)=>{if(!r)return e(`${r}`);const{kind:s,id:i}=oe(t,r);return s?n(t[s],i,o):a.fromBoard(r,o)}},s={fromBoard:e=>r.byVal.get(e),fromMyWallet:e=>{const r=ae(t,(r=>t[r].byVal.has(e)));assert(r,ee`cannot serialize unregistered ${e}`);const n=t[r].byVal.get(e);return ne(0,r,n)}},i={fromBoard:(0,o.AU)(s.fromBoard,a.fromBoard,{marshalName:"fromBoard"}),fromMyWallet:(0,o.AU)(s.fromMyWallet,a.fromMyWallet,{marshalName:"fromMyWallet"})};return harden({initBoardId:(e,t)=>{se(r,e,t)},ensureBoardId:(e,t)=>{r.byVal.has(t)?assert.equal(r.byVal.get(t),e):se(r,e,t)},fromMyWallet:(0,o.cI)("wallet marshaller",{...i.fromMyWallet}),fromBoard:(0,o.cI)("board marshaller",{...i.fromBoard})})};var le=r(4275),de=r(3276),ue=r(3617),fe=r(7141),ge=r(3770);const pe=e=>{const t=new Map,r=r=>{const{key:n,newValue:a}=r;n&&a&&((r,n)=>{const a=JSON.parse(r);assert(Array.isArray(a));const[o,s,i,c]=a,l=JSON.parse(n);if("out"!==o||!l||"string"!==typeof l.type)return;const d={...l,dappOrigin:s},u=JSON.stringify([s,i]);let f,g;if(t.has(u))[f,g]=t.get(u)||assert.fail();else{const t=e=>{console.debug("WalletConnect: message -> storage",e),window.localStorage.setItem(JSON.stringify(["in",s,i,g]),JSON.stringify(e)),g+=1},r=()=>(0,Y.E)(e).getScopedBridge(s,s);console.debug("new capTP connection",{origin:s,epoch:i}),f=(0,ge.Ol)(`from ${s} at ${i}`,t,r),g=0}t.set(u,[f,g+1]),console.debug("WalletConnect: storage -> dispatch",d),f.dispatch(d),window.localStorage.removeItem(r)})(n,a)};return window.addEventListener("storage",r),()=>{window.removeEventListener("storage",r);for(const[e,r]of t.values())e.abort(Error("wallet connection cancelled"))}};var he=r(8690),me=r(5155);const ye="DAPPS",be=e=>{var t;return null!==(t=(0,me.K)([ye,e]))&&void 0!==t?t:[]},we=e=>{const t=new Map,{notifier:r,updater:a}=(0,n.Gm)(),o=()=>a.updateState([...t.values()]),s=r=>{t.set(r.origin,r),((e,t)=>{var r;const{origin:n,enable:a,petname:o}=t,s=null!==(r=be(e))&&void 0!==r?r:[];(0,me.A)([ye,e],[...s.filter((e=>e.origin!==n)),{origin:n,enable:a,petname:o,id:n,meta:{id:n}}])})(e,r),o()},i=r=>{t.delete(r),((e,t)=>{var r;const n=null!==(r=be(e))&&void 0!==r?r:[];(0,me.A)([ye,e],n.filter((e=>e.origin!==t)))})(e,r),o()},c=(e,r)=>{const n=t.get(e);assert(n,`Tried to set petname on undefined dapp ${e}`),s({...n,petname:r})},l=e=>{const r=t.get(e);assert(r,`Tried to enable undefined dapp ${e}`),s({...r,enable:!0})};return be(e).forEach((e=>{let r;const n=new Promise((t=>{r=()=>{l(e.origin),t()}}));t.set(e.origin,{...e,approvedP:n,actions:{enable:r,setPetname:t=>c(e.origin,t),delete:()=>i(e.origin)}}),e.enable&&r()})),o(),{dapps:t,notifier:r,addDapp:s,setDappPetname:c,deleteDapp:i,enableDapp:l}},ve=e=>{const t=new Map,{notifier:r,updater:a}=(0,n.Gm)(),o=()=>a.updateState([...t.values()]),s=e=>{assert(t.has(e),`Tried to delete undefined issuer suggestion ${e}`),t.delete(e),o()};return{notifier:r,addSuggestion:(r,n)=>{t.set(n,{boardId:n,petname:r,actions:{delete:()=>s(n),accept:async t=>{const r=JSON.stringify({type:"suggestIssuer",data:{boardId:n,petname:t}});try{await e(r),s(n)}catch(a){console.error("Sign spend action failed",r)}}}}),o()}}},Ee="OFFERS",Se=e=>{var t;return null!==(t=(0,me.K)([Ee,e]))&&void 0!==t?t:[]},ke=(e,t)=>{var r;const n=null!==(r=Se(e))&&void 0!==r?r:[];(0,me.A)([Ee,e],n.filter((e=>e.id!==t)))},Ie=(e,t,r)=>{const a=new Map;let o=[];const{notifier:s,updater:i}=(0,n.Gm)(),c=()=>i.updateState([...a.values(),...o]),l=t=>{a.set(t.id,t),((e,t)=>{var r;const n=null!==(r=Se(e))&&void 0!==r?r:[];(0,me.A)([Ee,e],[...n.filter((e=>e.id!==t.id)),t])})(e,t),c()};Se(e).forEach((t=>{"decline"===t.status&&ke(e,t.id),a.set(t.id,{...t})})),c();return(async()=>{for await(const t of(0,n.oV)(r))null===t||void 0===t||t.forEach((r=>{let{id:n}=r;a.has(n)&&(a.delete(n),ke(e,n)),o=t,c()}))})(),{offers:a,notifier:s,addOffer:l,acceptOffer:async e=>{const r=a.get(e);return assert(r,`Tried to accept undefined offer ${e}`),t(r.spendAction)},cancelOffer:e=>{console.log("TODO: cancel offer")},declineOffer:e=>{const t=a.get(e);assert(t,`Tried to decline undefined offer ${e}`),l({...t,status:"decline"}),c()}}},$e=(e,t,r)=>{const{getPursesNotifier:n,dappService:a,offerService:o,issuerService:s,unserializer:i,networkConfig:c}=r,{dapps:l,addDapp:d,setDappPetname:u,deleteDapp:f,enableDapp:g}=a,p=t=>u(e,t);let h=l.get(e);if(!h){let r;const n=new Promise((t=>{r=()=>{g(e),t()}}));h={id:e,meta:{id:e},petname:t,origin:e,enable:!1,actions:{enable:r,setPetname:p,delete:()=>f(e)},approvedP:n},d(h)}return(0,ge.cI)("scoped bridge",{async addOffer(t){const r=(new Date).getTime(),n=r;return await h.approvedP,o.addOffer({id:n,instancePetname:`instance@${t.instanceHandleBoardId}`,requestContext:{dappOrigin:e,origin:e},meta:{id:n,creationStamp:r},status:"proposed",...t}),n},async suggestIssuer(e,t){await h.approvedP,s.addSuggestion(e,t)},async suggestInstallation(e,t){await h.approvedP,console.log("TODO: suggest installation",e,t)},async suggestInstance(e,t){await h.approvedP,console.log("TODO: suggest instance",e,t)},getPursesNotifier:async()=>(await h.approvedP,n()),getOffersNotifier:async()=>(await h.approvedP,o.notifier),getUnserializer:async()=>(await h.approvedP,i),getNetConfig:async()=>(await h.approvedP,c)})},Pe=e=>`${e}${Math.random()}`;var xe=r(6758),Oe=r(5867),Ce=r(18),Ne=r(7152),je=r(2571),Ae=r(8174),Be=r(6794),Me=r(6246),Te=r(9419),We=r(5030);const He=0,De=1,Ze=2,ze="Cannot sign a transaction in read only mode, connect to keplr.",Ve=100n*1000000n,Ue=(e,t)=>{const[r,n]=(0,ue.useState)(null);return(0,ue.useEffect)((()=>{let r=!1;return(async()=>{const o=await G(":published.provisionPool.metrics",t,{unserializer:e});for await(const{value:e}of(e=>(0,a.cI)("iterateLatest iterable",{[Symbol.asyncIterator]:()=>{const t=(0,a.E)(e).getLatestIterable(),r=(0,a.E)(t)[Symbol.asyncIterator]();return(0,a.cI)("iterateLatest iterator",{next:()=>(0,a.E)(r).next()})}}))(o)){if(r)break;console.log("provisionPoolData",e),n(e)}})().catch((e=>console.error("useProvisionPoolMetrics fetchData error",e))),()=>{r=!0}}),[e,t]),r},Le=(0,fe.LW)((e=>{let{onClose:t,open:r,address:n,href:a,keplrConnection:o,unserializer:s,leader:i}=e;const[c,l]=(0,ue.useState)(He),[d,u]=(0,ue.useState)(null),f=Ue(s,i),g=e=>(0,We.jsxs)(Me.Z,{children:[(0,We.jsx)(Me.Z,{sx:{margin:"auto",display:"flex",flexDirection:"row",justifyContent:"center"},children:(0,We.jsx)(xe.Z,{})}),(0,We.jsx)(je.Z,{sx:{pt:2},children:e})]}),p=(0,ue.useMemo)((()=>{switch(c){case He:return(0,We.jsxs)("div",{children:[(0,We.jsxs)(je.Z,{children:[(0,We.jsx)("b",{children:"Network Config"}),":"," ",(0,We.jsx)(Te.Z,{href:a,underline:"none",color:"rgb(0, 176, 255)",children:a})]}),(0,We.jsxs)(je.Z,{sx:{pt:2},children:[(0,We.jsx)("b",{children:"Wallet Address:"})," ",n]}),(0,We.jsxs)(je.Z,{sx:{pt:2},children:["There is no smart wallet provisioned for this address yet. A fee of ",(0,We.jsx)("b",{children:"10 BLD"})," is required to create one."]})]});case De:return g("Please approve the transaction in Keplr.");case Ze:return g("Awaiting smart wallet creation...");default:return(0,We.jsx)(We.Fragment,{})}}),[c,a,n]),h=null!==f&&(e=>e&&he.iU.subtract(e.totalMintedConverted,e.totalMintedProvided).value<Ve)(f);return(0,We.jsxs)(Oe.Z,{open:r,children:[(0,We.jsxs)(Ce.Z,{children:[c===He?"Create a":"Creating"," Smart Wallet"]}),(0,We.jsxs)(Ne.Z,{children:[p,h&&(0,We.jsx)(je.Z,{sx:{pt:2},color:"error",children:"The pool of funds to provision smart wallets is too small at this time."}),d&&(0,We.jsx)(je.Z,{sx:{pt:2},color:"error",children:d})]}),c===He&&(0,We.jsxs)(Ae.Z,{children:[(0,We.jsx)(Be.Z,{color:"inherit",onClick:t,children:"Change Connection"}),(0,We.jsx)(Be.Z,{disabled:!f||h,onClick:()=>{const{signers:{interactiveSigner:e}}=o;e?(async e=>{u(null),l(De);try{await e.submitProvision()}catch(t){return l(He),void u(t.message)}l(Ze)})(e):u(ze)},children:"Create"})]})]})}),(e=>({keplrConnection:e.keplrConnection}))),Re=ue.forwardRef((function(e,t){let{children:r,...n}=e;return(0,We.jsx)(le.Z,{elevation:6,ref:t,variant:"filled",...n,children:r})})),Je=(0,fe.LW)((e=>{var t,r;let{connectionConfig:a,setConnectionStatus:s,setBackend:i,setBackendErrorHandler:c,keplrConnection:l}=e;const[d,u]=(0,ue.useState)([]),[f,g]=(0,ue.useState)(!1),p=function(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"error";t&&(console.error(`${e}:`,t),e+=`: ${t.message}`),"error"===r&&s(fe.QK.Error),u((t=>[...t,{severity:r,message:e}]))},{href:h}=a,m=(()=>{if(l)return l.address})(),y=e=>{e.message===_?(g(!0),s(fe.QK.Error)):(i(null),p("Error in wallet backend",e))},[b,w]=(0,ue.useMemo)((()=>[ce(),v(h)]),[a,l]);return(0,ue.useEffect)((()=>{if(!a||!l)return;let e,t;return(async()=>{const r=e=>G(`:published.${e}`,w,{unserializer:b.fromMyWallet}),a=function(e,t,r,a,s,i,c){let l=arguments.length>7&&void 0!==arguments[7]?arguments[7]:e=>{throw e},d=arguments.length>8&&void 0!==arguments[8]?arguments[8]:()=>{};const u={getPursesNotifier:"purses",getContactsNotifier:"contacts",getIssuersNotifier:"issuers",getOffersNotifier:"offers",getPaymentsNotifier:"payments"},f=Object.fromEntries(Object.entries(u).map((e=>{let[t,r]=e;return[r,(0,n.Gm)(null)]}))),g={},p=new Map,h=new Map,m=()=>{const e=[];for(const[t,r]of p.entries())r.currentAmount&&r.brandPetname&&(assert(r.pursePetname,"missing purse.pursePetname"),h.set(r.pursePetname,t),e.push(r));f.purses.updater.updateState(harden(e))},y=async()=>{await Q(e);const t=(await(0,Y.E)(e).getLatestIterable())[Symbol.asyncIterator](),r=await t.next();d&&(d(),Object.values(f).forEach((e=>{let{updater:t}=e;return t.updateState([])})),d=void 0);const n=r.value,a=n.value;for(const e of a.purses){console.debug("registering purse",e);const t=a.brands.find((t=>e.brand===t.brand));assert(t,`missing descriptor for brand ${e.brand}`);const r={brand:e.brand,currentAmount:e.balance,brandPetname:t.petname,pursePetname:t.petname,displayInfo:t.displayInfo};p.set(e.brand,r)}return console.debug("brandToPurse map",p),m(),n.blockHeight},b=async e=>{for await(const{value:r}of I(t,{height:e})){const e=r;switch(e.updated){case"brand":{const{descriptor:{brand:t,petname:r,displayInfo:n}}=e,a=p.get(t),o={brand:t,brandPetname:r,pursePetname:r,displayInfo:n,currentAmount:(null===a||void 0===a?void 0:a.currentAmount)||he.iU.makeEmpty(t)};p.set(t,o),m();break}case"balance":{const{currentAmount:t}=e,r={...p.get(t.brand),currentAmount:t,value:t.value};p.set(t.brand,r),m();break}case"offerStatus":{const{status:t}=e;console.log("offerStatus",{status:t,offers:g});const r=g[t.id];if(!r){console.warn("Update for unknown offer, doing nothing.");break}"error"in t?g[t.id]={...r,id:t.id,status:"rejected",error:`${t.error}`}:"accept"!==r.status&&"numWantsSatisfied"in t&&(g[t.id]={...r,id:t.id,status:"accept"}),f.offers.updater.updateState(harden(Object.values(g)));break}default:throw Error(`Unknown updateRecord ${e.updated}`)}}},w=()=>y().then(b),v=()=>{w().catch((e=>{e.message===_?setTimeout(v,5e3):l(e)}))};w().catch((e=>{l(e),e.message===_&&setTimeout(v,5e3)}));const E=Object.fromEntries(Object.entries(u).map((e=>{let[t,r]=e;const{notifier:n}=f[r];return[t,()=>n]}))),S=()=>{console.log("make empty purse")},k=()=>{console.log("add contact")},$=()=>{console.log("add issuer")},P=e=>{const{signers:{interactiveSigner:t}}=i;if(!t)throw new Error("Cannot sign a transaction in read only mode, connect to keplr.");return t.submitSpendAction(e)},x=ve(P),O=we(s),C=Ie(s,P,E.getOffersNotifier()),{acceptOffer:N,declineOffer:j,cancelOffer:A}=C,B=async e=>{const{id:t,instanceHandleBoardId:r,invitationMaker:{method:n},proposalTemplate:{give:o,want:s}}=e,i=e=>Object.fromEntries(Object.entries(e).map((e=>{let[t,{brand:r,pursePetname:n,value:a}]=e;return[t,{brand:r||h.get(n),value:BigInt(a)}]}))),c={id:(new Date).getTime(),invitationSpec:{source:"contract",instance:r,publicInvitationMaker:n},proposal:{give:i(o),want:i(s)}},l=await(0,Y.E)(a).serialize(harden({method:"executeOffer",offer:c})),{slots:[d]}=await(0,Y.E)(a).serialize(r),u={...e,instancePetname:`instance@${d}`,spendAction:JSON.stringify(l)};return C.addOffer(u),g[t]=u,t};return(0,o.cI)("follower wallet bridge",{...E,getDappsNotifier:()=>O.notifier,getOffersNotifier:()=>C.notifier,getIssuerSuggestionsNotifier:()=>x.notifier,acceptOffer:N,declineOffer:j,cancelOffer:A,makeEmptyPurse:S,addContact:k,addIssuer:$,getScopedBridge:(e,t)=>$e(e,t,{dappService:O,offerService:{...C,addOffer:B},leader:r,unserializer:a,publicAddress:s,issuerService:x,networkConfig:c,...E})})}(r(`wallet.${m}.current`),r(`wallet.${m}`),w,b.fromBoard,m,l,h,y,(()=>{s(fe.QK.Connected),g(!1)})),{backendIt:d,cancel:u}=(e=>{const t=async e=>(0,n.oV)(e)[Symbol.asyncIterator](),{notifier:r}=(0,n.Gm)(harden({board:(0,Y.E)(e).getBoard()})),a=harden({actions:(0,o.cI)("schemaActions",{createPurse:function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Pe("Purse");return(0,Y.E)(e).makeEmptyPurse(null===t||void 0===t?void 0:t.issuerPetname,r)},createContact:function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Pe("Contact");return(0,Y.E)(e).addContact(r,t)},createIssuer:function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Pe("Issuer");return(0,Y.E)(e).addIssuer(r,t,!0)}}),services:t(r),contacts:t((0,Y.E)(e).getContactsNotifier()),dapps:t((0,Y.E)(e).getDappsNotifier()),issuers:t((0,Y.E)(e).getIssuersNotifier()),offers:(s=t((0,Y.E)(e).getOffersNotifier()),harden({next:async()=>{const{done:t,value:r}=await(0,Y.E)(s).next();return harden({done:t,value:r&&r.map((t=>{let{id:r,...n}=t;return harden({id:r,...n,actions:(0,o.cI)("offerActions",{accept:()=>(0,Y.E)(e).acceptOffer(r),decline:()=>(0,Y.E)(e).declineOffer(r),cancel:()=>(0,Y.E)(e).cancelOffer(r)})})}))})},return:s.return,throw:s.throw})),payments:t((0,Y.E)(e).getPaymentsNotifier()),purses:t((0,Y.E)(e).getPursesNotifier()),issuerSuggestions:t((0,Y.E)(e).getIssuerSuggestionsNotifier())});var s;const{notifier:i,updater:c}=(0,n.Gm)(a);return{backendIt:t(i),cancel:e=>{c.fail(e)}}})(a);return t=pe(a),e=u,c((()=>y)),(0,n.uO)(d,{updateState:t=>{e&&i(t)},fail:t=>{e&&y(t)},finish:t=>{e&&i(t)}})})().catch((e=>p("Cannot read Smart Wallet casting",e))),()=>{e&&e(),e=void 0,t&&t(),t=void 0}}),[a,l]),(0,We.jsxs)("div",{children:[(0,We.jsx)(de.Z,{open:d.length>0,children:(0,We.jsx)(Re,{onClose:(e,t)=>{"clickaway"!==t&&u((e=>e.slice(1)))},severity:null===(t=d[0])||void 0===t?void 0:t.severity,sx:{width:"100%"},children:null===(r=d[0])||void 0===r?void 0:r.message})}),(0,We.jsx)(Le,{open:f,onClose:()=>{g(!1)},address:m,href:h,unserializer:b.fromBoard,leader:w})]})}),(e=>({connectionConfig:e.connectionConfig,setConnectionStatus:e.setConnectionStatus,setBackend:e.setBackend,setBackendErrorHandler:e.setBackendErrorHandler,keplrConnection:e.keplrConnection})))}}]);
//# sourceMappingURL=47.9389dc00.chunk.js.map