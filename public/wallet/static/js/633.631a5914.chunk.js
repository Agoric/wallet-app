"use strict";(globalThis.webpackChunk_agoric_wallet_ui=globalThis.webpackChunk_agoric_wallet_ui||[]).push([[633],{4139:(e,t,n)=>{n.d(t,{g:()=>s});var r=n(3770),a=n(603);const s=e=>{const t=new Map,n=n=>{const{key:s,newValue:o}=n;s&&o&&((n,s)=>{const o=JSON.parse(n);assert(Array.isArray(o));const[i,c,l,d]=o,u=JSON.parse(s);if("out"!==i||!u||"string"!==typeof u.type)return;const f={...u,dappOrigin:c},g=JSON.stringify([c,l]);let p,h;if(t.has(g))[p,h]=t.get(g)||assert.fail();else{const t=e=>{console.debug("WalletConnect: message -> storage",e),window.localStorage.setItem(JSON.stringify(["in",c,l,h]),JSON.stringify(e)),h+=1},n=()=>(0,a.E)(e).getScopedBridge(c,c);console.debug("new capTP connection",{origin:c,epoch:l}),p=(0,r.Ol)(`from ${c} at ${l}`,t,n),h=0}t.set(g,[p,h+1]),console.debug("WalletConnect: storage -> dispatch",f),p.dispatch(f),window.localStorage.removeItem(n)})(s,o)};return window.addEventListener("storage",n),()=>{window.removeEventListener("storage",n);for(const[e,n]of t.values())e.abort(Error("wallet connection cancelled"))}}},6525:(e,t,n)=>{n.d(t,{q:()=>v,F:()=>b});var r=n(603),a=n(6912),s=n(3876),o=n(4532),i=n(3770);const c=(e,t,n)=>{const{getPursesNotifier:r,dappService:a,offerService:s,issuerService:o,unserializer:c,networkConfig:l}=n,{dapps:d,addDapp:u,setDappPetname:f,deleteDapp:g,enableDapp:p}=a,h=t=>f(e,t);let y=d.get(e);if(!y){let n;const r=new Promise((t=>{n=()=>{p(e),t()}}));y={id:e,meta:{id:e},petname:t,origin:e,enable:!1,actions:{enable:n,setPetname:h,delete:()=>g(e)},approvedP:r},u(y)}return(0,i.cI)("scoped bridge",{async addOffer(t){const n=(new Date).getTime(),r=`${n}`;return await y.approvedP,s.addOffer({id:r,instancePetname:`instance@${t.instanceHandleBoardId}`,requestContext:{dappOrigin:e,origin:e},meta:{id:`${n}`,creationStamp:n},status:"proposed",...t}),r},async suggestIssuer(e,t){await y.approvedP,o.addSuggestion(e,t)},async suggestInstallation(e,t){await y.approvedP,console.log("TODO: suggest installation",e,t)},async suggestInstance(e,t){await y.approvedP,console.log("TODO: suggest instance",e,t)},getPursesNotifier:async()=>(await y.approvedP,r()),getOffersNotifier:async()=>(await y.approvedP,s.notifier),getUnserializer:async()=>(await y.approvedP,c),getNetConfig:async()=>(await y.approvedP,l)})};var l=n(5155);const d="DAPPS",u=e=>{var t;return null!==(t=(0,l.K)([d,e]))&&void 0!==t?t:[]},f=e=>{const t=new Map,{notifier:n,updater:r}=(0,s.Gm)(),a=()=>r.updateState([...t.values()]),o=n=>{t.set(n.origin,n),((e,t)=>{var n;const{origin:r,enable:a,petname:s}=t,o=null!==(n=u(e))&&void 0!==n?n:[];(0,l.A)([d,e],[...o.filter((e=>e.origin!==r)),{origin:r,enable:a,petname:s,id:r,meta:{id:r}}])})(e,n),a()},i=n=>{t.delete(n),((e,t)=>{var n;const r=null!==(n=u(e))&&void 0!==n?n:[];(0,l.A)([d,e],r.filter((e=>e.origin!==t)))})(e,n),a()},c=(e,n)=>{const r=t.get(e);assert(r,`Tried to set petname on undefined dapp ${e}`),o({...r,petname:n})},f=e=>{const n=t.get(e);assert(n,`Tried to enable undefined dapp ${e}`),o({...n,enable:!0})};return u(e).forEach((e=>{let n;const r=new Promise((t=>{n=()=>{f(e.origin),t()}}));t.set(e.origin,{...e,approvedP:r,actions:{enable:n,setPetname:t=>c(e.origin,t),delete:()=>i(e.origin)}}),e.enable&&n()})),a(),{dapps:t,notifier:n,addDapp:o,setDappPetname:c,deleteDapp:i,enableDapp:f}},g="OFFERS",p=e=>{var t;return null!==(t=(0,l.K)([g,e]))&&void 0!==t?t:[]},h=(e,t)=>{var n;const r=null!==(n=p(e))&&void 0!==n?n:[];(0,l.A)([g,e],r.filter((e=>e.id!==t)))},y=(e,t,n)=>{const r=new Map;let a=[];const{notifier:o,updater:i}=(0,s.Gm)(),c=()=>i.updateState([...r.values(),...a]),d=t=>{r.set(t.id,t),((e,t)=>{var n;const r=null!==(n=p(e))&&void 0!==n?n:[];(0,l.A)([g,e],[...r.filter((e=>e.id!==t.id)),t])})(e,t),c()};p(e).forEach((t=>{"decline"===t.status&&h(e,t.id),r.set(t.id,{...t})})),c();return(async()=>{for await(const t of(0,s.oV)(n))null===t||void 0===t||t.forEach((n=>{const s=n.id.split("#"),o=s[s.length-1];r.has(o)&&(r.delete(o),h(e,o)),a=t,c()}))})(),{offers:r,notifier:o,addOffer:d,acceptOffer:async e=>{const n=r.get(e);assert(n,`Tried to accept undefined offer ${e}`);const a=JSON.stringify({type:"acceptOffer",data:n});return t(a)},cancelOffer:e=>{console.log("TODO: cancel offer")},declineOffer:e=>{const t=r.get(e);assert(t,`Tried to decline undefined offer ${e}`),d({...t,status:"decline"}),c()}}},w=e=>{const t=new Map,{notifier:n,updater:r}=(0,s.Gm)(),a=()=>r.updateState([...t.values()]),o=e=>{assert(t.has(e),`Tried to delete undefined issuer suggestion ${e}`),t.delete(e),a()};return{notifier:n,addSuggestion:(n,r)=>{t.set(r,{boardId:r,petname:n,actions:{delete:()=>o(r),accept:async t=>{const n=JSON.stringify({type:"suggestIssuer",data:{boardId:r,petname:t}});try{await e(n),o(r)}catch(a){console.error("Sign spend action failed",n)}}}}),a()}}},m=e=>`${e}${Math.random()}`,v=e=>{const t=async e=>(0,s.oV)(e)[Symbol.asyncIterator](),{notifier:n}=(0,s.Gm)(harden({board:(0,r.E)(e).getBoard()})),o=harden({actions:(0,a.cI)("schemaActions",{createPurse:function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:m("Purse");return(0,r.E)(e).makeEmptyPurse(null===t||void 0===t?void 0:t.issuerPetname,n)},createContact:function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:m("Contact");return(0,r.E)(e).addContact(n,t)},createIssuer:function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:m("Issuer");return(0,r.E)(e).addIssuer(n,t,!0)}}),services:t(n),contacts:t((0,r.E)(e).getContactsNotifier()),dapps:t((0,r.E)(e).getDappsNotifier()),issuers:t((0,r.E)(e).getIssuersNotifier()),offers:(i=t((0,r.E)(e).getOffersNotifier()),harden({next:async()=>{const{done:t,value:n}=await(0,r.E)(i).next();return harden({done:t,value:n&&n.map((t=>{let{id:n,...s}=t;return harden({id:n,...s,actions:(0,a.cI)("offerActions",{accept:()=>(0,r.E)(e).acceptOffer(n),decline:()=>(0,r.E)(e).declineOffer(n),cancel:()=>(0,r.E)(e).cancelOffer(n)})})}))})},return:i.return,throw:i.throw})),payments:t((0,r.E)(e).getPaymentsNotifier()),purses:t((0,r.E)(e).getPursesNotifier()),issuerSuggestions:t((0,r.E)(e).getIssuerSuggestionsNotifier())});var i;const{notifier:c,updater:l}=(0,s.Gm)(o);return{backendIt:t(c),cancel:e=>{l.fail(e)}}},b=function(e,t,n,r,i,l){let d=arguments.length>6&&void 0!==arguments[6]?arguments[6]:e=>{throw e},u=arguments.length>7?arguments[7]:void 0;const g={getPursesNotifier:"purses",getContactsNotifier:"contacts",getIssuersNotifier:"issuers",getOffersNotifier:"offers",getPaymentsNotifier:"payments"},p=Object.fromEntries(Object.entries(g).map((e=>{let[t,n]=e;return[n,(0,s.Gm)(null)]}))),h=async()=>{for await(const{value:t}of(0,o.DC)(e))u&&(u(),u=void 0),Object.entries(p).forEach((e=>{let[n,{updater:r}]=e;r.updateState(t[n])}))};h().catch(d);const m=Object.fromEntries(Object.entries(g).map((e=>{let[t,n]=e;const{notifier:r}=p[n];return[t,()=>r]}))),v=()=>{console.log("make empty purse")},b=()=>{console.log("add contact")},E=()=>{console.log("add issuer")},I=e=>{const{signers:{interactiveSigner:t}}=i;if(!t)throw new Error("Cannot sign a transaction in read only mode, connect to keplr.");return t.submitSpendAction(e)},O=w(I),S=f(r),P=y(r,I,m.getOffersNotifier()),{acceptOffer:N,declineOffer:$,cancelOffer:A}=P,C=(0,a.cI)("follower wallet bridge",{...m,getDappsNotifier:()=>S.notifier,getOffersNotifier:()=>P.notifier,getIssuerSuggestionsNotifier:()=>O.notifier,acceptOffer:N,declineOffer:$,cancelOffer:A,makeEmptyPurse:v,addContact:b,addIssuer:E,getScopedBridge:(e,a)=>c(e,a,{dappService:S,offerService:P,leader:t,unserializer:n,publicAddress:r,issuerService:O,networkConfig:l,...m})});return C}},4532:(e,t,n)=>{n.d(t,{DC:()=>S,pu:()=>G,$7:()=>b});var r=n(3876),a=n(7017),s=n(6912);const o="http://localhost:26657",i=e=>new Promise((t=>setTimeout(t,e))),c=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e;return Math.random()*Math.min(t,e)},l=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3e4;return c(2**e*t,n)},d=e=>{const t=c(5e3);return console.warn(`jittering ${e} by ${Math.ceil(t)}ms`),i(t)},u=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const r=l(n);return console.warn(`retrying ${e} in ${Math.ceil(r)}ms after attempt #${n}`,t),i(r)},f=()=>i(c(5e3)).then((()=>!0)),g=()=>{const e=new TextDecoder;return harden((t=>{const n=e.decode(t);return harden(JSON.parse(n))}))},p=()=>{const e="Alleged: ",t=new Map;return(0,a.cI)("marshal unserializer",{unserialize:(0,s.AU)(void 0,((n,r)=>{if(t.has(n))return t.get(n);"string"===typeof r&&r.startsWith(e)&&(r=r.slice(e.length));const s=(0,a.cI)(`SEVERED: ${r}`,{});return t.set(n,s),s})).unserialize})},h=e=>{for(let t=e.length-1;t>0;t-=1){const n=Math.floor(Math.random()*(t+1)),r=e[t];e[t]=e[n],e[n]=r}},y=async e=>{const{keepPolling:t=f}=await(0,a.E)(e).getOptions(),n=(0,a.cI)("polling change follower iterable",{[Symbol.asyncIterator]:()=>{let n;return(0,a.cI)("polling change follower iterator",{next:async()=>{n||(n=t("polling change follower").then((t=>t?(0,a.E)(e).jitter("polling change follower").then((()=>t)):t)));const r=await n;n=void 0;const s=harden({values:[]});return harden({value:s,done:!r})}})}});return(0,a.cI)("polling change follower",{getLatestIterable:async()=>n,getEachIterable:async()=>n})},{details:w}=assert,m=(e,t)=>{assert(Array.isArray(e),w`rpcAddrs ${e} must be an array`);return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{retryCallback:n=u,jitter:r=d}=t;h(e);let s,o=0,i=0;const c=(0,a.cI)("round robin leader",{getOptions:()=>t,jitter:async e=>r&&r(e),retry:async(e,t,r)=>{if(n)return n(e,t,r);throw t},watchCasting:e=>l,mapEndpoints:async(t,n)=>(t=`${t} (round-robin endpoints)`,new Promise(((l,d)=>{let u=o;const f=n=>{if(!s){const r=i;s=(0,a.E)(c).retry(t,n,r).then((()=>{u=(u+1)%e.length,s=null}))}s.then((()=>r&&r(t))).then(g,d),i+=1},g=()=>{Promise.resolve().then((()=>n(e[u]))).then((e=>{l(harden([e])),o=u,i=0}),f)};g()})))}),l=y(c);return c}(e.map((e=>(assert.typeof(e,"string",w`rpcAddr ${e} must be a string`),e.includes("://")?e:`http://${e}`))),t)},v=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{retryCallback:n=u,jitter:r=d}=t,a=async(e,t,r)=>{if(n)return n(e,t,r);throw t};let s=0;const o="Network config leader";return new Promise(((n,i)=>{const c=async()=>{const n=await fetch(e,{headers:{accept:"application/json"}}),{rpcAddrs:r}=await n.json();return s=0,m(r,t)},l=async e=>{a(o,e,s).then((()=>r(o))).then((()=>c().then(n,l))).catch(i),s+=1};c().then(n,l)}))},b=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:o,t=arguments.length>1?arguments[1]:void 0;return e.includes("network-config")?v(e,t):m([e],t)},E=e=>(0,r.a2)((0,a.E)(e).getSharableNotifierInternals()),I=e=>harden({[Symbol.asyncIterator]:()=>{return t=(0,a.E)(e).getSharableSubscriptionInternals(),(0,a.cI)("SubscriptionIterator",{next:async()=>{const e=a.E.get(t).head;return t=a.E.get(t).tail,e}});var t}}),O=(e,t)=>async function*(){for await(const n of e)yield t(n)}(),S=e=>(0,a.cI)("iterateLatest iterable",{[Symbol.asyncIterator]:()=>{const t=(0,a.E)(e).getEachIterable(),n=(0,a.E)(t)[Symbol.asyncIterator]();return(0,a.cI)("iterateLatest iterator",{next:()=>(0,a.E)(n).next()})}});var P=n(2039),N=n.t(P,2),$=n(6578),A=n.t($,2),C=n(2363),k=n.t(C,2);const{toAscii:T}=k,D=".".charCodeAt(0),x=new Uint8Array([0]),j=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"vstorage";const n=e?e.split("."):[],r=T(`${n.length}.${e}`);return harden({storeName:t,storeSubkey:r.map((e=>e===D?0:e)),dataPrefixBytes:x})},M=harden({"swingset:":e=>harden({storeName:"swingset",storeSubkey:T(`swingset/data:${e}`)}),"vstore:":j,":":j}),V=new TextEncoder,z=e=>{const{storeName:t,storeSubkey:n,dataPrefixBytes:r,subscription:a,notifier:s}=e;if(a||s)return harden({subscription:a,notifier:s});let o=n;"string"===typeof n&&(o=V.encode(n));let i=r;return"string"===typeof r&&(i=V.encode(r)),harden({storeName:t,storeSubkey:o,dataPrefixBytes:i})},F=async e=>{const t=await e;if("string"===typeof t)return(e=>{assert.typeof(e,"string");const t=e.match(/^([^:.]*:)(.*)/);assert(t,`spec string ${e} does not match 'PREFIX:PATH' or ':PATH'`);const n=t[1],r=t[2],a=M[n];return assert(a,`Unknown pathKind ${n}`),a(r)})(t);const{storeName:n,subscription:r,notifier:s}=t;return n||r||s?z(t):(0,a.mY)(t)?(async e=>{const t=await(0,a.E)(e).getStoreKey();return z(t)})(t):void assert.fail(`CastingSpec ${t} is not a string, object, or ref`)},{QueryClient:J}=A,{Tendermint34Client:L}=N,{details:R}=assert,U=e=>{const t=[];let n=0;for(const r of e)n+=1,1===n?t.push(r):assert.fail(`expected single value, got at least ${n}`);return assert.equal(t.length,1,"expected single value"),t[0]},q=harden({strict:async(e,t,n)=>e().catch(t),none:async(e,t,n)=>n(),optimistic:async(e,t,n)=>{const r=await n();return e().then((e=>{e.length===r.length&&e.every(((e,t)=>e===r[t]))||t(assert.error(R`Alleged value ${r} did not match proof ${e}`))}),t),r}}),B=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:b,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const{decode:s=g(),unserializer:o=p(),proof:i="optimistic",crasher:c=null}=n,l=q[i];assert(l,R`unrecognized follower proof mode ${i}`);const d="CosmJS follower",u=F(e),f="function"===typeof t?t():t,h=new Map,y=async e=>{if(h.has(e)){const t=h.get(e);return assert(t),t}const t=await L.connect(e),n=J.withExtensions(t);return h.set(e,n),n},w=e=>async t=>{const{storeName:n,storeSubkey:r,dataPrefixBytes:s=new Uint8Array}=await u;let o;switch(assert.typeof(n,"string"),assert(r),e){case"queryVerified":o=n;break;case"queryUnverified":o=`store/${n}/key`;break;default:assert.fail(R`unrecognized method ${e}`)}const i=await(0,a.E)(f).mapEndpoints(d,(async n=>{const s=await y(n);return(0,a.E)(s)[e](o,r,t).then((e=>({result:e,error:null})),(e=>({result:null,error:e})))})),{result:c,error:l}=U(i);if(null!==l)throw l;return assert(c),0===c.length?c:(assert(c.length>=s.length,R`result too short for data prefix ${s}`),assert(s.every(((e,t)=>e===c[t])),R`${c} doesn't start with data prefix ${s}`),c.slice(s.length))},m=w("queryVerified"),v=w("queryUnverified"),O=async(e,t)=>{let n=!1;const r=t=>(n=!0,e.fail(t),!1),i=e=>{r(e),c?(0,a.E)(c).crash("PROOF VERIFICATION FAILURE; crashing follower",e).catch((e=>assert(!1,R`crashing follower failed: ${e}`))):console.error("PROOF VERIFICATION FAILURE; crashing follower",e)};let g,p=0;const h=e=>new Promise(((t,n)=>{const s=e=>{p=0,t(e)},o=t=>{(async t=>{p+=1,g||(g=(0,a.E)(f).retry(d,t,p).then((()=>g=null))),await g,await(0,a.E)(f).jitter(d),b(e).then(s,o)})(t).catch((e=>{n(e),r(e)}))};b(e).then(s,o)})),y=(e=>{let t=0n,n=0n;return()=>{t+=1n;const r=t;assert(r>n);const s=(0,a.cI)("committer",{isValid:()=>r>n,commit:function(){assert(s.isValid()),n=r,e(...arguments)}});return s}})(e.updateState);let w;const b=async e=>{const t=y(),{values:n,blockHeight:c}=e,d=n.length>0?()=>Promise.resolve(n[n.length-1]):()=>v(c),u=await l((()=>m(c)),i,d);if(0===u.length)return void r(Error("No query results"));if(p=0,!t.isValid())return;if(w&&u.length===w.length&&u.every(((e,t)=>e===w[t])))return;w=u;const f=s(u);if(!o){const e=f;return void t.commit({value:e})}const g=await(0,a.E)(o).unserialize(f);t.isValid()&&t.commit({value:g})},E=(0,a.E)(f).watchCasting(u);return(async()=>{if(await h(harden({values:[]})),!n)for await(const e of S(E)){if(n)return;harden(e),await h(e)}})().catch(r),t};return(0,a.cI)("chain follower",{getLatestIterable:()=>{const{updater:e,notifier:t}=(0,r.Gm)();return O(e,E(t))},getEachIterable:()=>{const{subscription:e,publication:t}=(0,r.Iu)();return O(t,I(e))}})},G=async(e,t,n)=>{const r=await F(e),{storeName:s}=r;return s?B(r,t,n):(e=>{const t=e=>harden({value:e});return(0,a.cI)("subscription/notifier follower",{getLatestIterable:async()=>{const{notifier:n,subscription:r}=await e;let a;return n?a=E(n):(assert(r),a=I(r)),O(a,t)},getEachIterable:async()=>{const{notifier:n,subscription:r}=await e;let a;return r?a=I(r):(assert(n),a=E(n)),O(a,t)}})})(r)}}}]);
//# sourceMappingURL=633.631a5914.chunk.js.map