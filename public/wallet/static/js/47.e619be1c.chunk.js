"use strict";(globalThis.webpackChunk_agoric_wallet_ui=globalThis.webpackChunk_agoric_wallet_ui||[]).push([[47],{7047:(e,t,n)=>{n.r(t),n.d(t,{default:()=>Le});var r=n(3876),a=n(7017),o=n(2765);const s="http://localhost:26657",i=e=>new Promise((t=>setTimeout(t,e))),c=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e;return Math.random()*Math.min(t,e)},l=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3e4;return c(2**e*t,n)},d=e=>{const t=c(5e3);return console.debug(`jittering ${e} by ${Math.ceil(t)}ms`),i(t)},u=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const r=l(n);return console.log(`retrying ${e} in ${Math.ceil(r)}ms after attempt #${n}`,t),i(r)},f=()=>i(c(5e3)).then((()=>!0)),g=()=>harden((e=>{try{return harden(JSON.parse(e))}catch(t){throw new Error(`Cannot decode alleged JSON (${t.message}): ${e}`)}})),p=()=>{const e="Alleged: ",t=new Map;return(0,a.cI)("marshal unserializer",{unserialize:(0,o.AU)(void 0,((n,r)=>{if(t.has(n))return t.get(n);"string"===typeof r&&r.startsWith(e)&&(r=r.slice(e.length));const o=(0,a.cI)(`SEVERED: ${r}`,{});return t.set(n,o),o})).unserialize})},h=e=>{for(let t=e.length-1;t>0;t-=1){const n=Math.floor(Math.random()*(t+1)),r=e[t];e[t]=e[n],e[n]=r}},m=async e=>{const{keepPolling:t=f}=await(0,a.E)(e).getOptions(),n=(0,a.cI)("polling change follower iterable",{[Symbol.asyncIterator]:()=>{let n;return(0,a.cI)("polling change follower iterator",{next:async()=>{n||(n=t("polling change follower").then((t=>t?(0,a.E)(e).jitter("polling change follower").then((()=>t)):t)));const r=await n;n=void 0;const o=harden({values:[]});return harden({value:o,done:!r})}})}});return(0,a.cI)("polling change follower",{getLatestIterable:async()=>n,getEachIterable:async()=>n,getReverseIterable:async()=>{throw Error("not implemented for polling change follower")}})},{details:y}=assert,b=(e,t)=>{assert(Array.isArray(e),y`rpcAddrs ${e} must be an array`);return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{retryCallback:n=u,jitter:r=d}=t;h(e);let o,s=0,i=0;const c=(0,a.cI)("round robin leader",{getOptions:()=>t,jitter:async e=>r&&r(e),retry:async(e,t,r)=>{if(n)return n(e,t,r);throw t},watchCasting:e=>l,mapEndpoints:async(t,n)=>(t=`${t} (round-robin endpoints)`,new Promise(((l,d)=>{let u=s;const f=n=>{if(!o){const r=i;o=(0,a.E)(c).retry(t,n,r).then((()=>{u=(u+1)%e.length,o=null}))}o.then((()=>r&&r(t))).then(g,d),i+=1},g=()=>{Promise.resolve().then((()=>n(e[u]))).then((e=>{l(harden([e])),s=u,i=0}),f)};g()})))}),l=m(c);return c}(e.map((e=>(assert.typeof(e,"string",y`rpcAddr ${e} must be a string`),e.includes("://")?e:`http://${e}`))),t)},w=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{retryCallback:n=u,jitter:r=d}=t,a=async(e,t,r)=>{if(n)return n(e,t,r);throw t};let o=0;const s="Network config leader";return new Promise(((n,i)=>{const c=async()=>{const n=await fetch(e,{headers:{accept:"application/json"}}),{rpcAddrs:r}=await n.json();return o=0,b(r,t)},l=async e=>{a(s,e,o).then((()=>r(s))).then((()=>c().then(n,l))).catch(i),o+=1};c().then(n,l)}))},v=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:s,t=arguments.length>1?arguments[1]:void 0;return e.includes("network-config")?w(e,t):b([e],t)},E=e=>(0,r.a2)((0,a.E)(e).getSharableNotifierInternals()),S=e=>harden({[Symbol.asyncIterator]:()=>{return t=(0,a.E)(e).getSharableSubscriptionInternals(),(0,a.cI)("SubscriptionIterator",{next:async()=>{const e=a.E.get(t).head;return t=a.E.get(t).tail,e}});var t}}),k=(e,t)=>async function*(){for await(const n of e)yield t(n)}(),I=(e,t)=>(0,a.cI)("iterateEach iterable",{[Symbol.asyncIterator]:()=>{const n=(0,a.E)(e).getEachIterable(t),r=(0,a.E)(n)[Symbol.asyncIterator]();return(0,a.cI)("iterateEach iterator",{next:()=>(0,a.E)(r).next()})}});var $=n(2039),O=n.t($,2),P=n(6578),C=n.t(P,2),x=n(2363),N=n.t(x,2);const{toAscii:j}=N,A=".".charCodeAt(0),B=new Uint8Array([0]),M=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"vstorage";const n=e?e.split("."):[],r=j(`${n.length}.${e}`);return harden({storeName:t,storeSubkey:r.map((e=>e===A?0:e)),dataPrefixBytes:B})},W=harden({"swingset:":e=>harden({storeName:"swingset",storeSubkey:j(`swingset/data:${e}`)}),"vstore:":M,":":M}),T=new TextEncoder,H=e=>{const{storeName:t,storeSubkey:n,dataPrefixBytes:r,subscription:a,notifier:o}=e;if(a||o)return harden({subscription:a,notifier:o});let s=n;"string"===typeof n&&(s=T.encode(n));let i=r;return"string"===typeof r&&(i=T.encode(r)),harden({storeName:t,storeSubkey:s,dataPrefixBytes:i})},D=async e=>{const t=await e;if("string"===typeof t)return(e=>{assert.typeof(e,"string");const t=e.match(/^([^:.]*:)(.*)/);assert(t,`spec string ${e} does not match 'PREFIX:PATH' or ':PATH'`);const n=t[1],r=t[2],a=W[n];return assert(a,`Unknown pathKind ${n}`),a(r)})(t);const{storeName:n,subscription:r,notifier:o}=t;return n||r||o?H(t):(0,a.mY)(t)?(async e=>{const t=await(0,a.E)(e).getStoreKey();return H(t)})(t):void assert.fail(`CastingSpec ${t} is not a string, object, or ref`)},{QueryClient:V}=C,{Tendermint34Client:Z}=O,{details:R,quote:z}=assert,L=new TextDecoder,U=e=>e&&"object"===typeof e&&Array.isArray(e.values)&&"string"===typeof e.blockHeight&&/^0$|^[1-9][0-9]*$/.test(e.blockHeight),J=(e,t)=>{if(e.length!==t.length)return!1;for(let n=0;n<e.length;n+=1)if(e[n]!==t[n])return!1;return!0},K=new Uint8Array,q=e=>{const t=[];let n=0;for(const r of e)n+=1,1===n?t.push(r):assert.fail(`expected single value, got at least ${n}`);return assert.equal(t.length,1,"expected single value"),t[0]},F=["strict","none","optimistic"],_=async(e,t,n)=>{const r=await D(e),{storeName:o}=r;return o?function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:v,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const{decode:r=g(),unserializer:o=p(),proof:s="optimistic",crasher:i=null}=n,c=e=>{throw i&&(0,a.E)(i).crash("PROOF VERIFICATION FAILURE; crashing follower",e).catch((e=>assert.fail(R`crashing follower failed: ${e}`))),e};assert(F.includes(s),R`unrecognized follower proof mode ${s}`);const l="CosmJS follower",d=D(e),u="function"===typeof t?t():t,f=new Map,h=e=>{let t=f.get(e);return t||(t=Z.connect(e),f.set(e,t)),t},m=async()=>{const e=await(0,a.E)(u).mapEndpoints(l,(async e=>{const t=await h(e),n=await t.abciInfo(),{lastBlockHeight:r}=n;return assert.typeof(r,"number"),r}));return q(e)},y=new Map,b=async e=>{if(y.has(e)){const t=y.get(e);return assert(t),t}const t=await h(e),n=V.withExtensions(t);return y.set(e,n),n},w=async e=>{const{storeName:t,storeSubkey:n,dataPrefixBytes:r=K}=await d;assert.typeof(t,"string",R`storeName must be a string, got ${t}`),assert(n,R`storeSubkey must be a Uint8Array, got ${n}`);const o=await(0,a.E)(u).mapEndpoints(l,(async r=>e(r,t,n).then((e=>({result:e,error:null})),(e=>({result:null,error:e}))))),{result:s,error:i}=q(o);if(null!==i)throw i;return assert(s),0===s.length?s:(assert(s.length>=r.length,R`result too short for data prefix ${r}`),assert(J(s.subarray(0,r.length),r),R`${s} doesn't start with data prefix ${r}`),s.slice(r.length))},E=async e=>w((async(t,n,r)=>{const o=await b(t);return(0,a.E)(o).queryVerified(n,r,e)})),S=async e=>w((async(t,n,r)=>{const a=await h(t),o=await a.abciQuery({path:`store/${n}/key`,data:r,height:e,prove:!1});if(0!==o.code)throw new Error(`Tendermint ABCI query failed: ${o.log}`);const{value:s}=o;return s})),k=async e=>{if("strict"===s)return E(e).catch(c);if("none"===s)return S(e);if("optimistic"===s){const t=await S(e);return E(e).then((e=>{J(e,t)||c(assert.error(R`Alleged value ${t} did not match proof ${e}`))}),c),t}assert.fail(R`Unrecognized proof option ${z(s)}, must be one of strict, none, or optimistic`)},I=async e=>{assert.typeof(e,"number");for(let n=0;;n+=1)try{return await k(e)}catch(t){await(0,a.E)(u).retry(l,t,n);continue}},$=(e,t)=>{const n=L.decode(t);try{const e=JSON.parse(n);if(U(e))return harden({blockHeight:Number(e.blockHeight),values:e.values.map(r)})}catch{}return harden({blockHeight:e,values:[r(n)]})},O=async(e,t,n)=>({value:await(o?(0,a.E)(o).unserialize(e):e),blockHeight:t,currentBlockHeight:n});function*P(e,t){for(const n of e.values)yield O(n,e.blockHeight,t)}function*C(e,t){for(let n=e.values.length-1;n>=0;n-=1)yield O(e.values[n],e.blockHeight,t)}function*x(e,t){const{values:n}=e;if(n.length>0){const r=n[n.length-1];yield O(r,e.blockHeight,t)}}async function*N(){let e,t;for(;;){const n=await m();if(n===e){await(0,a.E)(u).jitter(l);continue}const r=await I(n);if(0===r.length){await(0,a.E)(u).jitter(l);continue}const o=$(n,r);e=n,void 0!==t&&J(t,r)||(yield*x(o,n),t=r)}}async function*j(e){let t;for(assert.typeof(e,"number");;){if(t=await I(e),0!==t.length){const n=$(e,t);yield*P(n,e);break}await(0,a.E)(u).jitter(l),e=await m()}for(;;){const n=await m();if(n<=e){await(0,a.E)(u).jitter(l);continue}let r=n,o=await I(r);if(0===o.length){await(0,a.E)(u).jitter(l);continue}let s=$(r,o);const i=o,c=[];for(;r>e;){if(s.blockHeight>r){const{storeName:e,storeSubkey:t}=await d;throw new Error(`Corrupt storage cell for ${e} under key ${t} at block-height ${r} claims to being published at a later block height ${s.blockHeight}`)}const t=s.blockHeight-1;if(t<=e)break;const n=await I(t);if(0===n.length)break;const a=$(t,n);J(n,o)||c.push(s),o=n,s=a,r=t}for(J(o,t)||c.push(s);;){const e=c.pop();if(void 0===e)break;yield*P(e,n)}e=n,t=i}}async function*A(e){let t;for(;e>0;){if(t=await I(e),0===t.length)return;const n=$(e,t);yield*C(n,e),e=n.blockHeight-1}}return(0,a.cI)("chain follower",{getLatestIterable:async()=>N(),async getEachIterable(){let{height:e}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return void 0===e&&(e=await m()),j(e)},async getReverseIterable(){let{height:e}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return void 0===e&&(e=await m()),A(e)}})}(r,t,n):(e=>{const t=e=>harden({value:e,blockHeight:NaN,currentBlockHeight:NaN});return(0,a.cI)("subscription/notifier follower",{getLatestIterable:async()=>{const{notifier:n,subscription:r}=await e;let a;return n?a=E(n):(assert(r),a=S(r)),k(a,t)},getEachIterable:async()=>{const{notifier:n,subscription:r}=await e;let a;return r?a=S(r):(assert(n),a=E(n)),k(a,t)},getReverseIterable:async()=>{throw Error("reverse iteration not implemented for subscription follower")}})})(r)},G="no smart wallet",Q=async e=>{const t=(0,a.E)(e).getReverseIterable(),n=await(0,a.E)(t)[Symbol.asyncIterator](),r=await n.next();r.done&&!r.value&&assert.fail(G)};var Y=n(7092),X=n(603);const{details:ee,quote:te}=assert,ne=e=>"string"===typeof e&&!!e.match(/^board[^:]/),re=(e,t,n)=>`${t}:${`${n}`}`,ae=(e,t)=>Object.keys(e).find(t),oe=(e,t)=>{const n=ae(e,(e=>t.startsWith(`${e}:`)));return{kind:n,id:n?Number(t.slice(n.length+1)):NaN}},se=(e,t,n)=>{e.bySlot.init(t,n),e.byVal.init(n,t)},ie=e=>{const t=`SEVERED: ${e.replace(/^Alleged: /,"")}`;return(0,o.cI)(t,{})};var ce=n(4275),le=n(3276),de=n(3617),ue=n(7141),fe=n(3770);const ge=e=>{const t=new Map,n=n=>{const{key:r,newValue:a}=n;r&&a&&((n,r)=>{const a=JSON.parse(n);assert(Array.isArray(a));const[o,s,i,c]=a,l=JSON.parse(r);if("out"!==o||!l||"string"!==typeof l.type)return;const d={...l,dappOrigin:s},u=JSON.stringify([s,i]);let f,g;if(t.has(u))[f,g]=t.get(u)||assert.fail();else{const t=e=>{console.debug("WalletConnect: message -> storage",e),window.localStorage.setItem(JSON.stringify(["in",s,i,g]),JSON.stringify(e)),g+=1},n=()=>(0,X.E)(e).getScopedBridge(s,s);console.debug("new capTP connection",{origin:s,epoch:i}),f=(0,fe.Ol)(`from ${s} at ${i}`,t,n),g=0}t.set(u,[f,g+1]),console.debug("WalletConnect: storage -> dispatch",d),f.dispatch(d),window.localStorage.removeItem(n)})(r,a)};return window.addEventListener("storage",n),()=>{window.removeEventListener("storage",n);for(const[e,n]of t.values())e.abort(Error("wallet connection cancelled"))}};var pe=n(5114),he=n(8690),me=n(5155);const ye="DAPPS",be=e=>{var t;return null!==(t=(0,me.K)([ye,e]))&&void 0!==t?t:[]},we=e=>{const t=new Map,{notifier:n,updater:a}=(0,r.Gm)(),o=()=>a.updateState([...t.values()]),s=n=>{t.set(n.origin,n),((e,t)=>{var n;const{origin:r,enable:a,petname:o}=t,s=null!==(n=be(e))&&void 0!==n?n:[];(0,me.A)([ye,e],[...s.filter((e=>e.origin!==r)),{origin:r,enable:a,petname:o,id:r,meta:{id:r}}])})(e,n),o()},i=n=>{t.delete(n),((e,t)=>{var n;const r=null!==(n=be(e))&&void 0!==n?n:[];(0,me.A)([ye,e],r.filter((e=>e.origin!==t)))})(e,n),o()},c=(e,n)=>{const r=t.get(e);assert(r,`Tried to set petname on undefined dapp ${e}`),s({...r,petname:n})},l=e=>{const n=t.get(e);assert(n,`Tried to enable undefined dapp ${e}`),s({...n,enable:!0})};return be(e).forEach((e=>{let n;const r=new Promise((t=>{n=()=>{l(e.origin),t()}}));t.set(e.origin,{...e,approvedP:r,actions:{enable:n,setPetname:t=>c(e.origin,t),delete:()=>i(e.origin)}}),e.enable&&n()})),o(),{dapps:t,notifier:n,addDapp:s,setDappPetname:c,deleteDapp:i,enableDapp:l}},ve=e=>{const t=new Map,{notifier:n,updater:a}=(0,r.Gm)(),o=()=>a.updateState([...t.values()]),s=e=>{assert(t.has(e),`Tried to delete undefined issuer suggestion ${e}`),t.delete(e),o()};return{notifier:n,addSuggestion:(n,r)=>{t.set(r,{boardId:r,petname:n,actions:{delete:()=>s(r),accept:async t=>{const n=JSON.stringify({type:"suggestIssuer",data:{boardId:r,petname:t}});try{await e(n),s(r)}catch(a){console.error("Sign spend action failed",n)}}}}),o()}}},Ee="OFFERS",Se=e=>{var t;return null!==(t=(0,me.K)([Ee,e]))&&void 0!==t?t:[]},ke=(e,t)=>{var n;const r=null!==(n=Se(e))&&void 0!==n?n:[];(0,me.A)([Ee,e],r.filter((e=>e.id!==t)))},Ie=(e,t,n)=>{const a=new Map;let o=[];const{notifier:s,updater:i}=(0,r.Gm)(),c=()=>i.updateState([...a.values(),...o]),l=t=>{a.set(t.id,t),((e,t)=>{var n;const r=null!==(n=Se(e))&&void 0!==n?n:[];(0,me.A)([Ee,e],[...r.filter((e=>e.id!==t.id)),t])})(e,t),c()};Se(e).forEach((t=>{"decline"===t.status&&ke(e,t.id),a.set(t.id,{...t})})),c();return(async()=>{for await(const t of(0,r.oV)(n))null===t||void 0===t||t.forEach((n=>{console.log("chain offer",n);const r=n.id.split("#"),s=r[r.length-1];a.has(s)&&(a.delete(s),ke(e,s)),o=t,c()}))})(),{offers:a,notifier:s,addOffer:l,acceptOffer:async e=>{const n=a.get(e);return assert(n,`Tried to accept undefined offer ${e}`),t(n.spendAction)},cancelOffer:e=>{console.log("TODO: cancel offer")},declineOffer:e=>{const t=a.get(e);assert(t,`Tried to decline undefined offer ${e}`),l({...t,status:"decline"}),c()}}},$e=(e,t,n)=>{const{getPursesNotifier:r,dappService:a,offerService:o,issuerService:s,unserializer:i,networkConfig:c}=n,{dapps:l,addDapp:d,setDappPetname:u,deleteDapp:f,enableDapp:g}=a,p=t=>u(e,t);let h=l.get(e);if(!h){let n;const r=new Promise((t=>{n=()=>{g(e),t()}}));h={id:e,meta:{id:e},petname:t,origin:e,enable:!1,actions:{enable:n,setPetname:p,delete:()=>f(e)},approvedP:r},d(h)}return(0,fe.cI)("scoped bridge",{async addOffer(t){const n=(new Date).getTime(),r=`${n}`;return await h.approvedP,o.addOffer({id:r,instancePetname:`instance@${t.instanceHandleBoardId}`,requestContext:{dappOrigin:e,origin:e},meta:{id:`${n}`,creationStamp:n},status:"proposed",...t}),r},async suggestIssuer(e,t){await h.approvedP,s.addSuggestion(e,t)},async suggestInstallation(e,t){await h.approvedP,console.log("TODO: suggest installation",e,t)},async suggestInstance(e,t){await h.approvedP,console.log("TODO: suggest instance",e,t)},getPursesNotifier:async()=>(await h.approvedP,r()),getOffersNotifier:async()=>(await h.approvedP,o.notifier),getUnserializer:async()=>(await h.approvedP,i),getNetConfig:async()=>(await h.approvedP,c)})},Oe=e=>`${e}${Math.random()}`;var Pe=n(6758),Ce=n(5867),xe=n(18),Ne=n(7152),je=n(2571),Ae=n(8174),Be=n(6794),Me=n(6246),We=n(9419),Te=n(5030);const He=0,De=1,Ve=2,Ze="Cannot sign a transaction in read only mode, connect to keplr.",Re=(0,ue.LW)((e=>{let{onClose:t,open:n,address:r,href:a,keplrConnection:o}=e;const[s,i]=(0,de.useState)(He),[c,l]=(0,de.useState)(null),d=e=>(0,Te.jsxs)(Me.Z,{children:[(0,Te.jsx)(Me.Z,{sx:{margin:"auto",display:"flex",flexDirection:"row",justifyContent:"center"},children:(0,Te.jsx)(Pe.Z,{})}),(0,Te.jsx)(je.Z,{sx:{pt:2},children:e})]}),u=(()=>{switch(s){case He:return(0,Te.jsxs)("div",{children:[(0,Te.jsxs)(je.Z,{children:[(0,Te.jsx)("b",{children:"Network Config"}),":"," ",(0,Te.jsx)(We.Z,{href:a,underline:"none",color:"rgb(0, 176, 255)",children:a})]}),(0,Te.jsxs)(je.Z,{sx:{pt:2},children:[(0,Te.jsx)("b",{children:"Wallet Address:"})," ",r]}),(0,Te.jsxs)(je.Z,{sx:{pt:2},children:["There is no smart wallet provisioned for this address yet. A fee of ",(0,Te.jsx)("b",{children:"10 BLD"})," is required to create one."]})]});case De:return d("Please approve the transaction in Keplr.");case Ve:return d("Awaiting smart wallet creation...");default:return(0,Te.jsx)(Te.Fragment,{})}})();return(0,Te.jsxs)(Ce.Z,{open:n,children:[(0,Te.jsxs)(xe.Z,{children:[s===He?"Create a":"Creating"," Smart Wallet"]}),(0,Te.jsxs)(Ne.Z,{children:[u,c&&(0,Te.jsx)(je.Z,{sx:{pt:2},color:"primary",children:c})]}),s===He&&(0,Te.jsxs)(Ae.Z,{children:[(0,Te.jsx)(Be.Z,{color:"cancel",onClick:t,children:"Change Connection"}),(0,Te.jsx)(Be.Z,{onClick:()=>{const{signers:{interactiveSigner:e}}=o;e?(async e=>{l(null),i(De);try{await e.submitProvision()}catch(t){return i(He),void l(t.message)}i(Ve)})(e):l(Ze)},children:"Create"})]})]})}),(e=>({keplrConnection:e.keplrConnection}))),ze=de.forwardRef((function(e,t){let{children:n,...r}=e;return(0,Te.jsx)(ce.Z,{elevation:6,ref:t,variant:"filled",...r,children:n})})),Le=(0,ue.LW)((e=>{var t,n;let{connectionConfig:a,setConnectionStatus:s,setBackend:i,setBackendErrorHandler:c,keplrConnection:l}=e;const[d,u]=(0,de.useState)([]),[f,g]=(0,de.useState)(!1),p=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"error";t&&(console.error(`${e}:`,t),e+=`: ${t.message}`),"error"===n&&s(ue.QK.Error),u((t=>[...t,{severity:n,message:e}]))},{href:h,smartConnectionMethod:m}=a,y=m===pe.a.KEPLR&&l?l.address:m===pe.a.READ_ONLY?a.publicAddress:void 0,b=e=>{e.message===G?(g(!0),s(ue.QK.Error)):(i(null),p("Error in wallet backend",e))};return(0,de.useEffect)((()=>{if(!a||a.smartConnectionMethod===pe.a.KEPLR&&!l)return;let e,t;return(async()=>{const n=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:ie;const t={purse:{bySlot:(0,Y.WS)(),byVal:(0,Y.WS)()},payment:{bySlot:(0,Y.WS)(),byVal:(0,Y.WS)()},unknown:{bySlot:(0,Y.WS)(),byVal:(0,Y.WS)()}},n={bySlot:(0,Y.WS)(),byVal:(0,Y.WS)()},r=(t,n,r)=>{if(t.bySlot.has(n))return t.bySlot.get(n);const a=e(r);return se(t,n,a),a},a={fromBoard:(e,t)=>(assert(ne(e),ee`bad board slot ${te(e)}`),r(n,e,t)),fromMyWallet:(n,o)=>{if(!n)return e(`${n}`);const{kind:s,id:i}=oe(t,n);return s?r(t[s],i,o):a.fromBoard(n,o)}},s={fromBoard:e=>n.byVal.get(e),fromMyWallet:e=>{const n=ae(t,(n=>t[n].byVal.has(e)));assert(n,ee`cannot serialize unregistered ${e}`);const r=t[n].byVal.get(e);return re(0,n,r)}},i={fromBoard:(0,o.AU)(s.fromBoard,a.fromBoard,{marshalName:"fromBoard"}),fromMyWallet:(0,o.AU)(s.fromMyWallet,a.fromMyWallet,{marshalName:"fromMyWallet"})};return harden({initBoardId:(e,t)=>{se(n,e,t)},ensureBoardId:(e,t)=>{n.byVal.has(t)?assert.equal(n.byVal.get(t),e):se(n,e,t)},fromMyWallet:(0,o.cI)("wallet marshaller",{...i.fromMyWallet}),fromBoard:(0,o.cI)("board marshaller",{...i.fromBoard})})}(),a=v(h),d=e=>_(`:published.${e}`,a,{unserializer:n.fromMyWallet}),u=function(e,t,n,a,s,i,c){let l=arguments.length>7&&void 0!==arguments[7]?arguments[7]:e=>{throw e},d=arguments.length>8&&void 0!==arguments[8]?arguments[8]:()=>{};const u={getPursesNotifier:"purses",getContactsNotifier:"contacts",getIssuersNotifier:"issuers",getOffersNotifier:"offers",getPaymentsNotifier:"payments"},f=Object.fromEntries(Object.entries(u).map((e=>{let[t,n]=e;return[n,(0,r.Gm)(null)]}))),g={},p=new Map,h=new Map;d&&(d(),Object.values(f).forEach((e=>{let{updater:t}=e;return t.updateState([])})),d=void 0);const m=()=>{const e=[];for(const[t,n]of p.entries())n.currentAmount&&n.brandPetname&&(assert(n.pursePetname,"missing purse.pursePetname"),h.set(n.pursePetname,t),e.push(n));f.purses.updater.updateState(harden(e))},y=async()=>{await Q(e);const t=(await(0,X.E)(e).getLatestIterable())[Symbol.asyncIterator](),n=(await t.next()).value,r=n.value;for(const e of r.purses){console.debug("registering purse",e);const t=r.brands.find((t=>e.brand===t.brand));assert(t,`missing descriptor for brand ${e.brand}`);const n={brand:e.brand,currentAmount:e.balance,brandPetname:t.petname,pursePetname:t.petname,displayInfo:t.displayInfo};p.set(e.brand,n)}return console.debug("brandToPurse map",p),m(),n.blockHeight},b=async e=>{for await(const{value:n}of I(t,{height:e})){const e=n;switch(e.updated){case"brand":{const{descriptor:{brand:t,petname:n,displayInfo:r}}=e,a=p.get(t),o={brand:t,brandPetname:n,pursePetname:n,displayInfo:r,currentAmount:(null===a||void 0===a?void 0:a.currentAmount)||he.iU.makeEmpty(t)};p.set(t,o),m();break}case"balance":{const{currentAmount:t}=e,n={...p.get(t.brand),currentAmount:t,value:t.value};p.set(t.brand,n),m();break}case"offerStatus":{const{status:t}=e;console.log("offerStatus",{status:t,offers:g});const n=g[t.id];if(!n){console.warn("Update for unknown offer, doing nothing.");break}"error"in t?g[t.id]={...n,id:t.id,status:"rejected",error:`${t.error}`}:"accept"!==n.status&&"numWantsSatisfied"in t&&(g[t.id]={...n,id:t.id,status:"accept"}),f.offers.updater.updateState(harden(Object.values(g)));break}default:throw Error(`Unknown updateRecord ${e.updated}`)}}},w=()=>y().then(b),v=()=>{w().catch((e=>{e.message===G?setTimeout(v,5e3):l(e)}))};w().catch((e=>{l(e),e.message===G&&setTimeout(v,5e3)}));const E=Object.fromEntries(Object.entries(u).map((e=>{let[t,n]=e;const{notifier:r}=f[n];return[t,()=>r]}))),S=()=>{console.log("make empty purse")},k=()=>{console.log("add contact")},$=()=>{console.log("add issuer")},O=e=>{const{signers:{interactiveSigner:t}}=i;if(!t)throw new Error("Cannot sign a transaction in read only mode, connect to keplr.");return t.submitSpendAction(e)},P=ve(O),C=we(s),x=Ie(s,O,E.getOffersNotifier()),{acceptOffer:N,declineOffer:j,cancelOffer:A}=x,B=async e=>{const{id:t,instanceHandleBoardId:n,invitationMaker:{method:r},proposalTemplate:{give:o,want:s}}=e,i=e=>Object.fromEntries(Object.entries(e).map((e=>{let[t,{brand:n,pursePetname:r,value:a}]=e;return[t,{brand:n||h.get(r),value:BigInt(a)}]}))),c={id:(new Date).getTime(),invitationSpec:{source:"contract",instance:n,publicInvitationMaker:r},proposal:{give:i(o),want:i(s)}},l=await(0,X.E)(a).serialize(harden({method:"executeOffer",offer:c})),{slots:[d]}=await(0,X.E)(a).serialize(n),u={...e,instancePetname:`instance@${d}`,spendAction:JSON.stringify(l)};return x.addOffer(u),g[t]=u,t};return(0,o.cI)("follower wallet bridge",{...E,getDappsNotifier:()=>C.notifier,getOffersNotifier:()=>x.notifier,getIssuerSuggestionsNotifier:()=>P.notifier,acceptOffer:N,declineOffer:j,cancelOffer:A,makeEmptyPurse:S,addContact:k,addIssuer:$,getScopedBridge:(e,t)=>$e(e,t,{dappService:C,offerService:{...x,addOffer:B},leader:n,unserializer:a,publicAddress:s,issuerService:P,networkConfig:c,...E})})}(d(`wallet.${y}.current`),d(`wallet.${y}`),a,n.fromBoard,y,l,h,b,(()=>{s(ue.QK.Connected),g(!1)})),{backendIt:f,cancel:p}=(e=>{const t=async e=>(0,r.oV)(e)[Symbol.asyncIterator](),{notifier:n}=(0,r.Gm)(harden({board:(0,X.E)(e).getBoard()})),a=harden({actions:(0,o.cI)("schemaActions",{createPurse:function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Oe("Purse");return(0,X.E)(e).makeEmptyPurse(null===t||void 0===t?void 0:t.issuerPetname,n)},createContact:function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Oe("Contact");return(0,X.E)(e).addContact(n,t)},createIssuer:function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Oe("Issuer");return(0,X.E)(e).addIssuer(n,t,!0)}}),services:t(n),contacts:t((0,X.E)(e).getContactsNotifier()),dapps:t((0,X.E)(e).getDappsNotifier()),issuers:t((0,X.E)(e).getIssuersNotifier()),offers:(s=t((0,X.E)(e).getOffersNotifier()),harden({next:async()=>{const{done:t,value:n}=await(0,X.E)(s).next();return harden({done:t,value:n&&n.map((t=>{let{id:n,...r}=t;return harden({id:n,...r,actions:(0,o.cI)("offerActions",{accept:()=>(0,X.E)(e).acceptOffer(n),decline:()=>(0,X.E)(e).declineOffer(n),cancel:()=>(0,X.E)(e).cancelOffer(n)})})}))})},return:s.return,throw:s.throw})),payments:t((0,X.E)(e).getPaymentsNotifier()),purses:t((0,X.E)(e).getPursesNotifier()),issuerSuggestions:t((0,X.E)(e).getIssuerSuggestionsNotifier())});var s;const{notifier:i,updater:c}=(0,r.Gm)(a);return{backendIt:t(i),cancel:e=>{c.fail(e)}}})(u);return t=ge(u),e=p,c((()=>b)),(0,r.uO)(f,{updateState:t=>{e&&i(t)},fail:t=>{e&&b(t)},finish:t=>{e&&i(t)}})})().catch((e=>p("Cannot read Smart Wallet casting",e))),()=>{e&&e(),e=void 0,t&&t(),t=void 0}}),[a,l]),(0,Te.jsxs)("div",{children:[(0,Te.jsx)(le.Z,{open:d.length>0,children:(0,Te.jsx)(ze,{onClose:(e,t)=>{"clickaway"!==t&&u((e=>e.slice(1)))},severity:null===(t=d[0])||void 0===t?void 0:t.severity,sx:{width:"100%"},children:null===(n=d[0])||void 0===n?void 0:n.message})}),(0,Te.jsx)(Re,{open:f,onClose:()=>{g(!1)},address:y,href:h})]})}),(e=>({connectionConfig:e.connectionConfig,setConnectionStatus:e.setConnectionStatus,setBackend:e.setBackend,setBackendErrorHandler:e.setBackendErrorHandler,keplrConnection:e.keplrConnection})))}}]);
//# sourceMappingURL=47.e619be1c.chunk.js.map