{"version":3,"file":"static/js/547.4d0b60b2.chunk.js","mappings":"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","sources":["util/WalletBackendAdapter.js","../../../casting/src/defaults.js","../../../casting/src/shuffle.js","../../../casting/src/change-follower.js","../../../casting/src/leader-netconfig.js","../../../casting/src/leader.js","../../../casting/src/iterable.js","../../../casting/src/follower-cosmjs.js","../../../casting/src/casting-spec.js"],"sourcesContent":["import { E } from '@endo/eventual-send';\nimport { Far } from '@endo/marshal';\nimport {\n  makeAsyncIterableFromNotifier,\n  makeNotifierKit,\n} from '@agoric/notifier';\nimport { iterateLatest } from '@agoric/casting';\n\nconst newId = kind => `${kind}${Math.random()}`;\n\nexport const makeBackendFromWalletBridge = walletBridge => {\n  /**\n   * @template T\n   * @param {ERef<Notifier<T>>} notifier\n   */\n  const iterateNotifier = async notifier =>\n    makeAsyncIterableFromNotifier(notifier)[Symbol.asyncIterator]();\n\n  const { notifier: servicesNotifier } = makeNotifierKit(\n    harden({\n      board: E(walletBridge).getBoard(),\n    }),\n  );\n\n  /**\n   * @param {AsyncIterator<any[], any[], undefined>} offersMembers\n   */\n  const wrapOffersIterator = offersMembers =>\n    harden({\n      next: async () => {\n        const { done, value } = await E(offersMembers).next();\n        return harden({\n          done,\n          value: value.map(({ id, ...rest }) =>\n            harden({\n              id,\n              ...rest,\n              actions: Far('offerActions', {\n                // Provide these synthetic actions since offers don't have any yet.\n                accept: () => E(walletBridge).acceptOffer(id),\n                decline: () => E(walletBridge).declineOffer(id),\n                cancel: () => E(walletBridge).cancelOffer(id),\n              }),\n            }),\n          ),\n        });\n      },\n      return: offersMembers.return,\n      throw: offersMembers.throw,\n    });\n\n  const firstSchema = harden({\n    actions: Far('schemaActions', {\n      createPurse: (issuer, id = newId('Purse')) =>\n        E(walletBridge).makeEmptyPurse(issuer?.issuerPetname, id),\n      createContact: (depositFacet, id = newId('Contact')) =>\n        E(walletBridge).addContact(id, depositFacet),\n      createIssuer: (issuer, id = newId('Issuer')) =>\n        E(walletBridge).addIssuer(id, issuer, true),\n    }),\n    services: iterateNotifier(servicesNotifier),\n    contacts: iterateNotifier(E(walletBridge).getContactsNotifier()),\n    dapps: iterateNotifier(E(walletBridge).getDappsNotifier()),\n    issuers: iterateNotifier(E(walletBridge).getIssuersNotifier()),\n    offers: wrapOffersIterator(\n      iterateNotifier(E(walletBridge).getOffersNotifier()),\n    ),\n    payments: iterateNotifier(E(walletBridge).getPaymentsNotifier()),\n    purses: iterateNotifier(E(walletBridge).getPursesNotifier()),\n  });\n\n  // Just produce a single update for the initial backend.\n  // TODO: allow further updates.\n  const { notifier: backendNotifier, updater: backendUpdater } =\n    makeNotifierKit(firstSchema);\n\n  const backendIt = iterateNotifier(backendNotifier);\n\n  const cancel = e => {\n    backendUpdater.fail(e);\n  };\n\n  return { backendIt, cancel };\n};\n\n/**\n * @param {import('@agoric/casting').Follower} follower\n * @param {(e: unknown) => void} [errorHandler]\n */\nexport const makeWalletBridgeFromFollower = (\n  follower,\n  errorHandler = e => {\n    // Make an unhandled rejection.\n    throw e;\n  },\n) => {\n  const notifiers = {\n    getPursesNotifier: 'purses',\n    getContactsNotifier: 'contacts',\n    getDappsNotifier: 'dapps',\n    getIssuersNotifier: 'issuers',\n    getOffersNotifier: 'offers',\n    getPaymentsNotifier: 'payments',\n  };\n\n  const notifierKits = Object.fromEntries(\n    Object.entries(notifiers).map(([_method, stateName]) => [\n      stateName,\n      makeNotifierKit([]),\n    ]),\n  );\n\n  const followLatest = async () => {\n    for await (const { value: state } of iterateLatest(follower)) {\n      Object.entries(notifierKits).forEach(([stateName, { updater }]) => {\n        updater.updateState(state[stateName]);\n      });\n    }\n  };\n  followLatest().catch(errorHandler);\n\n  const getNotifierMethods = Object.fromEntries(\n    Object.entries(notifiers).map(([method, stateName]) => {\n      const { notifier } = notifierKits[stateName];\n      return [method, () => notifier];\n    }),\n  );\n  const walletBridge = Far('follower wallet bridge', {\n    ...getNotifierMethods,\n  });\n  return walletBridge;\n};\n","// @ts-check\n/* global setTimeout */\nimport { Far } from '@endo/far';\nimport { makeMarshal } from '@endo/marshal';\n\n/**\n * Resolve a Promise after a given number of milliseconds.\n *\n * @param {number} ms\n * @returns {Promise<void>}\n */\nexport const delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n/**\n * Report an error, then retry the leader operation after a second or two.\n *\n * @param {any} err\n * @param {number} _attempt\n * @returns {Promise<void>}\n */\nexport const DEFAULT_RETRY_CALLBACK = (err, _attempt = 0) => {\n  console.warn('retrying after error', err);\n  // TODO: `delay(Math.random() * Math.min(cap, base * 2 ** attempt))\n  return delay(1000 + Math.random() * 1000);\n};\n\n/**\n * Return true after we want to be sure we received latest state something.\n *\n * @returns {Promise<boolean>}\n */\nexport const DEFAULT_KEEP_POLLING = () =>\n  // TOOD: Remove this when the event-driven stuff is in place.\n  delay(5000 + Math.random() * 1000).then(() => true);\n// ... and uses this instead.\n// delay(10 * 60 * 1000 + Math.random() * 60_000).then(() => true);\n\n/**\n * Decode utf-8 bytes, then parse the resulting JSON.\n *\n * @param {Uint8Array} buf\n */\nexport const DEFAULT_DECODER = harden(buf => {\n  const td = new TextDecoder();\n  const str = td.decode(buf);\n  return harden(JSON.parse(str));\n});\n\nconst ifaceAllegedPrefix = 'Alleged: ';\nconst ifaceInaccessiblePrefix = 'INACCESSIBLE: ';\nconst slotToVal = (_slot, iface) => {\n  // Private object.\n  if (typeof iface === 'string' && iface.startsWith(ifaceAllegedPrefix)) {\n    iface = iface.slice(ifaceAllegedPrefix.length);\n  }\n  return Far(`${ifaceInaccessiblePrefix}${iface}`, {});\n};\n\n/**\n * Unserialize the JSONable data.\n *\n * @type {import('./types').Unserializer}\n */\nexport const DEFAULT_UNSERIALIZER = Far('marshal unserializer', {\n  unserialize: makeMarshal(undefined, slotToVal).unserialize,\n});\n","// @ts-check\n\n/**\n * Modern version of Fisher-Yates shuffle algorithm (in-place).\n *\n * @template T\n * @param {Array<T>} a\n */\nexport const shuffle = a => {\n  for (let i = a.length - 1; i > 0; i -= 1) {\n    const j = Math.floor(Math.random() * (i + 1));\n    const x = a[i];\n    a[i] = a[j];\n    a[j] = x;\n  }\n};\n","// @ts-check\nimport { E, Far } from '@endo/far';\nimport { DEFAULT_KEEP_POLLING } from './defaults.js';\n\n/**\n * Just return an unspecified allegedValue every poll period.\n *\n * @param {import('./types').Leader} leader\n * @param {import('./types.js').CastingSpec} castingSpec\n * @returns {Promise<import('./types.js').Follower<import('./types').CastingChange>>}\n */\nexport const makePollingChangeFollower = async (leader, castingSpec) => {\n  const { keepPolling = DEFAULT_KEEP_POLLING } = await E(leader).getOptions();\n  return Far('polling change follower', {\n    getLatestIterable: () =>\n      Far('polling change follower iterable', {\n        [Symbol.asyncIterator]: () => {\n          /** @type {Promise<boolean> | undefined} */\n          let nextPollPromise;\n          return Far('polling change follower iterator', {\n            next: async () => {\n              if (!nextPollPromise) {\n                nextPollPromise = keepPolling();\n              }\n              const keepGoing = await nextPollPromise;\n              nextPollPromise = undefined;\n              const change = harden({\n                castingSpec,\n                // Make no warrant as to the values.\n                values: [],\n              });\n              return harden({\n                value: change,\n                done: !keepGoing,\n              });\n            },\n          });\n        },\n      }),\n  });\n};\n","// @ts-check\n/* global fetch */\nimport { makeRoundRobinLeader } from './leader.js';\nimport { DEFAULT_RETRY_CALLBACK } from './defaults.js';\n\nconst { details: X } = assert;\n\n/**\n * @param {string[]} rpcAddrs\n * @param {import('./types.js').LeaderOptions} [leaderOptions]\n */\nexport const makeLeaderFromRpcAddresses = (rpcAddrs, leaderOptions) => {\n  assert(Array.isArray(rpcAddrs), X`rpcAddrs ${rpcAddrs} must be an array`);\n\n  const rpcHrefs = rpcAddrs.map(rpcAddr => {\n    assert.typeof(rpcAddr, 'string', X`rpcAddr ${rpcAddr} must be a string`);\n    // Don't remove explicit port numbers from the URL, because the Cosmos\n    // `--node=xxx` flag requires them (it doesn't just assume that\n    // `--node=https://testnet.rpc.agoric.net` is the same as\n    // `--node=https://testnet.rpc.agoric.net:443`)\n    return rpcAddr.includes('://') ? rpcAddr : `http://${rpcAddr}`;\n  });\n\n  return makeRoundRobinLeader(rpcHrefs, leaderOptions);\n};\n\n/**\n * @param {string} netconfigURL\n * @param {import('./types.js').LeaderOptions} [options]\n */\nexport const makeLeaderFromNetworkConfig = (netconfigURL, options = {}) => {\n  const { retryCallback = DEFAULT_RETRY_CALLBACK } = options;\n  /** @type {import('./types.js').LeaderOptions['retryCallback']} */\n  const retry = async (err, attempt) => {\n    if (retryCallback) {\n      return retryCallback(err, attempt);\n    }\n    throw err;\n  };\n  let attempt = 0;\n  return new Promise((resolve, reject) => {\n    const makeLeader = async () => {\n      const response = await fetch(netconfigURL, {\n        headers: { accept: 'application/json' },\n      });\n      const { rpcAddrs } = await response.json();\n      // Our part succeeded, so reset the attempt counter.\n      attempt = 0;\n      return makeLeaderFromRpcAddresses(rpcAddrs, options);\n    };\n    const retryLeader = async err => {\n      retry(err, attempt)\n        .then(() => makeLeader().then(resolve, retryLeader))\n        .catch(reject);\n      attempt += 1;\n    };\n    makeLeader().then(resolve, retryLeader);\n  });\n};\n\n/**\n * @param {string} bootstrap\n * @param {import('./types.js').LeaderOptions} options\n */\nexport const makeLeader = (bootstrap, options) => {\n  if (bootstrap.includes('network-config')) {\n    return makeLeaderFromNetworkConfig(bootstrap, options);\n  }\n  return makeLeaderFromRpcAddresses([bootstrap], options);\n};\n","// @ts-check\nimport { E, Far } from '@endo/far';\nimport { DEFAULT_RETRY_CALLBACK } from './defaults.js';\nimport { shuffle } from './shuffle.js';\nimport { makePollingChangeFollower } from './change-follower.js';\n\n/**\n * Create a chain leader that rotates through a list of endpoints.\n *\n * @param {string[]} endpoints\n * @param {import('./types.js').LeaderOptions} leaderOptions\n */\nexport const makeRoundRobinLeader = (endpoints, leaderOptions = {}) => {\n  const { retryCallback = DEFAULT_RETRY_CALLBACK } = leaderOptions;\n\n  // Shuffle the RPC addresses, so that we don't always hit the same one as all\n  // our peers.\n  shuffle(endpoints);\n\n  let lastRespondingEndpointIndex = 0;\n  let thisAttempt = 0;\n\n  /** @type {import('./types.js').Leader} */\n  const leader = Far('round robin leader', {\n    getOptions: () => leaderOptions,\n    retry: async (err, attempt) => {\n      if (retryCallback) {\n        return retryCallback(err, attempt);\n      }\n      throw err;\n    },\n    watchCasting: castingSpec => makePollingChangeFollower(leader, castingSpec),\n    /**\n     * @template T\n     * @param {(endpoint: string) => Promise<T>} callback\n     */\n    mapEndpoints: async callback => {\n      /** @type {Promise<T[]>} */\n      const p = new Promise((resolve, reject) => {\n        let endpointIndex = lastRespondingEndpointIndex;\n\n        const retry = async err => {\n          endpointIndex = (endpointIndex + 1) % endpoints.length;\n\n          // eslint-disable-next-line no-use-before-define\n          E(leader).retry(err, thisAttempt).then(applyOne, reject);\n          thisAttempt += 1;\n        };\n\n        const applyOne = () => {\n          Promise.resolve()\n            .then(() => callback(endpoints[endpointIndex]))\n            .then(res => {\n              resolve(harden([res]));\n              lastRespondingEndpointIndex = endpointIndex;\n              thisAttempt = 0;\n            }, retry);\n\n          // Don't return to prevent a promise chain.\n        };\n\n        applyOne();\n      });\n      return p;\n    },\n  });\n  return leader;\n};\n","// @ts-check\nimport { E } from '@endo/far';\n\n/**\n * Consume a notifier, only returning next when there is a new publication.\n *\n * @template T\n * @param {Notifier<T>} notifier\n */\nexport const makeAsyncIterableFromNotifier = notifier =>\n  harden({\n    [Symbol.asyncIterator]: () => {\n      /** @type {UpdateCount} */\n      let lastUpdateCount = 0;\n      return harden({\n        next: async () => {\n          const { value, updateCount } = await notifier.getUpdateSince(\n            lastUpdateCount,\n          );\n          lastUpdateCount = updateCount;\n          return {\n            value,\n            done: lastUpdateCount === undefined,\n          };\n        },\n      });\n    },\n  });\n\n/**\n * @template T\n * @param {ERef<import('./types').Follower<T>>} follower\n */\nexport const iterateLatest = follower => {\n  // For now, just pass through the iterable.\n  return harden({\n    /** @returns {AsyncIterator<T>} */\n    [Symbol.asyncIterator]: () => {\n      const latestIterable = E(follower).getLatestIterable();\n      const iterator = E(latestIterable)[Symbol.asyncIterator]();\n      return harden({\n        next: () => E(iterator).next(),\n      });\n    },\n  });\n};\n","// @ts-check\nimport { E, Far } from '@endo/far';\nimport { makeNotifierKit } from '@agoric/notifier';\nimport { Tendermint34Client } from '@cosmjs/tendermint-rpc';\nimport { QueryClient } from '@cosmjs/stargate';\n\nimport { makeAsyncIterableFromNotifier, iterateLatest } from './iterable.js';\nimport { DEFAULT_DECODER, DEFAULT_UNSERIALIZER } from './defaults.js';\n\nconst { details: X } = assert;\n\n/** @template T @typedef {import('./types.js').FollowerElement<T>} FollowerElement */\n/** @template T @typedef {import('./types.js').Follower<T>} Follower */\n\n/**\n * @template T\n * @param {Iterable<T>} values\n * @returns {T}\n */\nconst collectSingle = values => {\n  /** @type {T[]} */\n  const head = [];\n  let count = 0;\n  for (const value of values) {\n    count += 1;\n    if (count === 1) {\n      head.push(value);\n    } else {\n      assert.fail(`expected single value, got at least ${count}`);\n    }\n  }\n\n  assert.equal(head.length, 1, 'expected single value');\n  return head[0];\n};\n\n/**\n * @callback QueryVerifier\n * @param {() => Promise<Uint8Array>} getProvenValue\n * @param {(reason?: unknown) => void} crash\n * @param {() => Promise<Uint8Array>} getAllegedValue\n */\n\n/**\n * @type {Record<Required<import('./types').FollowerOptions>['integrity'], QueryVerifier>}\n */\nexport const integrityToQueryVerifier = harden({\n  strict: async (getProvenValue, crash, _getAllegedValue) => {\n    // Just ignore the alleged value.\n    // Crash hard if we can't prove.\n    return getProvenValue().catch(crash);\n  },\n  none: async (_getProvenValue, _crash, getAllegedValue) => {\n    // Fast and loose.\n    return getAllegedValue();\n  },\n  optimistic: async (getProvenValue, crash, getAllegedValue) => {\n    const allegedValue = await getAllegedValue();\n    // Prove later, since it may take time we say we can't afford.\n    getProvenValue().then(provenValue => {\n      if (provenValue.length === allegedValue.length) {\n        if (provenValue.every((proven, i) => proven === allegedValue[i])) {\n          return;\n        }\n      }\n      crash(\n        assert.error(\n          X`Alleged value ${allegedValue} did not match proof ${provenValue}`,\n        ),\n      );\n    }, crash);\n\n    // Speculate that we got the right value.\n    return allegedValue;\n  },\n});\n\n/**\n * @template T\n * @param {ERef<import('./types').Leader>} leader\n * @param {import('./types').CastingSpec} castingSpec\n * @param {import('./types').FollowerOptions} options\n * @returns {Follower<FollowerElement<T>>}\n */\nexport const makeFollower = (leader, castingSpec, options = {}) => {\n  const {\n    decode = DEFAULT_DECODER,\n    unserializer = DEFAULT_UNSERIALIZER,\n    integrity = 'optimistic',\n    crasher = null,\n  } = options;\n  const {\n    storeName,\n    storeSubkey,\n    dataPrefixBytes = new Uint8Array(),\n  } = castingSpec;\n\n  /** @type {QueryVerifier} */\n  const queryVerifier = integrityToQueryVerifier[integrity];\n  assert(queryVerifier, X`unrecognized follower integrity mode ${integrity}`);\n\n  /** @type {Map<string, QueryClient>} */\n  const endpointToQueryClient = new Map();\n\n  /**\n   * @param {string} endpoint\n   */\n  const getOrCreateQueryClient = async endpoint => {\n    if (endpointToQueryClient.has(endpoint)) {\n      // Cache hit.\n      const queryClient = endpointToQueryClient.get(endpoint);\n      assert(queryClient);\n      return queryClient;\n    }\n    // Create a new client.  They retry automatically.\n    const rpcClient = await Tendermint34Client.connect(endpoint);\n    const queryClient = QueryClient.withExtensions(rpcClient);\n    endpointToQueryClient.set(endpoint, queryClient);\n    return queryClient;\n  };\n\n  /**\n   * @param {'queryVerified' | 'queryUnverified'} method\n   * @param {string} queryPath\n   */\n  const makeQuerier =\n    (method, queryPath) =>\n    /**\n     * @param {number} [height]\n     * @returns {Promise<Uint8Array>}\n     */\n    async height => {\n      const values = await E(leader).mapEndpoints(async endpoint => {\n        const queryClient = await getOrCreateQueryClient(endpoint);\n        return E(queryClient)\n          [method](queryPath, storeSubkey, height)\n          .then(\n            result => {\n              return { result, error: null };\n            },\n            error => {\n              return { result: null, error };\n            },\n          );\n      });\n      const { result, error } = collectSingle(values);\n      if (error !== null) {\n        throw error;\n      }\n      assert(result);\n\n      if (result.length === 0) {\n        // No data.\n        return result;\n      }\n\n      // Handle the data prefix if any.\n      assert(\n        result.length >= dataPrefixBytes.length,\n        X`result too short for data prefix ${dataPrefixBytes}`,\n      );\n      assert(\n        dataPrefixBytes.every((v, i) => v === result[i]),\n        X`${result} doesn't start with data prefix ${dataPrefixBytes}`,\n      );\n      return result.slice(dataPrefixBytes.length);\n    };\n\n  const getProvenValueAtHeight = makeQuerier('queryVerified', storeName);\n  const getUnprovenValueAtHeight = makeQuerier(\n    'queryUnverified',\n    `store/${storeName}/key`,\n  );\n\n  // Enable the periodic fetch.\n  /** @type {Follower<FollowerElement<T>>} */\n  return Far('chain follower', {\n    getLatestIterable: () => {\n      /** @type {NotifierRecord<FollowerElement<T>>} */\n      const { updater, notifier } = makeNotifierKit();\n      let finished = false;\n\n      const fail = err => {\n        finished = true;\n        updater.fail(err);\n        return false;\n      };\n\n      const crash = err => {\n        fail(err);\n        if (crasher) {\n          E(crasher)\n            .crash(`PROOF VERIFICATION FAILURE; crashing follower`, err)\n            .catch(e => assert(false, X`crashing follower failed: ${e}`));\n        } else {\n          console.error(`PROOF VERIFICATION FAILURE; crashing follower`, err);\n        }\n      };\n\n      let attempt = 0;\n      const retryOrFail = err => {\n        E(leader)\n          .retry(err, attempt)\n          .catch(e => {\n            fail(e);\n            throw e;\n          });\n        attempt += 1;\n      };\n\n      /**\n       * These semantics are to ensure that later queries are not committed\n       * ahead of earlier ones.\n       *\n       * @template T\n       * @param {(...args: T[]) => void} commitAction\n       */\n      const makePrepareInOrder = commitAction => {\n        let lastPrepareTicket = 0n;\n        let lastCommitTicket = 0n;\n\n        const prepareInOrder = () => {\n          lastPrepareTicket += 1n;\n          const ticket = lastPrepareTicket;\n          assert(ticket > lastCommitTicket);\n          const committer = Far('committer', {\n            isValid: () => ticket > lastCommitTicket,\n            /**\n             * @type {(...args: T[]) => void}\n             */\n            commit: (...args) => {\n              assert(committer.isValid());\n              lastCommitTicket = ticket;\n              commitAction(...args);\n            },\n          });\n          return committer;\n        };\n        return prepareInOrder;\n      };\n\n      const prepareUpdateInOrder = makePrepareInOrder(updater.updateState);\n\n      /** @type {Uint8Array} */\n      let lastBuf;\n\n      /**\n       * @param {import('./types').CastingChange} allegedChange\n       */\n      const queryAndUpdateOnce = async allegedChange => {\n        const committer = prepareUpdateInOrder();\n\n        // Make an unproven query if we have no alleged value.\n        const { values: allegedValues, blockHeight: allegedBlockHeight } =\n          allegedChange;\n        const getAllegedValue =\n          allegedValues.length > 0\n            ? () => Promise.resolve(allegedValues[allegedValues.length - 1])\n            : () => getUnprovenValueAtHeight(allegedBlockHeight);\n        const getProvenValue = () => getProvenValueAtHeight(allegedBlockHeight);\n\n        const buf = await queryVerifier(getProvenValue, crash, getAllegedValue);\n        if (buf.length === 0) {\n          fail(Error('No query results'));\n          return;\n        }\n        attempt = 0;\n        if (!committer.isValid()) {\n          return;\n        }\n        if (lastBuf) {\n          if (buf.length === lastBuf.length) {\n            if (buf.every((v, i) => v === lastBuf[i])) {\n              // Duplicate!\n              return;\n            }\n          }\n        }\n        lastBuf = buf;\n        const data = decode(buf);\n        if (!unserializer) {\n          /** @type {T} */\n          const value = data;\n          committer.commit({ value });\n          return;\n        }\n        const value = await E(unserializer).unserialize(data);\n        if (!committer.isValid()) {\n          return;\n        }\n        committer.commit({ value });\n      };\n\n      const changeFollower = E(leader).watchCasting(castingSpec);\n      const queryWhenKeyChanges = async () => {\n        for await (const allegedChange of iterateLatest(changeFollower)) {\n          if (finished) {\n            return;\n          }\n          harden(allegedChange);\n          await queryAndUpdateOnce(allegedChange).catch(retryOrFail);\n        }\n      };\n\n      queryAndUpdateOnce({ values: [], castingSpec }).catch(retryOrFail);\n      queryWhenKeyChanges().catch(fail);\n\n      return makeAsyncIterableFromNotifier(notifier);\n    },\n  });\n};\n","// @ts-check\nimport { toAscii } from '@cosmjs/encoding';\n\n/**\n * @param {string} storagePath\n * @returns {import('./types').CastingSpec}\n */\nconst swingsetPathToCastingSpec = storagePath =>\n  harden({\n    storeName: 'swingset',\n    storeSubkey: toAscii(`swingset/data:${storagePath}`),\n  });\n\nconst PATH_SEPARATOR_BYTE = '.'.charCodeAt(0);\nconst DATA_PREFIX_BYTES = new Uint8Array([0]);\n\n/**\n * @param {string} storagePath\n * @param {string} [storeName]\n * @returns {import('./types').CastingSpec}\n */\nconst vstoragePathToCastingSpec = (storagePath, storeName = 'vstorage') => {\n  const elems = storagePath ? storagePath.split('.') : [];\n  const buf = toAscii(`${elems.length}.${storagePath}`);\n  return harden({\n    storeName,\n    storeSubkey: buf.map(b => (b === PATH_SEPARATOR_BYTE ? 0 : b)),\n    dataPrefixBytes: DATA_PREFIX_BYTES,\n  });\n};\n\nexport const DEFAULT_PATH_CONVERTER = vstoragePathToCastingSpec;\n\n/**\n * @type {Record<string, (path: string) => import('./types').CastingSpec>}\n */\nexport const pathPrefixToConverters = harden({\n  'swingset:': swingsetPathToCastingSpec,\n  'vstore:': vstoragePathToCastingSpec,\n  ':': DEFAULT_PATH_CONVERTER,\n});\n\n/**\n * @param {string} specString\n * @returns {import('./types').CastingSpec}\n */\nexport const makeCastingSpec = specString => {\n  assert.typeof(specString, 'string');\n  const match = specString.match(/^([^:.]*:)(.*)/);\n  assert(\n    match,\n    `spec string ${specString} does not match 'PREFIX:PATH' or ':PATH'`,\n  );\n  const kind = match[1];\n  const storePath = match[2];\n  const converter = pathPrefixToConverters[kind];\n  assert(converter, `Unknown pathKind ${kind}`);\n  return converter(storePath);\n};\n"],"names":["newId","kind","Math","random","makeBackendFromWalletBridge","walletBridge","iterateNotifier","async","makeAsyncIterableFromNotifier","notifier","Symbol","asyncIterator","servicesNotifier","makeNotifierKit","harden","board","E","getBoard","firstSchema","actions","Far","createPurse","issuer","id","makeEmptyPurse","issuerPetname","createContact","depositFacet","addContact","createIssuer","addIssuer","services","contacts","getContactsNotifier","dapps","getDappsNotifier","issuers","getIssuersNotifier","offers","offersMembers","getOffersNotifier","next","done","value","map","rest","accept","acceptOffer","decline","declineOffer","cancel","cancelOffer","return","throw","payments","getPaymentsNotifier","purses","getPursesNotifier","backendNotifier","updater","backendUpdater","backendIt","e","fail","makeWalletBridgeFromFollower","follower","errorHandler","notifiers","notifierKits","Object","fromEntries","entries","_method","stateName","followLatest","state","iterateLatest","forEach","updateState","catch","getNotifierMethods","method","delay","ms","Promise","resolve","setTimeout","DEFAULT_RETRY_CALLBACK","err","console","warn","DEFAULT_KEEP_POLLING","then","DEFAULT_DECODER","buf","str","TextDecoder","decode","JSON","parse","ifaceAllegedPrefix","DEFAULT_UNSERIALIZER","unserialize","makeMarshal","undefined","_slot","iface","startsWith","slice","length","shuffle","a","i","j","floor","x","makePollingChangeFollower","leader","castingSpec","keepPolling","getOptions","getLatestIterable","nextPollPromise","keepGoing","change","values","details","X","assert","makeLeaderFromRpcAddresses","rpcAddrs","leaderOptions","Array","isArray","endpoints","retryCallback","lastRespondingEndpointIndex","thisAttempt","retry","attempt","watchCasting","mapEndpoints","reject","endpointIndex","applyOne","callback","res","makeRoundRobinLeader","rpcAddr","typeof","includes","makeLeader","bootstrap","options","netconfigURL","response","fetch","headers","json","retryLeader","makeLeaderFromNetworkConfig","lastUpdateCount","updateCount","getUpdateSince","latestIterable","iterator","collectSingle","head","count","push","equal","integrityToQueryVerifier","strict","getProvenValue","crash","_getAllegedValue","none","_getProvenValue","_crash","getAllegedValue","optimistic","allegedValue","provenValue","every","proven","error","makeFollower","unserializer","integrity","crasher","storeName","storeSubkey","dataPrefixBytes","Uint8Array","queryVerifier","endpointToQueryClient","Map","getOrCreateQueryClient","has","endpoint","queryClient","get","rpcClient","Tendermint34Client","QueryClient","set","makeQuerier","queryPath","height","result","v","getProvenValueAtHeight","getUnprovenValueAtHeight","finished","retryOrFail","prepareUpdateInOrder","commitAction","lastPrepareTicket","lastCommitTicket","ticket","committer","isValid","commit","makePrepareInOrder","lastBuf","queryAndUpdateOnce","allegedValues","blockHeight","allegedBlockHeight","allegedChange","Error","data","changeFollower","queryWhenKeyChanges","PATH_SEPARATOR_BYTE","charCodeAt","DATA_PREFIX_BYTES","vstoragePathToCastingSpec","storagePath","elems","split","toAscii","b","pathPrefixToConverters","makeCastingSpec","specString","match","storePath","converter"],"sourceRoot":""}