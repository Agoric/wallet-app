"use strict";(globalThis.webpackChunk_agoric_wallet_ui=globalThis.webpackChunk_agoric_wallet_ui||[]).push([[492],{9492:(e,t,r)=>{r.r(t),r.d(t,{default:()=>ze});var n=r(3876),a=r(7017),o=r(8848);const s="http://localhost:26657",i=e=>new Promise((t=>setTimeout(t,e))),c=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e;return Math.random()*Math.min(t,e)},l=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3e4;return c(2**e*t,r)},d=e=>{const t=c(5e3);return console.debug(`jittering ${e} by ${Math.ceil(t)}ms`),i(t)},u=function(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const n=l(r);return console.log(`retrying ${e} in ${Math.ceil(n)}ms after attempt #${r}`,t),i(n)},f=()=>i(c(5e3)).then((()=>!0)),g=()=>harden((e=>{try{return harden(JSON.parse(e))}catch(t){throw new Error(`Cannot decode alleged JSON (${t.message}): ${e}`)}})),p=()=>{const e="Alleged: ",t=new Map;return(0,a.cI)("marshal unserializer",{unserialize:(0,o.AU)(void 0,((r,n)=>{if(t.has(r))return t.get(r);"string"===typeof n&&n.startsWith(e)&&(n=n.slice(e.length));const o=(0,a.cI)(`SEVERED: ${n}`,{});return t.set(r,o),o})).unserialize})},h=e=>{for(let t=e.length-1;t>0;t-=1){const r=Math.floor(Math.random()*(t+1)),n=e[t];e[t]=e[r],e[r]=n}},y=async e=>{const{keepPolling:t=f}=await(0,a.E)(e).getOptions(),r=(0,a.cI)("polling change follower iterable",{[Symbol.asyncIterator]:()=>{let r;return(0,a.cI)("polling change follower iterator",{next:async()=>{r||(r=t("polling change follower").then((t=>t?(0,a.E)(e).jitter("polling change follower").then((()=>t)):t)));const n=await r;r=void 0;const o=harden({values:[]});return harden({value:o,done:!n})}})}});return(0,a.cI)("polling change follower",{getLatestIterable:async()=>r,getEachIterable:async()=>r,getReverseIterable:async()=>{throw Error("not implemented for polling change follower")}})},{details:m}=assert,b=(e,t)=>{assert(Array.isArray(e),m`rpcAddrs ${e} must be an array`);return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{retryCallback:r=u,jitter:n=d}=t;h(e);let o,s=0,i=0;const c=(0,a.cI)("round robin leader",{getOptions:()=>t,jitter:async e=>n&&n(e),retry:async(e,t,n)=>{if(r)return r(e,t,n);throw t},watchCasting:e=>l,mapEndpoints:async(t,r)=>(t=`${t} (round-robin endpoints)`,new Promise(((l,d)=>{let u=s;const f=r=>{if(!o){const n=i;o=(0,a.E)(c).retry(t,r,n).then((()=>{u=(u+1)%e.length,o=null}))}o.then((()=>n&&n(t))).then(g,d),i+=1},g=()=>{Promise.resolve().then((()=>r(e[u]))).then((e=>{l(harden([e])),s=u,i=0}),f)};g()})))}),l=y(c);return c}(e.map((e=>(assert.typeof(e,"string",m`rpcAddr ${e} must be a string`),e.includes("://")?e:`http://${e}`))),t)},w=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{retryCallback:r=u,jitter:n=d}=t,a=async(e,t,n)=>{if(r)return r(e,t,n);throw t};let o=0;const s="Network config leader";return new Promise(((r,i)=>{const c=async()=>{const r=await fetch(e,{headers:{accept:"application/json"}}),{rpcAddrs:n}=await r.json();return o=0,b(n,t)},l=async e=>{a(s,e,o).then((()=>n(s))).then((()=>c().then(r,l))).catch(i),o+=1};c().then(r,l)}))},v=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:s,t=arguments.length>1?arguments[1]:void 0;return e.includes("network-config")?w(e,t):b([e],t)},E=e=>(0,n.a2)((0,a.E)(e).getSharableNotifierInternals()),S=e=>harden({[Symbol.asyncIterator]:()=>{return t=(0,a.E)(e).getSharableSubscriptionInternals(),(0,a.cI)("SubscriptionIterator",{next:async()=>{const e=a.E.get(t).head;return t=a.E.get(t).tail,e}});var t}}),k=(e,t)=>async function*(){for await(const r of e)yield t(r)}(),I=(e,t)=>(0,a.cI)("iterateEach iterable",{[Symbol.asyncIterator]:()=>{const r=(0,a.E)(e).getEachIterable(t),n=(0,a.E)(r)[Symbol.asyncIterator]();return(0,a.cI)("iterateEach iterator",{next:()=>(0,a.E)(n).next()})}}),$=(e,t)=>(0,a.cI)("iterateReverse iterable",{[Symbol.asyncIterator]:()=>{const r=(0,a.E)(e).getReverseIterable(t),n=(0,a.E)(r)[Symbol.asyncIterator]();return(0,a.cI)("iterateEach iterator",{next:()=>(0,a.E)(n).next()})}});var O=r(2039),C=r.t(O,2),x=r(6578),N=r.t(x,2),P=r(2363),j=r.t(P,2);const{toAscii:A}=j,B=".".charCodeAt(0),M=new Uint8Array([0]),W=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"vstorage";const r=e?e.split("."):[],n=A(`${r.length}.${e}`);return harden({storeName:t,storeSubkey:n.map((e=>e===B?0:e)),dataPrefixBytes:M})},H=harden({"swingset:":e=>harden({storeName:"swingset",storeSubkey:A(`swingset/data:${e}`)}),"vstore:":W,":":W}),T=new TextEncoder,D=e=>{const{storeName:t,storeSubkey:r,dataPrefixBytes:n,subscription:a,notifier:o}=e;if(a||o)return harden({subscription:a,notifier:o});let s=r;"string"===typeof r&&(s=T.encode(r));let i=n;return"string"===typeof n&&(i=T.encode(n)),harden({storeName:t,storeSubkey:s,dataPrefixBytes:i})},R=async e=>{const t=await e;if("string"===typeof t)return(e=>{assert.typeof(e,"string");const t=e.match(/^([^:.]*:)(.*)/);assert(t,`spec string ${e} does not match 'PREFIX:PATH' or ':PATH'`);const r=t[1],n=t[2],a=H[r];return assert(a,`Unknown pathKind ${r}`),a(n)})(t);const{storeName:r,subscription:n,notifier:o}=t;return r||n||o?D(t):(0,a.mY)(t)?(async e=>{const t=await(0,a.E)(e).getStoreKey();return D(t)})(t):void assert.fail(`CastingSpec ${t} is not a string, object, or ref`)},{QueryClient:V}=N,{Tendermint34Client:Z}=C,{details:z,quote:L}=assert,U=new TextDecoder,J=e=>e&&"object"===typeof e&&Array.isArray(e.values)&&"string"===typeof e.blockHeight&&/^0$|^[1-9][0-9]*$/.test(e.blockHeight),K=(e,t)=>{if(e.length!==t.length)return!1;for(let r=0;r<e.length;r+=1)if(e[r]!==t[r])return!1;return!0},q=new Uint8Array,F=e=>{const t=[];let r=0;for(const n of e)r+=1,1===r?t.push(n):assert.fail(`expected single value, got at least ${r}`);return assert.equal(t.length,1,"expected single value"),t[0]},_=["strict","none","optimistic"],G=async(e,t,r)=>{const n=await R(e),{storeName:o}=n;return o?function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:v,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const{decode:n=g(),unserializer:o=p(),proof:s="optimistic",crasher:i=null}=r,c=e=>{throw i&&(0,a.E)(i).crash("PROOF VERIFICATION FAILURE; crashing follower",e).catch((e=>assert.fail(z`crashing follower failed: ${e}`))),e};assert(_.includes(s),z`unrecognized follower proof mode ${s}`);const l="CosmJS follower",d=R(e),u="function"===typeof t?t():t,f=new Map,h=e=>{let t=f.get(e);return t||(t=Z.connect(e),f.set(e,t)),t},y=async()=>{const e=await(0,a.E)(u).mapEndpoints(l,(async e=>{const t=await h(e),r=await t.abciInfo(),{lastBlockHeight:n}=r;return assert.typeof(n,"number"),n}));return F(e)},m=new Map,b=async e=>{if(m.has(e)){const t=m.get(e);return assert(t),t}const t=await h(e),r=V.withExtensions(t);return m.set(e,r),r},w=async e=>{const{storeName:t,storeSubkey:r,dataPrefixBytes:n=q}=await d;assert.typeof(t,"string",z`storeName must be a string, got ${t}`),assert(r,z`storeSubkey must be a Uint8Array, got ${r}`);const o=await(0,a.E)(u).mapEndpoints(l,(async n=>e(n,t,r).then((e=>({result:e,error:null})),(e=>({result:null,error:e}))))),{result:s,error:i}=F(o);if(null!==i)throw i;return assert(s),0===s.length?s:(assert(s.length>=n.length,z`result too short for data prefix ${n}`),assert(K(s.subarray(0,n.length),n),z`${s} doesn't start with data prefix ${n}`),s.slice(n.length))},E=async e=>w((async(t,r,n)=>{const o=await b(t);return(0,a.E)(o).queryVerified(r,n,e)})),S=async e=>w((async(t,r,n)=>{const a=await h(t),o=await a.abciQuery({path:`store/${r}/key`,data:n,height:e,prove:!1});if(0!==o.code)throw new Error(`Tendermint ABCI query failed: ${o.log}`);const{value:s}=o;return s})),k=async e=>{if("strict"===s)return E(e).catch(c);if("none"===s)return S(e);if("optimistic"===s){const t=await S(e);return E(e).then((e=>{K(e,t)||c(assert.error(z`Alleged value ${t} did not match proof ${e}`))}),c),t}assert.fail(z`Unrecognized proof option ${L(s)}, must be one of strict, none, or optimistic`)},I=async e=>{for(let r=0;;r+=1)try{return await k(e)}catch(t){await(0,a.E)(u).retry(l,t,r);continue}},$=(e,t)=>{const r=U.decode(t);try{const e=JSON.parse(r);if(J(e))return harden({blockHeight:Number(e.blockHeight),values:e.values.map(n)})}catch{}return harden({blockHeight:e,values:[n(r)]})},O=async(e,t,r)=>({value:await(o?(0,a.E)(o).unserialize(e):e),blockHeight:t,currentBlockHeight:r});function*C(e,t){for(const r of e.values)yield O(r,e.blockHeight,t)}function*x(e,t){for(let r=e.values.length-1;r>=0;r-=1)yield O(e.values[r],e.blockHeight,t)}function*N(e,t){const{values:r}=e;if(r.length>0){const n=r[r.length-1];yield O(n,e.blockHeight,t)}}async function*P(){let e,t;for(;;){const r=await y();if(r===e){await(0,a.E)(u).jitter(l);continue}const n=await I(r);if(0===n.length){await(0,a.E)(u).jitter(l);continue}const o=$(r,n);e=r,void 0!==t&&K(t,n)||(yield*N(o,r),t=n)}}async function*j(e){let t;for(;;){if(t=await I(e),0!==t.length){const r=$(e,t);yield*C(r,e);break}await(0,a.E)(u).jitter(l),e=await y()}for(;;){const r=await y();if(r<=e){await(0,a.E)(u).jitter(l);continue}let n=r,o=await I(n);if(0===o.length){await(0,a.E)(u).jitter(l);continue}let s=$(n,o);const i=o,c=[];for(;n>e;){if(s.blockHeight>n){const{storeName:e,storeSubkey:t}=await d;throw new Error(`Corrupt storage cell for ${e} under key ${t} at block-height ${n} claims to being published at a later block height ${s.blockHeight}`)}const t=s.blockHeight-1;if(t<=e)break;const r=await I(t);if(0===r.length)break;const a=$(t,r);K(r,o)||c.push(s),o=r,s=a,n=t}for(K(o,t)||c.push(s);;){const e=c.pop();if(void 0===e)break;yield*C(e,r)}e=r,t=i}}async function*A(e){let t;for(;e>0;){if(t=await I(e),0===t.length)return;const r=$(e,t);yield*x(r,e),e=r.blockHeight-1}}return(0,a.cI)("chain follower",{getLatestIterable:async()=>P(),async getEachIterable(){let{height:e}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return void 0===e&&(e=await y()),j(e)},async getReverseIterable(){let{height:e}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return void 0===e&&(e=await y()),A(e)}})}(n,t,r):(e=>{const t=e=>harden({value:e,blockHeight:NaN,currentBlockHeight:NaN});return(0,a.cI)("subscription/notifier follower",{getLatestIterable:async()=>{const{notifier:r,subscription:n}=await e;let a;return r?a=E(r):(assert(n),a=S(n)),k(a,t)},getEachIterable:async()=>{const{notifier:r,subscription:n}=await e;let a;return n?a=S(n):(assert(r),a=E(r)),k(a,t)},getReverseIterable:async()=>{throw Error("reverse iteration not implemented for subscription follower")}})})(n)};var Q=r(3617),Y=r(3276),X=r(4275),ee=r(1845),te=r(603);const{details:re,quote:ne}=assert,ae=e=>"string"===typeof e&&!!e.match(/^board[^:]/),oe=(e,t,r)=>`${t}:${`${r}`}`,se=(e,t)=>Object.keys(e).find(t),ie=(e,t)=>{const r=se(e,(e=>t.startsWith(`${e}:`)));return{kind:r,id:r?Number(t.slice(r.length+1)):NaN}},ce=(e,t,r)=>{e.bySlot.init(t,r),e.byVal.init(r,t)},le=e=>{const t=`SEVERED: ${e.replace(/^Alleged: /,"")}`;return(0,o.cI)(t,{})};var de=r(7141),ue=r(3770);const fe=(e,t,r)=>{const{getPursesNotifier:n,dappService:a,offerService:o,issuerService:s,unserializer:i,networkConfig:c}=r,{dapps:l,addDapp:d,setDappPetname:u,deleteDapp:f,enableDapp:g}=a,p=t=>u(e,t);let h=l.get(e);if(!h){let r;const n=new Promise((t=>{r=()=>{g(e),t()}}));h={id:e,meta:{id:e},petname:t,origin:e,enable:!1,actions:{enable:r,setPetname:p,delete:()=>f(e)},approvedP:n},d(h)}return(0,ue.cI)("scoped bridge",{async addOffer(t){const r=(new Date).getTime(),n=`${r}`;return await h.approvedP,o.addOffer({id:n,instancePetname:`instance@${t.instanceHandleBoardId}`,requestContext:{dappOrigin:e,origin:e},meta:{id:`${r}`,creationStamp:r},status:"proposed",...t}),n},async suggestIssuer(e,t){await h.approvedP,s.addSuggestion(e,t)},async suggestInstallation(e,t){await h.approvedP,console.log("TODO: suggest installation",e,t)},async suggestInstance(e,t){await h.approvedP,console.log("TODO: suggest instance",e,t)},getPursesNotifier:async()=>(await h.approvedP,n()),getOffersNotifier:async()=>(await h.approvedP,o.notifier),getUnserializer:async()=>(await h.approvedP,i),getNetConfig:async()=>(await h.approvedP,c)})};var ge=r(5155);const pe="DAPPS",he=e=>{var t;return null!==(t=(0,ge.K)([pe,e]))&&void 0!==t?t:[]},ye=e=>{const t=new Map,{notifier:r,updater:a}=(0,n.Gm)(),o=()=>a.updateState([...t.values()]),s=r=>{t.set(r.origin,r),((e,t)=>{var r;const{origin:n,enable:a,petname:o}=t,s=null!==(r=he(e))&&void 0!==r?r:[];(0,ge.A)([pe,e],[...s.filter((e=>e.origin!==n)),{origin:n,enable:a,petname:o,id:n,meta:{id:n}}])})(e,r),o()},i=r=>{t.delete(r),((e,t)=>{var r;const n=null!==(r=he(e))&&void 0!==r?r:[];(0,ge.A)([pe,e],n.filter((e=>e.origin!==t)))})(e,r),o()},c=(e,r)=>{const n=t.get(e);assert(n,`Tried to set petname on undefined dapp ${e}`),s({...n,petname:r})},l=e=>{const r=t.get(e);assert(r,`Tried to enable undefined dapp ${e}`),s({...r,enable:!0})};return he(e).forEach((e=>{let r;const n=new Promise((t=>{r=()=>{l(e.origin),t()}}));t.set(e.origin,{...e,approvedP:n,actions:{enable:r,setPetname:t=>c(e.origin,t),delete:()=>i(e.origin)}}),e.enable&&r()})),o(),{dapps:t,notifier:r,addDapp:s,setDappPetname:c,deleteDapp:i,enableDapp:l}},me="OFFERS",be=e=>{var t;return null!==(t=(0,ge.K)([me,e]))&&void 0!==t?t:[]},we=(e,t)=>{var r;const n=null!==(r=be(e))&&void 0!==r?r:[];(0,ge.A)([me,e],n.filter((e=>e.id!==t)))},ve=(e,t,r)=>{const a=new Map;let o=[];const{notifier:s,updater:i}=(0,n.Gm)(),c=()=>i.updateState([...a.values(),...o]),l=t=>{a.set(t.id,t),((e,t)=>{var r;const n=null!==(r=be(e))&&void 0!==r?r:[];(0,ge.A)([me,e],[...n.filter((e=>e.id!==t.id)),t])})(e,t),c()};be(e).forEach((t=>{"decline"===t.status&&we(e,t.id),a.set(t.id,{...t})})),c();return(async()=>{for await(const t of(0,n.oV)(r))null===t||void 0===t||t.forEach((r=>{console.log("chain offer",r);const n=r.id.split("#"),s=n[n.length-1];a.has(s)&&(a.delete(s),we(e,s)),o=t,c()}))})(),{offers:a,notifier:s,addOffer:l,acceptOffer:async e=>{const r=a.get(e);return assert(r,`Tried to accept undefined offer ${e}`),t(r.spendAction)},cancelOffer:e=>{console.log("TODO: cancel offer")},declineOffer:e=>{const t=a.get(e);assert(t,`Tried to decline undefined offer ${e}`),l({...t,status:"decline"}),c()}}},Ee=e=>{const t=new Map,{notifier:r,updater:a}=(0,n.Gm)(),o=()=>a.updateState([...t.values()]),s=e=>{assert(t.has(e),`Tried to delete undefined issuer suggestion ${e}`),t.delete(e),o()};return{notifier:r,addSuggestion:(r,n)=>{t.set(n,{boardId:n,petname:r,actions:{delete:()=>s(n),accept:async t=>{const r=JSON.stringify({type:"suggestIssuer",data:{boardId:n,petname:t}});try{await e(r),s(n)}catch(a){console.error("Sign spend action failed",r)}}}}),o()}}},Se=e=>`${e}${Math.random()}`,ke="no smart wallet";var Ie=r(5114);const $e=e=>{const t=new Map,r=r=>{const{key:n,newValue:a}=r;n&&a&&((r,n)=>{const a=JSON.parse(r);assert(Array.isArray(a));const[o,s,i,c]=a,l=JSON.parse(n);if("out"!==o||!l||"string"!==typeof l.type)return;const d={...l,dappOrigin:s},u=JSON.stringify([s,i]);let f,g;if(t.has(u))[f,g]=t.get(u)||assert.fail();else{const t=e=>{console.debug("WalletConnect: message -> storage",e),window.localStorage.setItem(JSON.stringify(["in",s,i,g]),JSON.stringify(e)),g+=1},r=()=>(0,te.E)(e).getScopedBridge(s,s);console.debug("new capTP connection",{origin:s,epoch:i}),f=(0,ue.Ol)(`from ${s} at ${i}`,t,r),g=0}t.set(u,[f,g+1]),console.debug("WalletConnect: storage -> dispatch",d),f.dispatch(d),window.localStorage.removeItem(r)})(n,a)};return window.addEventListener("storage",r),()=>{window.removeEventListener("storage",r);for(const[e,r]of t.values())e.abort(Error("wallet connection cancelled"))}};var Oe=r(6758),Ce=r(5867),xe=r(18),Ne=r(7152),Pe=r(2571),je=r(8174),Ae=r(6794),Be=r(6246),Me=r(9419),We=r(5030);const He=0,Te=1,De=2,Re="Cannot sign a transaction in read only mode, connect to keplr.",Ve=(0,de.LW)((e=>{let{onClose:t,open:r,address:n,href:a,keplrConnection:o}=e;const[s,i]=(0,Q.useState)(He),[c,l]=(0,Q.useState)(null),d=e=>(0,We.jsxs)(Be.Z,{children:[(0,We.jsx)(Be.Z,{sx:{margin:"auto",display:"flex",flexDirection:"row",justifyContent:"center"},children:(0,We.jsx)(Oe.Z,{})}),(0,We.jsx)(Pe.Z,{sx:{pt:2},children:e})]}),u=(()=>{switch(s){case He:return(0,We.jsxs)("div",{children:[(0,We.jsxs)(Pe.Z,{children:[(0,We.jsx)("b",{children:"Network Config"}),":"," ",(0,We.jsx)(Me.Z,{href:a,underline:"none",color:"rgb(0, 176, 255)",children:a})]}),(0,We.jsxs)(Pe.Z,{sx:{pt:2},children:[(0,We.jsx)("b",{children:"Wallet Address:"})," ",n]}),(0,We.jsxs)(Pe.Z,{sx:{pt:2},children:["There is no smart wallet provisioned for this address yet. A fee of ",(0,We.jsx)("b",{children:"10 BLD"})," is required to create one."]})]});case Te:return d("Please approve the transaction in Keplr.");case De:return d("Awaiting smart wallet creation...");default:return(0,We.jsx)(We.Fragment,{})}})();return(0,We.jsxs)(Ce.Z,{open:r,children:[(0,We.jsxs)(xe.Z,{children:[s===He?"Create a":"Creating"," Smart Wallet"]}),(0,We.jsxs)(Ne.Z,{children:[u,c&&(0,We.jsx)(Pe.Z,{sx:{pt:2},color:"primary",children:c})]}),s===He&&(0,We.jsxs)(je.Z,{children:[(0,We.jsx)(Ae.Z,{color:"cancel",onClick:t,children:"Change Connection"}),(0,We.jsx)(Ae.Z,{onClick:()=>{const{signers:{interactiveSigner:e}}=o;e?(async e=>{l(null),i(Te);try{await e.submitProvision()}catch(t){return i(He),void l(t.message)}i(De)})(e):l(Re)},children:"Create"})]})]})}),(e=>({keplrConnection:e.keplrConnection}))),Ze=Q.forwardRef((function(e,t){let{children:r,...n}=e;return(0,We.jsx)(X.Z,{elevation:6,ref:t,variant:"filled",...n,children:r})})),ze=(0,de.LW)((e=>{var t,r;let{connectionConfig:a,setConnectionStatus:s,setBackend:i,setBackendErrorHandler:c,keplrConnection:l}=e;const[d,u]=(0,Q.useState)([]),[f,g]=(0,Q.useState)(!1),p=function(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"error";t&&(console.error(`${e}:`,t),e+=`: ${t.message}`),"error"===r&&s(de.QK.Error),u((t=>[...t,{severity:r,message:e}]))},{href:h,smartConnectionMethod:y}=a,m=y===Ie.a.KEPLR&&l?l.address:y===Ie.a.READ_ONLY?a.publicAddress:void 0,b=e=>{e.message===ke?(g(!0),s(de.QK.Error)):(i(null),p("Error in wallet backend",e))};return(0,Q.useEffect)((()=>{if(!a||a.smartConnectionMethod===Ie.a.KEPLR&&!l)return;let e,t;return(async()=>{const r=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:le;const t={purse:{bySlot:(0,ee.WS)(),byVal:(0,ee.WS)()},payment:{bySlot:(0,ee.WS)(),byVal:(0,ee.WS)()},unknown:{bySlot:(0,ee.WS)(),byVal:(0,ee.WS)()}},r={bySlot:(0,ee.WS)(),byVal:(0,ee.WS)()},n=(t,r,n)=>{if(t.bySlot.has(r))return t.bySlot.get(r);const a=e(n);return ce(t,r,a),a},a={fromBoard:(e,t)=>(assert(ae(e),re`bad board slot ${ne(e)}`),n(r,e,t)),fromMyWallet:(r,o)=>{if(!r)return e(`${r}`);const{kind:s,id:i}=ie(t,r);return s?n(t[s],i,o):a.fromBoard(r,o)}},s={fromBoard:e=>r.byVal.get(e),fromMyWallet:e=>{const r=se(t,(r=>t[r].byVal.has(e)));assert(r,re`cannot serialize unregistered ${e}`);const n=t[r].byVal.get(e);return oe(0,r,n)}},i={fromBoard:(0,o.AU)(s.fromBoard,a.fromBoard,{marshalName:"fromBoard"}),fromMyWallet:(0,o.AU)(s.fromMyWallet,a.fromMyWallet,{marshalName:"fromMyWallet"})};return harden({initBoardId:(e,t)=>{ce(r,e,t)},ensureBoardId:(e,t)=>{r.byVal.has(t)?assert.equal(r.byVal.get(t),e):ce(r,e,t)},fromMyWallet:(0,o.cI)("wallet marshaller",{...i.fromMyWallet}),fromBoard:(0,o.cI)("board marshaller",{...i.fromBoard})})}(),a=v(h),d=function(e,t,r,a,s,i){let c=arguments.length>6&&void 0!==arguments[6]?arguments[6]:e=>{throw e},l=arguments.length>7&&void 0!==arguments[7]?arguments[7]:()=>{};const d={getPursesNotifier:"purses",getContactsNotifier:"contacts",getIssuersNotifier:"issuers",getOffersNotifier:"offers",getPaymentsNotifier:"payments"},u=Object.fromEntries(Object.entries(d).map((e=>{let[t,r]=e;return[r,(0,n.Gm)(null)]}))),f={},g=new Map,p=new Map,h=()=>{const e=[];for(const[t,r]of g.entries())r.currentAmount&&r.brandPetname&&(p.set(r.pursePetname,t),e.push(r));u.purses.updater.updateState(harden(e))},y=async()=>{let t;for await(const{blockHeight:r}of $(e))t=r;assert(t,ke);for await(const{value:r}of I(e,{height:t})){const e=r;switch(l&&(l(),Object.values(u).forEach((e=>{let{updater:t}=e;return t.updateState([])})),l=void 0),e.updated){case"brand":{const{descriptor:t}=e,r={...g.get(t.brand),brand:t.brand,brandPetname:t.petname,pursePetname:t.petname,displayInfo:t.displayInfo};g.set(t.brand,r),h();break}case"balance":{const{currentAmount:t}=e,r={...g.get(t.brand),currentAmount:t,value:t.value};g.set(t.brand,r),h();break}case"offerStatus":{const{status:t}=e;console.log("offerStatus",{status:t,offers:f});const r=f[t.id];if(!r){console.warn("Update for unknown offer, doing nothing.");break}"error"in t?f[t.id]={...r,id:`${t.id}`,status:"rejected",error:`${t.error}`}:"accept"!==r.status&&"numWantsSatisfied"in t&&(f[t.id]={...r,id:`${t.id}`,status:"accept"}),u.offers.updater.updateState(harden(Object.values(f)));break}default:throw Error(`Unknown updateRecord ${e.updated}`)}}},m=()=>{y().catch((e=>{e.message===ke?setTimeout(m,5e3):c(e)}))};y().catch((e=>{c(e),e.message===ke&&setTimeout(m,5e3)}));const b=Object.fromEntries(Object.entries(d).map((e=>{let[t,r]=e;const{notifier:n}=u[r];return[t,()=>n]}))),w=()=>{console.log("make empty purse")},v=()=>{console.log("add contact")},E=()=>{console.log("add issuer")},S=e=>{const{signers:{interactiveSigner:t}}=s;if(!t)throw new Error("Cannot sign a transaction in read only mode, connect to keplr.");return t.submitSpendAction(e)},k=Ee(S),O=ye(a),C=ve(a,S,b.getOffersNotifier()),{acceptOffer:x,declineOffer:N,cancelOffer:P}=C,j=async e=>{const{id:t,instanceHandleBoardId:n,invitationMaker:{method:a},proposalTemplate:{give:o,want:s}}=e,i=e=>Object.fromEntries(Object.entries(e).map((e=>{let[t,{brand:r,pursePetname:n,value:a}]=e;return[t,{brand:r||p.get(n),value:BigInt(a)}]}))),c={id:(new Date).getTime(),invitationSpec:{source:"contract",instance:n,publicInvitationMaker:a},proposal:{give:i(o),want:i(s)}},l=await(0,te.E)(r).serialize(harden({method:"executeOffer",offer:c})),{slots:[d]}=await(0,te.E)(r).serialize(n),u={...e,instancePetname:`instance@${d}`,spendAction:JSON.stringify(l)};return C.addOffer(u),f[t]=u,t};return(0,o.cI)("follower wallet bridge",{...b,getDappsNotifier:()=>O.notifier,getOffersNotifier:()=>C.notifier,getIssuerSuggestionsNotifier:()=>k.notifier,acceptOffer:x,declineOffer:N,cancelOffer:P,makeEmptyPurse:w,addContact:v,addIssuer:E,getScopedBridge:(e,n)=>fe(e,n,{dappService:O,offerService:{...C,addOffer:j},leader:t,unserializer:r,publicAddress:a,issuerService:k,networkConfig:i,...b})})}(G(`:published.wallet.${m}`,a,{unserializer:r.fromMyWallet}),a,r.fromBoard,m,l,h,b,(()=>{s(de.QK.Connected),g(!1)})),{backendIt:u,cancel:f}=(e=>{const t=async e=>(0,n.oV)(e)[Symbol.asyncIterator](),{notifier:r}=(0,n.Gm)(harden({board:(0,te.E)(e).getBoard()})),a=harden({actions:(0,o.cI)("schemaActions",{createPurse:function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Se("Purse");return(0,te.E)(e).makeEmptyPurse(null===t||void 0===t?void 0:t.issuerPetname,r)},createContact:function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Se("Contact");return(0,te.E)(e).addContact(r,t)},createIssuer:function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Se("Issuer");return(0,te.E)(e).addIssuer(r,t,!0)}}),services:t(r),contacts:t((0,te.E)(e).getContactsNotifier()),dapps:t((0,te.E)(e).getDappsNotifier()),issuers:t((0,te.E)(e).getIssuersNotifier()),offers:(s=t((0,te.E)(e).getOffersNotifier()),harden({next:async()=>{const{done:t,value:r}=await(0,te.E)(s).next();return harden({done:t,value:r&&r.map((t=>{let{id:r,...n}=t;return harden({id:r,...n,actions:(0,o.cI)("offerActions",{accept:()=>(0,te.E)(e).acceptOffer(r),decline:()=>(0,te.E)(e).declineOffer(r),cancel:()=>(0,te.E)(e).cancelOffer(r)})})}))})},return:s.return,throw:s.throw})),payments:t((0,te.E)(e).getPaymentsNotifier()),purses:t((0,te.E)(e).getPursesNotifier()),issuerSuggestions:t((0,te.E)(e).getIssuerSuggestionsNotifier())});var s;const{notifier:i,updater:c}=(0,n.Gm)(a);return{backendIt:t(i),cancel:e=>{c.fail(e)}}})(d);return t=$e(d),e=f,c((()=>b)),(0,n.uO)(u,{updateState:t=>{e&&i(t)},fail:t=>{e&&b(t)},finish:t=>{e&&i(t)}})})().catch((e=>p("Cannot read Smart Wallet casting",e))),()=>{e&&e(),e=void 0,t&&t(),t=void 0}}),[a,l]),(0,We.jsxs)("div",{children:[(0,We.jsx)(Y.Z,{open:d.length>0,children:(0,We.jsx)(Ze,{onClose:(e,t)=>{"clickaway"!==t&&u((e=>e.slice(1)))},severity:null===(t=d[0])||void 0===t?void 0:t.severity,sx:{width:"100%"},children:null===(r=d[0])||void 0===r?void 0:r.message})}),(0,We.jsx)(Ve,{open:f,onClose:()=>{g(!1)},address:m,href:h})]})}),(e=>({connectionConfig:e.connectionConfig,setConnectionStatus:e.setConnectionStatus,setBackend:e.setBackend,setBackendErrorHandler:e.setBackendErrorHandler,keplrConnection:e.keplrConnection})))}}]);
//# sourceMappingURL=492.ce5eb81f.chunk.js.map