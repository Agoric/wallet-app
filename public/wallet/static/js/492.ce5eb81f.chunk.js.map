{"version":3,"file":"static/js/492.ce5eb81f.chunk.js","mappings":"kMAQO,MAAMA,EAAoB,yBAgBpBC,EAAQC,GAAM,IAAIC,SAAQC,GAAWC,WAAWD,EAASF,KAMzDI,EAAgB,SAACC,GAAuB,IAAhBC,EAAgB,uDAAVD,EACzC,OAAOE,KAAKC,SAAWD,KAAKE,IAAIH,EAAKD,EACtC,EAOYK,EAAqB,WAA6C,IAA5CC,EAA4C,uDAAlC,EAAGC,EAA+B,uDAAxB,IAAON,EAAiB,uDAAX,IAClE,OAAOF,EAAc,GAAKO,EAAUC,EAAMN,EAC3C,EAQYO,EAAiBC,IAC5B,MAAMC,EAASX,EAAcY,KAE7B,OADAC,QAAQC,MAAO,aAAYJ,QAAYP,KAAKY,KAAKJ,QAC1ChB,EAAMgB,EAAb,EAWWK,EAAyB,SAACN,EAAOO,GAAqB,IAAhBV,EAAgB,uDAAN,EAC3D,MAAMW,EAAUZ,EAAmBC,GAKnC,OAJAM,QAAQM,IACL,YAAWT,QAAYP,KAAKY,KAAKG,uBAA6BX,IAC/DU,GAEKtB,EAAMuB,EACd,EAOYE,EAAuB,IAClCzB,EAAMK,EAAcqB,MAAuCC,MAAK,KAAM,IAE3DC,EAAuB,IAM3BC,QAAOC,IACZ,IACE,OAAOD,OAAOE,KAAKC,MAAMF,GAG1B,CAFC,MAAOG,GACP,MAAM,IAAIC,MAAO,+BAA8BD,EAAME,aAAaL,IACnE,KASQM,EAA4B,KACvC,MAAMC,EAAqB,YAErBC,EAAO,IAAIC,IAajB,OAAOC,EAAAA,EAAAA,IAAI,uBAAwB,CACjCC,aAAaC,EAAAA,EAAAA,SAAYC,GAbT,CAACC,EAAMC,KAEvB,GAAIP,EAAKQ,IAAIF,GACX,OAAON,EAAKS,IAAIH,GAEG,kBAAVC,GAAsBA,EAAMG,WAAWX,KAChDQ,EAAQA,EAAMI,MAAMZ,EAAmBa,SAEzC,MAAMC,GAAMX,EAAAA,EAAAA,IAAK,YAA4BK,IAAS,CAAC,GAEvD,OADAP,EAAKc,IAAIR,EAAMO,GACRA,CAAP,IAG+CV,aADjD,EC5GWY,EAAUC,IACrB,IAAK,IAAIC,EAAID,EAAEJ,OAAS,EAAGK,EAAI,EAAGA,GAAK,EAAG,CACxC,MAAMC,EAAIhD,KAAKiD,MAAMjD,KAAKC,UAAY8C,EAAI,IACpCG,EAAIJ,EAAEC,GACZD,EAAEC,GAAKD,EAAEE,GACTF,EAAEE,GAAKE,CACR,GCJUC,EAA4BC,UACvC,MAAM,YAAEC,EAAcpC,SAA+BqC,EAAAA,EAAAA,GAAEC,GAAQC,aAEzDC,GAAWzB,EAAAA,EAAAA,IAAI,mCAAoC,CACvD,CAAC0B,OAAOC,eAAgB,KAEtB,IAAIC,EACJ,OAAO5B,EAAAA,EAAAA,IAAI,mCAAoC,CAC7C6B,KAAMT,UACCQ,IACHA,EAAkBP,EAAY,2BAA2BlC,MACvD2C,GACMA,GACKR,EAAAA,EAAAA,GAAEC,GACN/C,OAAO,2BACPW,MAAK,IAAM2C,IAETA,KAIb,MAAMC,QAAkBH,EACxBA,OAAkBzB,EAClB,MAAM6B,EAAS3C,OAAO,CAEpB4C,OAAQ,KAEV,OAAO5C,OAAO,CACZ6C,MAAOF,EACPG,MAAOJ,GAFT,GApBJ,IA6BJ,OAAO/B,EAAAA,EAAAA,IAAI,0BAA2B,CACpCoC,kBAAmBhB,SAAYK,EAC/BY,gBAAiBjB,SAAYK,EAC7Ba,mBAAoBlB,UAClB,MAAM1B,MAAM,8CAAZ,GAJJ,GCrCM6C,QAASC,GAAMC,OAOVC,EAA6B,CAACC,EAAUC,KACnDH,OAAOI,MAAMC,QAAQH,GAAWH,CAAE,YAAWG,sBAW7C,OChBkC,SAACI,GAAkC,IAAvBH,EAAuB,uDAAP,CAAC,EAC/D,MAAM,cAAEI,EAAgBnE,EAAlB,OAA0CL,EAASF,GACvDsE,EAIF/B,EAAQkC,GAER,IAEIE,EAFAC,EAA8B,EAC9BC,EAAc,EAIlB,MAAM5B,GAASvB,EAAAA,EAAAA,IAAI,qBAAsB,CACvCwB,WAAY,IAAMoB,EAClBpE,OAAQ4C,SAAe5C,GAAUA,EAAOD,GACxC6E,MAAOhC,MAAO7C,EAAOO,EAAKV,KACxB,GAAI4E,EACF,OAAOA,EAAczE,EAAOO,EAAKV,GAEnC,MAAMU,CAAN,EAGFuE,aAAcC,GAAiBC,EAM/BC,aAAcpC,MAAO7C,EAAOkF,KAC1BlF,EAAS,GAAEA,4BAED,IAAIb,SAAQ,CAACC,EAAS+F,KAC9B,IAAIC,EAAgBT,EAEpB,MAAME,EAAQtE,IACZ,IAAKmE,EAAU,CACb,MAAM7E,EAAU+E,EAChBF,GAAW3B,EAAAA,EAAAA,GAAEC,GACV6B,MAAM7E,EAAOO,EAAKV,GAClBe,MAAK,KACJwE,GAAiBA,EAAgB,GAAKZ,EAAUrC,OAChDuC,EAAW,IAAX,GAEL,CAEDA,EACG9D,MAAK,IAAMX,GAAUA,EAAOD,KAE5BY,KAAKyE,EAAUF,GAClBP,GAAe,CAAf,EAGIS,EAAW,KACflG,QAAQC,UACLwB,MAAK,IAAMsE,EAASV,EAAUY,MAC9BxE,MAAK0E,IACJlG,EAAQ0B,OAAO,CAACwE,KAChBX,EAA8BS,EAC9BR,EAAc,CAAd,GACCC,EANL,EAWFQ,GAAU,OAMVL,EAAwBpC,EAA0BI,GACxD,OAAOA,CACR,CDzDQuC,CATUnB,EAASoB,KAAIC,IAC5BvB,OAAOwB,OAAOD,EAAS,SAAUxB,CAAE,WAAUwB,sBAKtCA,EAAQE,SAAS,OAASF,EAAW,UAASA,OAGjBpB,EAAtC,EAOWuB,EAA8B,SAACC,GAA+B,IAAjBC,EAAiB,uDAAP,CAAC,EACnE,MAAM,cAAErB,EAAgBnE,EAAlB,OAA0CL,EAASF,GACvD+F,EAEIjB,EAAQhC,MAAO7C,EAAOO,EAAKV,KAC/B,GAAI4E,EACF,OAAOA,EAAczE,EAAOO,EAAKV,GAEnC,MAAMU,CAAN,EAEF,IAAIV,EAAU,EACd,MAAMG,EAAQ,wBACd,OAAO,IAAIb,SAAQ,CAACC,EAAS+F,KAC3B,MAAMY,EAAalD,UACjB,MAAMmD,QAAiBC,MAAMJ,EAAc,CACzCK,QAAS,CAAEC,OAAQ,uBAEf,SAAE/B,SAAmB4B,EAASI,OAGpC,OADAvG,EAAU,EACHsE,EAA2BC,EAAU0B,EAA5C,EAEIO,EAAcxD,UAClBgC,EAAM7E,EAAOO,EAAKV,GACfe,MAAK,IAAMX,EAAOD,KAClBY,MAAK,IAAMmF,IAAanF,KAAKxB,EAASiH,KACtCC,MAAMnB,GACTtF,GAAW,CAAX,EAEFkG,IAAanF,KAAKxB,EAASiH,EAA3B,GAEH,EAOYN,EAAa,WAA4C,IAA3CQ,EAA2C,uDAA/BvH,EAAmB8G,EAAY,uCACpE,OAAIS,EAAUZ,SAAS,kBACdC,EAA4BW,EAAWT,GAEzC3B,EAA2B,CAACoC,GAAYT,EAChD,EErEYU,EAAuBC,IAClCC,EAAAA,EAAAA,KAAa3D,EAAAA,EAAAA,GAAE0D,GAAUE,gCA4BdC,EAA2BC,GACtC/F,OAAO,CACL,CAACqC,OAAOC,eAAgB,KACtB0D,OAtB2BC,GAuBzBhE,EAAAA,EAAAA,GAAE8D,GAAcG,oCApBfvF,EAAAA,EAAAA,IAAI,uBAAwB,CACjC6B,KAAMT,UACJ,MAAMoE,EAAUlE,EAAAA,EAAAA,IAAMgE,GAAOG,KAE7B,OADAH,EAAQhE,EAAAA,EAAAA,IAAMgE,GAAOI,KACdF,CAAP,IAP2BF,KAoBxB,IAcIK,EAAmB,CAAClE,EAAUmE,IACzCxE,kBACE,UAAW,MAAMc,KAAST,QAClBmE,EAAU1D,EAEnB,CACM2D,GA6BIC,EAAc,CAACC,EAAU1B,KAEpCrE,EAAAA,EAAAA,IAAI,uBAAwB,CAE1B,CAAC0B,OAAOC,eAAgB,KACtB,MAAMqE,GAAe1E,EAAAA,EAAAA,GAAEyE,GAAU1D,gBAAgBgC,GAC3C4B,GAAW3E,EAAAA,EAAAA,GAAE0E,GAActE,OAAOC,iBACxC,OAAO3B,EAAAA,EAAAA,IAAI,uBAAwB,CACjC6B,KAAM,KAAMP,EAAAA,EAAAA,GAAE2E,GAAUpE,QAD1B,IAWOqE,EAAiB,CAACH,EAAU1B,KAEvCrE,EAAAA,EAAAA,IAAI,0BAA2B,CAE7B,CAAC0B,OAAOC,eAAgB,KACtB,MAAMqE,GAAe1E,EAAAA,EAAAA,GAAEyE,GAAUzD,mBAAmB+B,GAC9C4B,GAAW3E,EAAAA,EAAAA,GAAE0E,GAActE,OAAOC,iBACxC,OAAO3B,EAAAA,EAAAA,IAAI,uBAAwB,CACjC6B,KAAM,KAAMP,EAAAA,EAAAA,GAAE2E,GAAUpE,QAD1B,I,mEC3GN,MAAM,QAAEsE,GAAYC,EAYdC,EAAsB,IAAIC,WAAW,GACrCC,EAAoB,IAAIC,WAAW,CAAC,IAOpCC,EAA4B,SAACC,GAAwC,IAA3BC,EAA2B,uDAAf,WAC1D,MAAMC,EAAQF,EAAcA,EAAYG,MAAM,KAAO,GAC/CC,EAAMX,EAAS,GAAES,EAAMlG,UAAUgG,KACvC,OAAOrH,OAAO,CACZsH,YACAI,YAAaD,EAAI/C,KAAIiD,GAAMA,IAAMX,EAAsB,EAAIW,IAC3DC,gBAAiBV,GAEpB,EAOYW,EAAyB7H,OAAO,CAC3C,YA9BgCqH,GAChCrH,OAAO,CACLsH,UAAW,WACXI,YAAaZ,EAAS,iBAAgBO,OA4BxC,UAAWD,EACX,IARoCA,IA6BhCU,EAAK,IAAIC,YAMFC,EAA4BC,IACvC,MAAM,UAAEX,EAAF,YAAaI,EAAb,gBAA0BE,EAA1B,aAA2C7B,EAA3C,SAAyDJ,GAC7DsC,EACF,GAAIlC,GAAgBJ,EAClB,OAAO3F,OAAO,CACZ+F,eACAJ,aAGJ,IAAIuC,EAASR,EACc,kBAAhBA,IACTQ,EAASJ,EAAGK,OAAOT,IAErB,IAAIU,EAAaR,EAIjB,MAH+B,kBAApBA,IACTQ,EAAaN,EAAGK,OAAOP,IAElB5H,OAAO,CACZsH,YACAI,YAAaQ,EACbN,gBAAiBQ,GAHnB,EAsBWC,EAAkBtG,UAC7B,MAAMuG,QAAaC,EACnB,GAAoB,kBAATD,EACT,MA9DqCE,KACvCpF,OAAOwB,OAAO4D,EAAY,UAC1B,MAAMC,EAAQD,EAAWC,MAAM,kBAC/BrF,OACEqF,EACC,eAAcD,6CAEjB,MAAME,EAAOD,EAAM,GACbE,EAAYF,EAAM,GAClBG,EAAYf,EAAuBa,GAEzC,OADAtF,OAAOwF,EAAY,oBAAmBF,KAC/BE,EAAUD,EAAjB,EAmDSE,CAA0BP,GAGnC,MAAM,UAAEhB,EAAF,aAAavB,EAAb,SAA2BJ,GAAa2C,EAC9C,OAAIhB,GAAavB,GAAgBJ,EACxBqC,EAA0BM,IAE/BQ,EAAAA,EAAAA,IAAeR,GArBiBvG,WACpC,MAAMkG,QAAgBhG,EAAAA,EAAAA,GAAE8G,GAASC,cACjC,OAAOhB,EAA0BC,EAAjC,EAoBSgB,CAAuBX,QAEhClF,OAAO8F,KAAM,eAAcZ,oCAA3B,GC/GI,YAAEa,GAAgBC,GAClB,mBAAEC,GAAuBC,GACvBpG,QAASC,EAAGoG,MAAOC,GAAMpG,OAC3BqG,EAAc,IAAIC,YAclBC,EAAeC,GACnBA,GACgB,kBAATA,GACPpG,MAAMC,QAAQmG,EAAKhH,SACS,kBAArBgH,EAAKC,aACZ,oBAAoBC,KAAKF,EAAKC,aAM1BE,EAAa,CAACtI,EAAGkG,KACrB,GAAIlG,EAAEJ,SAAWsG,EAAEtG,OACjB,OAAO,EAET,IAAK,IAAIK,EAAI,EAAGA,EAAID,EAAEJ,OAAQK,GAAK,EACjC,GAAID,EAAEC,KAAOiG,EAAEjG,GACb,OAAO,EAGX,OAAO,CAAP,EAGIsI,EAAyB,IAAI7C,WAO7B8C,EAAgBrH,IAEpB,MAAMwD,EAAO,GACb,IAAI8D,EAAQ,EACZ,IAAK,MAAMrH,KAASD,EAClBsH,GAAS,EACK,IAAVA,EACF9D,EAAK+D,KAAKtH,GAEVO,OAAO8F,KAAM,uCAAsCgB,KAKvD,OADA9G,OAAOgH,MAAMhE,EAAK/E,OAAQ,EAAG,yBACtB+E,EAAK,EAAZ,EAIIiE,EAAS,CAAC,SAAU,OAAQ,cCjBrBC,EAAevI,MAAOwI,EAAOC,EAAexF,KACvD,MAAMsD,QAAaD,EAAgBkC,IAC7B,UAAEjD,GAAcgB,EACtB,OAAIhB,EDuB4B,SAChCiB,GAGG,IAFHiC,EAEG,uDAFaC,EAChBzF,EACG,uDADO,CAAC,EAEX,MAAM,OACJ0F,EAAS3K,IADL,aAEJ4K,EAAepK,IAFX,MAGJqK,EAAQ,aAHJ,QAIJC,EAAU,MACR7F,EAKE8F,EAAQrL,IAMZ,MALIoL,IACF5I,EAAAA,EAAAA,GAAE4I,GACCC,MAAO,gDAAgDrL,GACvD+F,OAAMuF,GAAK3H,OAAO8F,KAAK/F,CAAE,6BAA4B4H,OAEpDtL,CAAN,EAGF2D,OAAOiH,EAAOxF,SAAS+F,GAAQzH,CAAE,oCAAmCyH,KAEpE,MAAM1L,EAAQ,kBACR8L,EAAe3C,EAAgBE,GAE/BrG,EACqB,oBAAlBsI,EAA+BA,IAAkBA,EAEpDS,EAAqB,IAAIvK,IAKzBwK,EAA0BC,IAC9B,IAAIC,EAAUH,EAAmB/J,IAAIiK,GAKrC,OAJKC,IACHA,EAAU/B,EAAmBgC,QAAQF,GACrCF,EAAmB1J,IAAI4J,EAAUC,IAE5BA,CAAP,EAGIE,EAAiBvJ,UACrB,MAAMa,QAAeX,EAAAA,EAAAA,GAAEC,GAAQiC,aAAajF,GAAO6C,UACjD,MAAMwJ,QAAeL,EAAwBC,GACvCK,QAAaD,EAAOE,YACpB,gBAAEC,GAAoBF,EAE5B,OADApI,OAAOwB,OAAO8G,EAAiB,UACxBA,CAAP,IAEF,OAAOzB,EAAcrH,EAArB,EAII+I,EAAwB,IAAIjL,IAK5BkL,EAAqB7J,UACzB,GAAI4J,EAAsB1K,IAAIkK,GAAW,CAEvC,MAAMU,EAAcF,EAAsBzK,IAAIiK,GAE9C,OADA/H,OAAOyI,GACAA,CACR,CAED,MAAMC,QAAkBZ,EAAwBC,GAC1CU,EAAc1C,EAAY4C,eAAeD,GAE/C,OADAH,EAAsBpK,IAAI4J,EAAUU,GAC7BA,CAAP,EAMIG,EAA6BjK,UACjC,MAAM,UACJuF,EADI,YAEJI,EAFI,gBAGJE,EAAkBoC,SACVgB,EAEV5H,OAAOwB,OACL0C,EACA,SACAnE,CAAE,mCAAkCmE,KAEtClE,OACEsE,EACAvE,CAAE,yCAAwCuE,KAI5C,MAAM9E,QAAeX,EAAAA,EAAAA,GAAEC,GAAQiC,aAAajF,GAAO6C,SACjDkK,EAAmBd,EAAU7D,EAAWI,GAAa5H,MACnDoM,IACS,CAAEA,SAAQ9L,MAAO,SAE1BA,IACS,CAAE8L,OAAQ,KAAM9L,eAKvB,OAAE8L,EAAF,MAAU9L,GAAU6J,EAAcrH,GACxC,GAAc,OAAVxC,EACF,MAAMA,EAIR,OAFAgD,OAAO8I,GAEe,IAAlBA,EAAO7K,OAEF6K,GAIT9I,OACE8I,EAAO7K,QAAUuG,EAAgBvG,OACjC8B,CAAE,oCAAmCyE,KAEvCxE,OACE2G,EAAWmC,EAAOC,SAAS,EAAGvE,EAAgBvG,QAASuG,GACvDzE,CAAE,GAAE+I,oCAAyCtE,KAExCsE,EAAO9K,MAAMwG,EAAgBvG,QAApC,EAOI+K,EAAwBrK,SACrBiK,GACLjK,MAAOoJ,EAAU7D,EAAWI,KAC1B,MAAMmE,QAAoBD,EAAmBT,GAC7C,OAAOlJ,EAAAA,EAAAA,GAAE4J,GAAaQ,cAAc/E,EAAWI,EAAa4E,EAA5D,IAQAC,EAA0BxK,SACvBiK,GACLjK,MAAOoJ,EAAU7D,EAAWI,KAC1B,MAAM6D,QAAeL,EAAwBC,GACvCjG,QAAiBqG,EAAOiB,UAAU,CACtCC,KAAO,SAAQnF,QACfoF,KAAMhF,EACN4E,SACAK,OAAO,IAET,GAAsB,IAAlBzH,EAAS0H,KACX,MAAM,IAAIvM,MAAO,iCAAgC6E,EAASvF,OAE5D,MAAM,MAAEkD,GAAUqC,EAClB,OAAOrC,CAAP,IAQAgK,EAAqB9K,UACzB,GAAc,WAAV6I,EAEF,OAAOwB,EAAsBvC,GAAarE,MAAMsF,GAC3C,GAAc,SAAVF,EAET,OAAO2B,EAAwB1C,GAC1B,GAAc,eAAVe,EAAwB,CACjC,MAAMkC,QAAoBP,EAAwB1C,GAelD,OAZAuC,EAAsBvC,GAAa/J,MAAKiN,IAClChD,EAAWgD,EAAYD,IAG3BhC,EACE1H,OAAOhD,MACL+C,CAAE,iBAAgB2J,yBAAmCC,KAFzD,GAKCjC,GAGIgC,CACR,CAED1J,OAAO8F,KACL/F,CAAE,6BAA4BqG,EAC5BoB,iDAFJ,EAUIoC,EAAkBjL,UACtB,IAAK,IAAIhD,EAAU,GAAKA,GAAW,EACjC,IAEE,aAAa8N,EAAmBhD,EAMjC,CALC,MAAOzJ,SAGD6B,EAAAA,EAAAA,GAAEC,GAAQ6B,MAAM7E,EAAOkB,EAAOrB,GACpC,QACD,CACF,EAOGkO,EAAoB,CAACpD,EAAa6C,KACtC,MAAMQ,EAAOzD,EAAYiB,OAAOgC,GAChC,IACE,MAAM9C,EAAO1J,KAAKC,MAAM+M,GACxB,GAAIvD,EAAaC,GACf,OAAO5J,OAAO,CACZ6J,YAAasD,OAAOvD,EAAKC,aACzBjH,OAAQgH,EAAKhH,OAAO8B,IAAIgG,IAS7B,CAHC,MAGD,CAMD,OAAO1K,OAAO,CACZ6J,cACAjH,OAAQ,CAAC8H,EAAOwC,KAFlB,EAYIE,EAAqCrL,MACzC2K,EACA7C,EACAwD,KAMO,CAAExK,YAFP8H,GAAe1I,EAAAA,EAAAA,GAAE0I,GAAc/J,YAAY8L,GAAQA,GAErC7C,cAAawD,uBAQ/B,SAAUC,EAAkBC,EAAYF,GACtC,IAAK,MAAMX,KAAQa,EAAW3K,aACtBwK,EACJV,EACAa,EAAW1D,YACXwD,EAGL,CAOD,SAAUG,EAAsBD,EAAYF,GAC1C,IAAK,IAAI3L,EAAI6L,EAAW3K,OAAOvB,OAAS,EAAGK,GAAK,EAAGA,GAAK,QAChD0L,EACJG,EAAW3K,OAAOlB,GAClB6L,EAAW1D,YACXwD,EAGL,CAOD,SAAUI,EAAkBF,EAAYF,GACtC,MAAM,OAAEzK,GAAW2K,EACnB,GAAI3K,EAAOvB,OAAS,EAAG,CACrB,MAAMqM,EAAO9K,EAAOA,EAAOvB,OAAS,SAC9B+L,EACJM,EACAH,EAAW1D,YACXwD,EAEH,CACF,CAKDtL,eAAgBgB,IACd,IAAI8G,EACA6C,EACJ,OAAS,CACP,MAAMW,QAA2B/B,IACjC,GAAI+B,IAAuBxD,EAAa,OAGhC5H,EAAAA,EAAAA,GAAEC,GAAQ/C,OAAOD,GACvB,QACD,CAED,MAAMyO,QAAoBX,EAAgBK,GAC1C,GAA2B,IAAvBM,EAAYtM,OAAc,OAGtBY,EAAAA,EAAAA,GAAEC,GAAQ/C,OAAOD,GACvB,QACD,CACD,MAAM0O,EAAoBX,EACxBI,EACAM,GAGF9D,EAAcwD,OAODvM,IAAT4L,GAAsB3C,EAAW2C,EAAMiB,WAMpCF,EAAkBG,EAAmBP,GAC5CX,EAAOiB,EACR,CACF,CAMD5L,eAAgB8L,EAAwBC,GAItC,IAAIC,EAKJ,OAAS,CAEP,GADAA,QAAmBf,EAAgBc,GACT,IAAtBC,EAAW1M,OAAc,CAC3B,MAAM2M,EAAmBf,EACvBa,EACAC,SAEKT,EAAkBU,EAAkBF,GAC3C,KACD,OAGK7L,EAAAA,EAAAA,GAAEC,GAAQ/C,OAAOD,GACvB4O,QAA0BxC,GAC3B,CAID,OAAS,CACP,MAAM+B,QAA2B/B,IAEjC,GAAI+B,GAAsBS,EAAmB,OAGrC7L,EAAAA,EAAAA,GAAEC,GAAQ/C,OAAOD,GACvB,QACD,CASD,IAAI+O,EAAmBZ,EACnBa,QAAkBlB,EAAgBiB,GACtC,GAAyB,IAArBC,EAAU7M,OAAc,OAGpBY,EAAAA,EAAAA,GAAEC,GAAQ/C,OAAOD,GACvB,QACD,CACD,IAAIiP,EAAkBlB,EAAkBgB,EAAkBC,GAI1D,MAAMP,EAAcO,EACdE,EAAQ,GACd,KAAOH,EAAmBH,GAAmB,CAC3C,GAAIK,EAAgBtE,YAAcoE,EAAkB,CAClD,MAAM,UAAE3G,EAAF,YAAaI,SAAsBsD,EACzC,MAAM,IAAI3K,MACP,4BAA2BiH,eAAuBI,qBAA+BuG,uDAAsEE,EAAgBtE,cAE3K,CACD,MAAMwE,EAAkBF,EAAgBtE,YAAc,EAEtD,GAAIwE,GAAmBP,EACrB,MAEF,MAAMQ,QAAiBtB,EAAgBqB,GAGvC,GAAwB,IAApBC,EAASjN,OACX,MAEF,MAAMkN,EAAiBtB,EAAkBoB,EAAiBC,GASrDvE,EAAWuE,EAAUJ,IACxBE,EAAMjE,KAAKgE,GAIbD,EAAYI,EACZH,EAAkBI,EAClBN,EAAmBI,CACpB,CAUD,IANKtE,EAAWmE,EAAWH,IACzBK,EAAMjE,KAAKgE,KAKJ,CACP,MAAMvE,EAAOwE,EAAMI,MACnB,QAAa1N,IAAT8I,EACF,YAEK0D,EAAkB1D,EAAMyD,EAChC,CAGDS,EAAoBT,EACpBU,EAAaJ,CACd,CACF,CAMD5L,eAAgB0M,EAA2BX,GAIzC,IAAIC,EACJ,KAAOD,EAAoB,GAAG,CAE5B,GADAC,QAAmBf,EAAgBc,GACT,IAAtBC,EAAW1M,OAEb,OAEF,MAAM2M,EAAmBf,EAAkBa,EAAmBC,SACvDP,EAAsBQ,EAAkBF,GAC/CA,EAAoBE,EAAiBnE,YAAc,CACpD,CACF,CAGD,OAAOlJ,EAAAA,EAAAA,IAAI,iBAAkB,CAC3BoB,kBAAA,SACSgB,IAEThB,wBAAmD,IAA7B,OAAEuK,GAA2B,uDAAJ,CAAC,EAI9C,YAHexL,IAAXwL,IACFA,QAAehB,KAEVuC,EAAwBvB,EAChC,EACDvK,2BAAsD,IAA7B,OAAEuK,GAA2B,uDAAJ,CAAC,EAIjD,YAHexL,IAAXwL,IACFA,QAAehB,KAEVmD,EAA2BnC,EACnC,GAEJ,CChiBUoC,CAAmBpG,EAAMkC,EAAexF,GAjDlBsD,KAC/B,MAAM/B,EAAY1D,GAChB7C,OAAO,CAAE6C,QAAOgH,YAAa8E,IAAKtB,mBAAoBsB,MAiCxD,OA/BiBhO,EAAAA,EAAAA,IAAI,iCAAkC,CACrDoC,kBAAmBhB,UACjB,MAAM,SAAE4D,EAAF,aAAYI,SAAuBuC,EACzC,IAAIsG,EAOJ,OANIjJ,EACFiJ,EAAKlJ,EAAqBC,IAE1BvC,OAAO2C,GACP6I,EAAK9I,EAAyBC,IAEzBO,EAAiBsI,EAAIrI,EAA5B,EAGFvD,gBAAiBjB,UACf,MAAM,SAAE4D,EAAF,aAAYI,SAAuBuC,EACzC,IAAIsG,EAOJ,OANI7I,EACF6I,EAAK9I,EAAyBC,IAE9B3C,OAAOuC,GACPiJ,EAAKlJ,EAAqBC,IAErBW,EAAiBsI,EAAIrI,EAA5B,EAGFtD,mBAAoBlB,UAClB,MAAM1B,MACJ,8DADF,GAKJ,EAgBOwO,CAAyBvG,EAAhC,E,uDC7DF,MAAQpF,QAASC,GAAGoG,MAAOC,IAAMpG,OAa3B0L,GAAYC,GACW,kBAAbA,KAA2BA,EAAStG,MAAM,cAsBpDuG,GAAiB,CAACC,EAASvG,EAAMwG,IAE7B,GAAExG,KAD6B,GAAEwG,MAUrCC,GAAU,CAACC,EAAQC,IACXC,OAAOC,KAAKH,GAAQI,KAAKH,GAUjCI,GAAkB,CAACC,EAAQ3O,KAC/B,MAAM2H,EAAOyG,GAAQO,GAAQC,GAAK5O,EAAKI,WAAY,GAAEwO,QAErD,MAAO,CAAEjH,OAAMwG,GADJxG,EAAOyE,OAAOpM,EAAKK,MAAMsH,EAAKrH,OAAS,IAAMsN,IACxD,EAiCIiB,GAAc,CAACC,EAAO9O,EAAM+O,KAChCD,EAAME,OAAOC,KAAKjP,EAAM+O,GACxBD,EAAMI,MAAMD,KAAKF,EAAK/O,EAAtB,EAmIImP,GAAsBlP,IAC1B,MAAMmP,EAAW,YAAWnP,EAAMoP,QAAQ,aAAc,MACxD,OAAOzP,EAAAA,EAAAA,IAAIwP,EAAS,CAAC,EAArB,E,0BCxOK,MAAME,GAAkB,CAACC,EAAQC,EAAsBC,KAC5D,MAAM,kBACJC,EADI,YAEJC,EAFI,aAGJC,EAHI,cAIJC,EAJI,aAKJjG,EALI,cAMJkG,GACEL,GAEE,MAAEM,EAAF,QAASC,EAAT,eAAkBC,EAAlB,WAAkCC,EAAlC,WAA8CC,GAClDR,EAEIS,EAAaC,GAAWJ,EAAeV,EAAQc,GAErD,IAAIC,EAAOP,EAAM5P,IAAIoP,GACrB,IAAKe,EAAM,CACT,IAAIC,EACJ,MAAMC,EAAY,IAAIlT,SAAQmG,IAC5B8M,EAAe,KACbJ,EAAWZ,GACX9L,GAAK,CAFP,IAMF6M,EAAO,CACLnC,GAAIoB,EACJkB,KAAM,CAAEtC,GAAIoB,GACZc,QAASb,EACTD,SACAmB,QAAQ,EACRC,QAAS,CACPD,OAAQH,EACRH,aACAQ,OAAQ,IAAMV,EAAWX,IAE3BiB,aAEFR,EAAQM,EACT,CAED,OAAO1Q,EAAAA,GAAAA,IAAI,gBAAiB,CAC1BoB,eAAe6P,GACb,MAAMC,GAAc,IAAIC,MAAOC,UACzB7C,EAAM,GAAE2C,IAad,aAZMR,EAAKE,UACXZ,EAAaqB,SAAS,CACpB9C,KACA+C,gBAAkB,YAAWL,EAAOM,wBACpCC,eAAgB,CAAEC,WAAY9B,EAAQA,UACtCkB,KAAM,CACJtC,GAAK,GAAE2C,IACPQ,cAAeR,GAEjBS,OAAQ,cACLV,IAEE1C,CACR,EACDnN,oBAAoBqP,EAASmB,SACrBlB,EAAKE,UACXX,EAAc4B,cAAcpB,EAASmB,EACtC,EACDxQ,0BAA0BqP,EAASmB,SAC3BlB,EAAKE,UACXlS,QAAQM,IAAI,6BAA8ByR,EAASmB,EACpD,EACDxQ,sBAAsBqP,EAASmB,SACvBlB,EAAKE,UACXlS,QAAQM,IAAI,yBAA0ByR,EAASmB,EAChD,EACDxQ,kBAAA,gBACQsP,EAAKE,UAEJd,KAET1O,kBAAA,gBACQsP,EAAKE,UAEJZ,EAAahL,UAEtB5D,gBAAA,gBACQsP,EAAKE,UACJ5G,GAET5I,aAAA,gBACQsP,EAAKE,UACJV,IA9CX,E,eCzCF,MAAM4B,GAAmB,QAEZC,GAAYC,IAAa,wBACpCC,EAAAA,GAAAA,GAAU,CAACH,GAAkBE,WADO,QACY,EADZ,ECMzBE,GAAiBF,IAC5B,MAAM7B,EAAQ,IAAIpQ,KACZ,SAAEiF,EAAF,QAAYmN,IAAYC,EAAAA,EAAAA,MACxBC,EAAmB,IAAMF,EAAQG,YAAY,IAAInC,EAAMlO,WAEvDsQ,EAAa7B,IACjBP,EAAMvP,IAAI8P,EAAKf,OAAQe,GDTD,EAACsB,EAAetB,KAAU,IAAD,EACjD,MAAM,OAAEf,EAAF,OAAUmB,EAAV,QAAkBL,GAAYC,EAE9BP,EAAK,UAAG4B,GAAUC,UAAb,QAA+B,IAC1CQ,EAAAA,GAAAA,GACE,CAACV,GAAkBE,GACnB,IACK7B,EAAMsC,QAAOC,GAAKA,EAAE/C,SAAWA,IAClC,CAAEA,SAAQmB,SAAQL,UAASlC,GAAIoB,EAAQkB,KAAM,CAAEtC,GAAIoB,KAJvD,ECMEgD,CAAOX,EAAetB,GACtB2B,GAAkB,EAGd/B,EAAaX,IACjBQ,EAAMa,OAAOrB,GDFS,EAACqC,EAAerC,KAAY,IAAD,EACnD,MAAMQ,EAAK,UAAG4B,GAAUC,UAAb,QAA+B,IAC1CQ,EAAAA,GAAAA,GACE,CAACV,GAAkBE,GACnB7B,EAAMsC,QAAOC,GAAKA,EAAE/C,SAAWA,IAFjC,ECCEiD,CAAOZ,EAAerC,GACtB0C,GAAkB,EAGdhC,EAAiB,CAACV,EAAQc,KAC9B,MAAMC,EAAOP,EAAM5P,IAAIoP,GACvBlN,OAAOiO,EAAO,0CAAyCf,KACvD4C,EAAW,IAAK7B,EAAMD,WAAtB,EAGIF,EAAaZ,IACjB,MAAMe,EAAOP,EAAM5P,IAAIoP,GACvBlN,OAAOiO,EAAO,kCAAiCf,KAC/C4C,EAAW,IAAK7B,EAAMI,QAAQ,GAA9B,EA6BF,OA1BoB+B,GAAKb,GACbc,SAAQJ,IAClB,IAAI/B,EACJ,MAAMC,EAAY,IAAIlT,SAAQmG,IAC5B8M,EAAe,KACbJ,EAAWmC,EAAE/C,QACb9L,GAAK,CAFP,IAMFsM,EAAMvP,IAAI8R,EAAE/C,OAAQ,IACf+C,EACH9B,YACAG,QAAS,CACPD,OAAQH,EACRH,WAAYC,GAAWJ,EAAeqC,EAAE/C,OAAQc,GAChDO,OAAQ,IAAMV,EAAWoC,EAAE/C,WAI3B+C,EAAE5B,QACJH,GACD,IAEH0B,IAEO,CACLlC,QACAnL,WACAoL,QAASmC,EACTlC,iBACAC,aACAC,aANF,EC/DIwC,GAAoB,SAEbC,GAAahB,IAAa,wBACrCC,EAAAA,GAAAA,GAAU,CAACc,GAAmBf,WADO,QACY,EADZ,EAW1BiB,GAAc,CAACjB,EAAezD,KAAQ,IAAD,EAChD,MAAM2E,EAAM,UAAGF,GAAWhB,UAAd,QAAgC,IAC5CQ,EAAAA,GAAAA,GACE,CAACO,GAAmBf,GACpBkB,EAAOT,QAAOU,GAAKA,EAAE5E,KAAOA,IAF9B,ECFW6E,GAAkB,CAC7BpB,EACAqB,EACAC,KAEA,MAAMJ,EAAS,IAAInT,IACnB,IAAIwT,EAAc,GAClB,MAAM,SAAEvO,EAAF,QAAYmN,IAAYC,EAAAA,EAAAA,MACxBC,EAAmB,IACvBF,EAAQG,YAAY,IAAIY,EAAOjR,YAAasR,IAExCC,EAAcC,IAClBP,EAAOtS,IAAI6S,EAAMlF,GAAIkF,GDpBD,EAACzB,EAAeyB,KAAW,IAAD,EAChD,MAAMP,EAAM,UAAGF,GAAWhB,UAAd,QAAgC,IAC5CQ,EAAAA,GAAAA,GACE,CAACO,GAAmBf,GACpB,IAAIkB,EAAOT,QAAOU,GAAKA,EAAE5E,KAAOkF,EAAMlF,KAAKkF,GAF7C,ECmBEC,CAAI1B,EAAeyB,GACnBpB,GAAkB,EAoBCQ,GAAKb,GACbc,SAAQK,IACF,YAAbA,EAAExB,QACJiB,GAAOZ,EAAemB,EAAE5E,IAE1B2E,EAAOtS,IAAIuS,EAAE5E,GAAI,IACZ4E,GADL,IAIFd,IAqBA,MAnByBjR,WACvB,UAAW,MAAMuS,KAASC,EAAAA,EAAAA,IACxBN,GAEK,OAALK,QAAK,IAALA,GAAAA,EAAOb,SAAQW,IACb/U,QAAQM,IAAI,cAAeyU,GAC3B,MAAMI,EAAUJ,EAAMlF,GAAG1H,MAAM,KACzBiN,EAAQD,EAAQA,EAAQnT,OAAS,GACnCwS,EAAO5S,IAAIwT,KACbZ,EAAOlC,OAAO8C,GACdlB,GAAOZ,EAAe8B,IAExBP,EAAcI,EACdtB,GAAkB,GAErB,EAEH0B,GAEO,CACLb,SACAlO,WACAqM,SAAUmC,EACVQ,YA5CkB5S,UAClB,MAAMqS,EAAQP,EAAO3S,IAAIgO,GAEzB,OADA9L,OAAOgR,EAAQ,mCAAkClF,KAC1C8E,EAAgBI,EAAMQ,YAA7B,EA0CAC,YAvCkBC,IAClBzV,QAAQM,IAAI,qBAAZ,EAuCAoV,aArDmB7F,IACnB,MAAMkF,EAAQP,EAAO3S,IAAIgO,GACzB9L,OAAOgR,EAAQ,oCAAmClF,KAClDiF,EAAY,IAAKC,EAAO9B,OAAQ,YAChCU,GAAkB,EA2CpB,EC1EWgC,GAAmBhB,IAC9B,MAAMiB,EAAc,IAAIvU,KAElB,SAAEiF,EAAF,QAAYmN,IAAYC,EAAAA,EAAAA,MACxBC,EAAmB,IAAMF,EAAQG,YAAY,IAAIgC,EAAYrS,WAE7DsS,EAAmB3C,IACvBnP,OACE6R,EAAYhU,IAAIsR,GACf,+CAA8CA,KAEjD0C,EAAYtD,OAAOY,GACnBS,GAAkB,EA0BpB,MAAO,CACLrN,WACA6M,cAzBoB,CAACpB,EAASmB,KAC9B0C,EAAY1T,IAAIgR,EAAS,CACvBA,UACAnB,UACAM,QAAS,CACPC,OAAQ,IAAMuD,EAAiB3C,GAC/BlN,OAAQtD,UACN,MAAMoT,EAASjV,KAAKkV,UAAU,CAC5BC,KAAM,gBACN3I,KAAM,CAAE6F,UAASnB,QAASkE,KAE5B,UACQtB,EAAgBmB,GACtBD,EAAiB3C,EAGlB,CAFC,MAAOxH,GACP1L,QAAQe,MAAM,2BAA4B+U,EAC3C,MAIPnC,GAAkB,EAGpB,EC/BIuC,GAAQ7M,GAAS,GAAEA,IAAO/J,KAAKC,WACxB4W,GAAwB,kB,eCV9B,MAAMC,GAAwBjF,IAEnC,MAAMkF,EAAa,IAAIhV,IA2CjBiV,EAAkBC,IACtB,MAAM,IAAEC,EAAF,SAAOC,GAAaF,EAEtBC,GAAOC,GA5CgB,EAACD,EAAKC,KACjC,MAAMC,EAAW7V,KAAKC,MAAM0V,GAC5BzS,OAAOI,MAAMC,QAAQsS,IACrB,MAAOC,EAAK1F,EAAQ2F,EAAOC,GAAiCH,EACtDI,EAAUjW,KAAKC,MAAM2V,GAC3B,GAAY,QAARE,IAAkBG,GAAmC,kBAAjBA,EAAQd,KAC9C,OAGF,MAAM/T,EAAM,IACP6U,EACH/D,WAAY9B,GAER8F,EAAUlW,KAAKkV,UAAU,CAAC9E,EAAQ2F,IAExC,IAAII,EAEAC,EACJ,GAAIZ,EAAWzU,IAAImV,IAChBC,EAAMC,GAAMZ,EAAWxU,IAAIkV,IAAYhT,OAAO8F,WAC1C,CAEL,MAAMqN,EAAOC,IACXnX,QAAQC,MAAM,oCAAqCkX,GACnDC,OAAOC,aAAaC,QAClBzW,KAAKkV,UAAU,CAAC,KAAM9E,EAAQ2F,EAAOK,IACrCpW,KAAKkV,UAAUoB,IAEjBF,GAAM,CAAN,EAEIM,EAAW,KAAM3U,EAAAA,GAAAA,GAAEuO,GAAQH,gBAAgBC,EAAQA,GACzDjR,QAAQC,MAAM,uBAAwB,CAAEgR,SAAQ2F,UAChDI,GAAOQ,EAAAA,GAAAA,IAAW,QAAOvG,QAAa2F,IAASM,EAAMK,GACrDN,EAAK,CACN,CACDZ,EAAWnU,IAAI6U,EAAS,CAACC,EAAMC,EAAK,IACpCjX,QAAQC,MAAM,qCAAsCgC,GACpD+U,EAAKS,SAASxV,GACdmV,OAAOC,aAAaK,WAAWlB,EAA/B,EAOEmB,CAAqBnB,EAAKC,EAC3B,EAIH,OAFAW,OAAOQ,iBAAiB,UAAWtB,GAE5B,KACLc,OAAOS,oBAAoB,UAAWvB,GACtC,IAAK,MAAOU,EAAMH,KAAQR,EAAW9S,SAEnCyT,EAAKc,MAAM9W,MAAM,+BAClB,CALH,E,gHC5CF,MAAM+W,GACK,EADLA,GAEe,EAFfA,GAGS,EAGTC,GACO,iEAyGb,IAAeC,EAAAA,GAAAA,KAnGS,IAAwD,IAAvD,QAAEC,EAAF,KAAWC,EAAX,QAAiBC,EAAjB,KAA0BC,EAA1B,gBAAgCC,GAAsB,EAC7E,MAAOC,EAAaC,IAAkBC,EAAAA,EAAAA,UAASV,KACxChX,EAAO2X,IAAYD,EAAAA,EAAAA,UAAS,MA2B7BE,EAAoB9K,IACxB,WAAC+K,GAAA,EAAD,YACE,UAACA,GAAA,EAAD,CACEC,GAAI,CACFC,OAAQ,OACRC,QAAS,OACTC,cAAe,MACfC,eAAgB,UALpB,UAQE,UAACC,GAAA,EAAD,OAEF,UAACC,GAAA,EAAD,CAAmBN,GAAI,CAAEO,GAAI,GAA7B,SAAmCvL,OAIjCwL,EAAU,MACd,OAAQd,GACN,KAAKR,GACH,OACE,6BACE,WAACoB,GAAA,EAAD,YACE,2CADF,IACyB,KACvB,UAACG,GAAA,EAAD,CAAMjB,KAAMA,EAAMkB,UAAU,OAAOC,MAAM,mBAAzC,SACGnB,QAGL,WAACc,GAAA,EAAD,CAAmBN,GAAI,CAAEO,GAAI,GAA7B,WACE,4CADF,IAC0BhB,MAE1B,WAACe,GAAA,EAAD,CAAmBN,GAAI,CAAEO,GAAI,GAA7B,kFAEK,wBA/DI,WA6DT,oCAMN,KAAKrB,GACH,OAAOY,EAAkB,4CAC3B,KAAKZ,GACH,OAAOY,EAAkB,qCAC3B,QACE,OAAO,0BAzBG,KA6BhB,OACE,WAACc,GAAA,EAAD,CAAQtB,KAAMA,EAAd,WACE,WAACuB,GAAA,EAAD,WACGnB,IAAgBR,GAAgB,WAAa,WADhD,oBAGA,WAAC4B,GAAA,EAAD,WACGN,EACAtY,IACC,UAACoY,GAAA,EAAD,CAAmBN,GAAI,CAAEO,GAAI,GAAKI,MAAM,UAAxC,SACGzY,OAINwX,IAAgBR,KACf,WAAC6B,GAAA,EAAD,YACE,UAACC,GAAA,EAAD,CAAQL,MAAM,SAASM,QAAS5B,EAAhC,gCAGA,UAAC2B,GAAA,EAAD,CAAQC,QA3EkB,KAChC,MACEC,SAAS,kBAAEC,IACT1B,EACC0B,EAjBiBtX,WACtBgW,EAAS,MACTF,EAAeT,IACf,UACQkC,EAAOC,iBAKd,CAJC,MAAOxO,GAGP,OAFA8M,EAAeT,SACfW,EAAShN,EAAEzK,QAEZ,CACDuX,EAAeT,GAAf,EAYAoC,CAAgBH,GAJdtB,EAASV,GAIX,EAkEM,yBAlBR,IAyBqDoC,IAAO,CAC5D9B,gBAAiB8B,EAAQ9B,oBC1GrB+B,GAAQC,EAAAA,YAAiB,WAAuCC,GAAM,IAA9B,SAAEC,KAAaC,GAAc,EACzE,OACE,UAAC,IAAD,CAAUC,UAAW,EAAGH,IAAKA,EAAKI,QAAQ,YAAaF,EAAvD,SACGD,GAGN,IA6ID,IAAevC,EAAAA,GAAAA,KA3Ie,IAMvB,IAAD,QANyB,iBAC7B2C,EAD6B,oBAE7BC,EAF6B,WAG7BC,EAH6B,uBAI7BC,EAJ6B,gBAK7BzC,GACI,EACJ,MAAO0C,EAAkBC,IAAuBxC,EAAAA,EAAAA,UAAS,KAClDyC,EAAqBC,IAA0B1C,EAAAA,EAAAA,WAAS,GAczD2C,EAAY,SAACna,EAASyK,GAA2B,IAAxB2P,EAAuB,uDAAZ,QACpC3P,IACF1L,QAAQe,MAAO,GAAEE,KAAYyK,GAC7BzK,GAAY,KAAIyK,EAAEzK,WAEH,UAAboa,GACFR,EAAoBS,GAAAA,GAAAA,OAEtBL,GAAoBM,GAAM,IAAIA,EAAI,CAAEF,WAAUpa,aAC/C,GAEK,KAAEoX,EAAF,sBAAQmD,GAA0BZ,EAElCtH,EAEFkI,IAA0BC,GAAAA,EAAAA,OAC1BnD,EAEOA,EAAgBF,QACdoD,IAA0BC,GAAAA,EAAAA,UAC5Bb,EAAiBtH,mBADnB,EAMHoI,EAAehQ,IACfA,EAAEzK,UAAYkV,IAChBgF,GAAuB,GACvBN,EAAoBS,GAAAA,GAAAA,SAEpBR,EAAW,MACXM,EAAU,0BAA2B1P,GACtC,EAgEH,OA7DAiQ,EAAAA,EAAAA,YAAU,KACR,IACGf,GACAA,EAAiBY,wBAA0BC,GAAAA,EAAAA,QACzCnD,EAEH,OAGF,IAAIsD,EACAC,EA2CJ,MAzCenZ,WACb,MAAM0X,EViJqB,WAAwC,IAAvC0B,EAAuC,uDAAxBjL,GAC/C,MAAMkL,EAAgB,CAEpBC,MAAO,CACLtL,QAAQuL,EAAAA,GAAAA,MACRrL,OAAOqL,EAAAA,GAAAA,OAGTC,QAAS,CACPxL,QAAQuL,EAAAA,GAAAA,MACRrL,OAAOqL,EAAAA,GAAAA,OAGTE,QAAS,CACPzL,QAAQuL,EAAAA,GAAAA,MACRrL,OAAOqL,EAAAA,GAAAA,QAILG,EAAe,CACnB1L,QAAQuL,EAAAA,GAAAA,MACRrL,OAAOqL,EAAAA,GAAAA,OAUHI,EAAa,CAAC7L,EAAO9O,EAAMC,KAC/B,GAAI6O,EAAME,OAAO9O,IAAIF,GACnB,OAAO8O,EAAME,OAAO7O,IAAIH,GAE1B,MAAM+O,EAAMqL,EAAana,GAEzB,OADA4O,GAAYC,EAAO9O,EAAM+O,GAClBA,CAAP,EAGI6L,EAAY,CAKhBC,UAAW,CAAC7a,EAAMC,KAChBoC,OAAO0L,GAAU/N,GAAOoC,EAAE,kBAAiBqG,GAAEzI,MACtC2a,EAAWD,EAAc1a,EAAMC,IAOxC6a,aAAc,CAAC9a,EAAMC,KACnB,IAAKD,EAEH,OAAOoa,EAAc,GAAEpa,KAEzB,MAAM,KAAE2H,EAAF,GAAQwG,GAAOO,GAAgB2L,EAAera,GACpD,OAAO2H,EACHgT,EAAWN,EAAc1S,GAAOwG,EAAIlO,GACpC2a,EAAUC,UAAU7a,EAAMC,EAF9B,GAME8a,EAAY,CAChBF,UAAW9L,GAAO2L,EAAaxL,MAAM/O,IAAI4O,GAEzC+L,aAAc/L,IACZ,MAAMpH,EAAOyG,GAAQiM,GAAezL,GAAKyL,EAAczL,GAAGM,MAAMhP,IAAI6O,KACpE1M,OAAOsF,EAAMvF,EAAE,iCAAgC2M,KAE/C,MAAMZ,EAAKkM,EAAc1S,GAAMuH,MAAM/O,IAAI4O,GACzC,OAAOd,GAAeoM,EAAe1S,EAAMwG,EAA3C,GAIE6M,EAAU,CACdH,WAAW/a,EAAAA,EAAAA,IAAYib,EAAUF,UAAWD,EAAUC,UAAW,CAC/DI,YAAa,cAEfH,cAAchb,EAAAA,EAAAA,IAAYib,EAAUD,aAAcF,EAAUE,aAAc,CACxEG,YAAa,kBAIjB,OAAOhc,OAAO,CAKZic,YAAa,CAAC/M,EAAIY,KAChBF,GAAY6L,EAAcvM,EAAIY,EAA9B,EAMFoM,cAAe,CAAChN,EAAIY,KACd2L,EAAaxL,MAAMhP,IAAI6O,GACzB1M,OAAOgH,MAAMqR,EAAaxL,MAAM/O,IAAI4O,GAAMZ,GAG5CU,GAAY6L,EAAcvM,EAAIY,EAA9B,EAEF+L,cAAclb,EAAAA,EAAAA,IAAI,oBAAqB,IAAKob,EAAQF,eACpDD,WAAWjb,EAAAA,EAAAA,IAAI,mBAAoB,IAAKob,EAAQH,aAEnD,CU9PqBO,GACVja,EAAS+C,EAAWyS,GAOpBlH,EHGgC,SAC1C9J,EACAxE,EACAka,EACAzJ,EACAgF,EACA9G,GAMI,IALJwL,EAKG,uDALYtR,IAEb,MAAMA,CAAN,EAEFuR,EACG,uDADa,OAEhB,MAAMC,EAAY,CAChB9L,kBAAmB,SACnB+L,oBAAqB,WACrBC,mBAAoB,UACpBC,kBAAmB,SACnBC,oBAAqB,YAGjBC,EAAetN,OAAOuN,YAC1BvN,OAAOwN,QAAQP,GAAW7X,KAAI,QAAEqY,EAASC,GAAX,QAA0B,CACtDA,GACAjK,EAAAA,EAAAA,IAAgB,MAFY,KAO1Bc,EAAS,CAAC,EACVoJ,EAAe,IAAIvc,IACnBwc,EAAsB,IAAIxc,IAE1Byc,EAAe,KACnB,MAAMC,EAAS,GACf,IAAK,MAAOC,EAAOhC,KAAU4B,EAAaH,UACpCzB,EAAMiC,eAAiBjC,EAAMkC,eAC/BL,EAAoB3b,IAAI8Z,EAAMmC,aAAcH,GAC5CD,EAAOjT,KAAKkR,IAGhBuB,EAAaQ,OAAOtK,QAAQG,YAAYjT,OAAOod,GAA/C,EAGIK,EAAe1b,UAEnB,IAAI2b,EACJ,UAAW,MAAM,YAAE7T,KAAiBhD,EAAeH,GAEjDgX,EAAc7T,EAEhBzG,OAAOsa,EAAalI,IACpB,UAAW,MAAM,MAAE3S,KAAW4D,EAAYC,EAAU,CAClD4F,OAAQoR,IACN,CAEF,MAAMC,EAAe9a,EAQrB,OAPIyZ,IACFA,IACAhN,OAAO1M,OAAOga,GAAcnJ,SAAQ,QAAC,QAAEX,GAAH,SAClCA,EAAQG,YAAY,GADc,IAGpCqJ,OAAgBxb,GAEV6c,EAAaC,SACnB,IAAK,QAAS,CACZ,MAAM,WAAEC,GAAeF,EACjBG,EAAW,IACZb,EAAa/b,IAAI2c,EAAWR,OAC/BA,MAAOQ,EAAWR,MAClBE,aAAcM,EAAWzM,QACzBoM,aAAcK,EAAWzM,QACzB2M,YAAaF,EAAWE,aAE1Bd,EAAa1b,IAAIsc,EAAWR,MAAOS,GACnCX,IACA,KACD,CACD,IAAK,UAAW,CAGd,MAAM,cAAEG,GAAkBK,EACpBG,EAAW,IACZb,EAAa/b,IAAIoc,EAAcD,OAClCC,gBACAza,MAAOya,EAAcza,OAEvBoa,EAAa1b,IAAI+b,EAAcD,MAAOS,GACtCX,IACA,KACD,CACD,IAAK,cAAe,CAClB,MAAM,OAAE7K,GAAWqL,EACnBte,QAAQM,IAAI,cAAe,CAAE2S,SAAQuB,WACrC,MAAMmK,EAAWnK,EAAOvB,EAAOpD,IAC/B,IAAK8O,EAAU,CACb3e,QAAQ4e,KAAK,4CACb,KACD,CACG,UAAW3L,EACbuB,EAAOvB,EAAOpD,IAAM,IACf8O,EACH9O,GAAK,GAAEoD,EAAOpD,KACdoD,OAAQ,WACRlS,MAAQ,GAAEkS,EAAOlS,SAGC,WAApB4d,EAAS1L,QACT,sBAAuBA,IAEvBuB,EAAOvB,EAAOpD,IAAM,IACf8O,EACH9O,GAAK,GAAEoD,EAAOpD,KACdoD,OAAQ,WAGZsK,EAAa/I,OAAOf,QAAQG,YAC1BjT,OAAOsP,OAAO1M,OAAOiR,KAEvB,KACD,CACD,QACE,MAAMxT,MAAO,wBAAuBsd,EAAaC,WAGtD,GAGG7Z,EAAQ,KACZ0Z,IAAejY,OAAMuF,IACfA,EAAEzK,UAAYkV,GAChBjX,WAAWwF,EAAO,KAElBsY,EAAatR,EACd,GALH,EASF0S,IAAejY,OAAMuF,IACnBsR,EAAatR,GACTA,EAAEzK,UAAYkV,IAChBjX,WAAWwF,EAAO,IACnB,IAGH,MAAMma,EAAqB5O,OAAOuN,YAChCvN,OAAOwN,QAAQP,GAAW7X,KAAI,IAA0B,IAAxByZ,EAAQnB,GAAe,EACrD,MAAM,SAAErX,GAAaiX,EAAaI,GAClC,MAAO,CAACmB,EAAQ,IAAMxY,EAAtB,KAIEyY,EAAiB,KACrB/e,QAAQM,IAAI,mBAAZ,EAGI0e,EAAa,KACjBhf,QAAQM,IAAI,cAAZ,EAGI2e,EAAY,KAChBjf,QAAQM,IAAI,aAAZ,EAGIqU,EAAkBtH,IACtB,MACE0M,SAAS,kBAAEC,IACT1B,EACJ,IAAK0B,EACH,MAAM,IAAIhZ,MACR,kEAGJ,OAAOgZ,EAAkBkF,kBAAkB7R,EAA3C,EAGIkE,EAAgBoE,GAAiBhB,GACjCtD,EAAcmC,GAAeF,GAC7BhC,EAAeoD,GACnBpB,EACAqB,EACAkK,EAAmBxB,sBAEf,YAAE/H,EAAF,aAAeI,EAAf,YAA6BF,GAAgBlE,EAI7C6N,EAAkBzc,UACtB,MAAM,GACJmN,EACAgD,sBAAuBuM,EACvBC,iBAAiB,OAAEP,GACnBQ,kBAAkB,KAAEC,EAAF,KAAQC,IACxB3b,EAEE4b,EAAYxd,GAChBgO,OAAOuN,YACLvN,OAAOwN,QAAQxb,GAAKoD,KAAI,QAAEqa,GAAI,MAAE1B,EAAF,aAASG,EAAT,MAAuB3a,IAA7B,QAA0C,CAChEkc,EACA,CACE1B,MAAOA,GAASH,EAAoBhc,IAAIsc,GACxC3a,MAAOmc,OAAOnc,IAJM,KAQtBuR,EAAQ,CACZlF,IAAI,IAAI4C,MAAOC,UACfkN,eAAgB,CACdC,OAAQ,WACRT,WACAU,sBAAuBhB,GAEzBiB,SAAU,CACRR,KAAME,EAAUF,GAChBC,KAAMC,EAAUD,KAGdjK,QAAoB3S,EAAAA,GAAAA,GAAEma,GAAYiD,UACtCrf,OAAO,CACLme,OAAQ,eACR/J,YAMFkL,OAAQC,UACAtd,EAAAA,GAAAA,GAAEma,GAAYiD,UAAUZ,GAE5Be,EAAY,IACbtc,EACH+O,gBAAkB,YAAWsN,IAC7B3K,YAAa1U,KAAKkV,UAAUR,IAI9B,OAFAjE,EAAaqB,SAASwN,GACtB3L,EAAO3E,GAAMsQ,EACNtQ,CAAP,EA2BF,OAxBqBvO,EAAAA,EAAAA,IAAI,yBAA0B,IAC9Cud,EACHuB,iBAAkB,IAAM/O,EAAY/K,SACpC+W,kBAAmB,IAAM/L,EAAahL,SACtC+Z,6BAA8B,IAAM9O,EAAcjL,SAClDgP,cACAI,eACAF,cACAuJ,iBACAC,aACAC,YACAjO,gBAAiB,CAACC,EAAQC,IACxBF,GAAgBC,EAAQC,EAAsB,CAC5CG,cACAC,aAAc,IAAKA,EAAcqB,SAAUwM,GAC3Ctc,SACAyI,aAAcyR,EACdzJ,gBACA/B,gBACAC,mBACGqN,KAKV,CG3QoByB,CANErV,EACd,qBAAoBqI,IACrBzQ,EACA,CAAEyI,aAAc8O,EAAQoC,eAKxB3Z,EACAuX,EAAQmC,UACRjJ,EACAgF,EACAD,EACAqD,GACA,KACEb,EAAoBS,GAAAA,GAAAA,WACpBH,GAAuB,EAAvB,KAGE,UAAEoF,EAAF,OAAaC,GHtGkBC,KAKzC,MAAMC,EAAkBhe,UACtBwS,EAAAA,EAAAA,IAA8B5O,GAAUtD,OAAOC,kBAEzCqD,SAAUqa,IAAqBjN,EAAAA,EAAAA,IACrC/S,OAAO,CACLigB,OAAOhe,EAAAA,GAAAA,GAAE6d,GAAcI,cAkCrBC,EAAcngB,OAAO,CACzB0R,SAAS/Q,EAAAA,EAAAA,IAAI,gBAAiB,CAC5Byf,YAAa,SAACC,GAAD,IAASnR,EAAT,uDAAcqG,GAAM,SAApB,OACXtT,EAAAA,GAAAA,GAAE6d,GAAc1B,eAAhB,OAA+BiC,QAA/B,IAA+BA,OAA/B,EAA+BA,EAAQC,cAAepR,EAD3C,EAEbqR,cAAe,SAACC,GAAD,IAAetR,EAAf,uDAAoBqG,GAAM,WAA1B,OACbtT,EAAAA,GAAAA,GAAE6d,GAAczB,WAAWnP,EAAIsR,EADlB,EAEfC,aAAc,SAACJ,GAAD,IAASnR,EAAT,uDAAcqG,GAAM,UAApB,OACZtT,EAAAA,GAAAA,GAAE6d,GAAcxB,UAAUpP,EAAImR,GAAQ,EAD1B,IAGhBK,SAAUX,EAAgBC,GAC1BW,SAAUZ,GAAgB9d,EAAAA,GAAAA,GAAE6d,GAActD,uBAC1C1L,MAAOiP,GAAgB9d,EAAAA,GAAAA,GAAE6d,GAAcL,oBACvCmB,QAASb,GAAgB9d,EAAAA,GAAAA,GAAE6d,GAAcrD,sBACzC5I,QAxCyBgN,EAyCvBd,GAAgB9d,EAAAA,GAAAA,GAAE6d,GAAcpD,qBAxClC1c,OAAO,CACLwC,KAAMT,UACJ,MAAM,KAAEe,EAAF,MAAQD,SAAgBZ,EAAAA,GAAAA,GAAE4e,GAAere,OAC/C,OAAOxC,OAAO,CACZ8C,OACAD,MACEA,GACAA,EAAM6B,KAAI,QAAC,GAAEwK,KAAO4R,GAAV,SACR9gB,OAAO,CACLkP,QACG4R,EACHpP,SAAS/Q,EAAAA,EAAAA,IAAI,eAAgB,CAE3B0E,OAAQ,KAAMpD,EAAAA,GAAAA,GAAE6d,GAAcnL,YAAYzF,GAC1C6R,QAAS,KAAM9e,EAAAA,GAAAA,GAAE6d,GAAc/K,aAAa7F,GAC5C2Q,OAAQ,KAAM5d,EAAAA,GAAAA,GAAE6d,GAAcjL,YAAY3F,MARtC,KAJd,EAkBF8R,OAAQH,EAAcG,OACtBC,MAAOJ,EAAcI,SAoBvBC,SAAUnB,GAAgB9d,EAAAA,GAAAA,GAAE6d,GAAcnD,uBAC1CS,OAAQ2C,GAAgB9d,EAAAA,GAAAA,GAAE6d,GAAcrP,qBACxC0Q,kBAAmBpB,GACjB9d,EAAAA,GAAAA,GAAE6d,GAAcJ,kCA9COmB,MAqD3B,MAAQlb,SAAUyb,EAAiBtO,QAASuO,IAC1CtO,EAAAA,EAAAA,IAAgBoN,GAQlB,MAAO,CAAEP,UANSG,EAAgBqB,GAMdvB,OAJL9U,IACbsW,EAAenY,KAAK6B,EAApB,EAGF,EGuBkCuW,CAA4B9Q,GAK1D,OAJA0K,EAAuBzF,GAAsBjF,GAC7CyK,EAAiB4E,EAEjBzF,GAAuB,IAAMW,KACtBwG,EAAAA,EAAAA,IAAgB3B,EAAW,CAChC3M,YAAauO,IACXvG,GAAkBd,EAAWqH,EAA7B,EAEFtY,KAAM6B,IACJkQ,GAAkBF,EAAahQ,EAA/B,EAEF0W,OAAQD,IACNvG,GAAkBd,EAAWqH,EAA7B,GARJ,EAYFE,GAASlc,OAAMuF,GAAK0P,EAAU,mCAAoC1P,KAE3D,KACLkQ,GAAkBA,IAClBA,OAAiBna,EACjBoa,GAAwBA,IACxBA,OAAuBpa,CAAvB,CAJF,GAMC,CAACmZ,EAAkBtC,KAGpB,6BACE,UAACgK,EAAA,EAAD,CAAUnK,KAAM6C,EAAiBhZ,OAAS,EAA1C,UACE,UAACqY,GAAD,CACEnC,QA5GoB,CAACqK,EAAGC,KACf,cAAXA,GAIJvH,GAAoBM,GAAMA,EAAGxZ,MAAM,IAAnC,EAwGMsZ,SAAQ,UAAEL,EAAiB,UAAnB,aAAE,EAAqBK,SAC/BxC,GAAI,CAAE4J,MAAO,QAHf,mBAKGzH,EAAiB,UALpB,aAKG,EAAqB/Z,aAG1B,UAAC,GAAD,CACEkX,KAAM+C,EACNhD,QAzHyB,KAC7BiD,GAAuB,EAAvB,EAyHI/C,QAAS9E,EACT+E,KAAMA,MAfZ,IAqB2D+B,IAAO,CAClEQ,iBAAkBR,EAAQQ,iBAC1BC,oBAAqBT,EAAQS,oBAC7BC,WAAYV,EAAQU,WACpBC,uBAAwBX,EAAQW,uBAChCzC,gBAAiB8B,EAAQ9B,mB","sources":["../../../casting/src/defaults.js","../../../casting/src/shuffle.js","../../../casting/src/change-follower.js","../../../casting/src/leader-netconfig.js","../../../casting/src/leader.js","../../../casting/src/iterable.js","../../../casting/src/casting-spec.js","../../../casting/src/follower-cosmjs.js","../../../casting/src/follower.js","../../api/src/marshal-contexts.js","service/ScopedBridge.js","store/Dapps.js","service/Dapps.js","store/Offers.js","service/Offers.js","service/Issuers.js","util/WalletBackendAdapter.js","util/BridgeStorage.js","components/ProvisionDialog.jsx","components/SmartWalletConnection.jsx"],"sourcesContent":["// @ts-check\n/* global setTimeout */\nimport { Far } from '@endo/far';\nimport { makeMarshal } from '@endo/marshal';\n\n/**\n * Default to the local chain.\n */\nexport const DEFAULT_BOOTSTRAP = 'http://localhost:26657';\n\nexport const DEFAULT_JITTER_SECONDS = 5;\n\nexport const DEFAULT_POLL_WITH_EVENTS_SECONDS = 600;\n\nexport const DEFAULT_KEEP_POLLING_SECONDS = 5;\n\n/**\n * Resolve a Promise after a given number of milliseconds.\n *\n * SECURITY: closes over setTimeout global\n *\n * @param {number} ms\n * @returns {Promise<void>}\n */\nexport const delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n/**\n * @param {number} range\n * @param {number} [cap]\n */\nexport const randomBackoff = (range, cap = range) => {\n  return Math.random() * Math.min(cap, range);\n};\n\n/**\n * @param {number} [attempt]\n * @param {number} [base]\n * @param {number} [cap]\n */\nexport const exponentialBackoff = (attempt = 0, base = 1_000, cap = 30_000) => {\n  return randomBackoff(2 ** attempt * base, cap);\n};\n\n/**\n * Add a little to the retry delay to avoid a thundering herd.\n *\n * @param {string} where\n * @returns {Promise<void>}\n */\nexport const DEFAULT_JITTER = where => {\n  const jitter = randomBackoff(DEFAULT_JITTER_SECONDS * 1_000);\n  console.debug(`jittering ${where} by ${Math.ceil(jitter)}ms`);\n  return delay(jitter);\n};\n\n/**\n * Report an error, then retry the leader operation after a second or two.\n *\n * @param {string} where\n * @param {any} err\n * @param {number} [attempt]\n * @returns {Promise<void>}\n */\nexport const DEFAULT_RETRY_CALLBACK = (where, err, attempt = 0) => {\n  const backoff = exponentialBackoff(attempt);\n  console.log(\n    `retrying ${where} in ${Math.ceil(backoff)}ms after attempt #${attempt}`,\n    err,\n  );\n  return delay(backoff);\n};\n\n/**\n * Return true after we want to be sure we received latest state something.\n *\n * @returns {Promise<boolean>}\n */\nexport const DEFAULT_KEEP_POLLING = () =>\n  delay(randomBackoff(DEFAULT_KEEP_POLLING_SECONDS * 1_000)).then(() => true);\n\nexport const MAKE_DEFAULT_DECODER = () => {\n  /**\n   * Parse JSON.\n   *\n   * @param {string} str\n   */\n  return harden(str => {\n    try {\n      return harden(JSON.parse(str));\n    } catch (error) {\n      throw new Error(`Cannot decode alleged JSON (${error.message}): ${str}`);\n    }\n  });\n};\n\n/**\n * Unserialize the JSONable data.\n *\n * @type {() => import('./types').Unserializer}\n */\nexport const MAKE_DEFAULT_UNSERIALIZER = () => {\n  const ifaceAllegedPrefix = 'Alleged: ';\n  const ifaceInaccessiblePrefix = 'SEVERED: ';\n  const seen = new Map();\n  const slotToVal = (slot, iface) => {\n    // Private object.\n    if (seen.has(slot)) {\n      return seen.get(slot);\n    }\n    if (typeof iface === 'string' && iface.startsWith(ifaceAllegedPrefix)) {\n      iface = iface.slice(ifaceAllegedPrefix.length);\n    }\n    const obj = Far(`${ifaceInaccessiblePrefix}${iface}`, {});\n    seen.set(slot, obj);\n    return obj;\n  };\n  return Far('marshal unserializer', {\n    unserialize: makeMarshal(undefined, slotToVal).unserialize,\n  });\n};\n","// @ts-check\n\n/**\n * Modern version of Fisher-Yates shuffle algorithm (in-place).\n *\n * @template T\n * @param {Array<T>} a\n */\nexport const shuffle = a => {\n  for (let i = a.length - 1; i > 0; i -= 1) {\n    const j = Math.floor(Math.random() * (i + 1));\n    const x = a[i];\n    a[i] = a[j];\n    a[j] = x;\n  }\n};\n","// @ts-check\nimport { E, Far } from '@endo/far';\nimport { DEFAULT_KEEP_POLLING } from './defaults.js';\n\n/**\n * Just return an unspecified allegedValue every poll period.\n *\n * @param {import('./types').Leader} leader\n * @returns {Promise<import('./types.js').Follower<import('./types').CastingChange>>}\n */\nexport const makePollingChangeFollower = async leader => {\n  const { keepPolling = DEFAULT_KEEP_POLLING } = await E(leader).getOptions();\n\n  const iterable = Far('polling change follower iterable', {\n    [Symbol.asyncIterator]: () => {\n      /** @type {Promise<boolean> | undefined} */\n      let nextPollPromise;\n      return Far('polling change follower iterator', {\n        next: async () => {\n          if (!nextPollPromise) {\n            nextPollPromise = keepPolling('polling change follower').then(\n              cont => {\n                if (cont) {\n                  return E(leader)\n                    .jitter('polling change follower')\n                    .then(() => cont);\n                }\n                return cont;\n              },\n            );\n          }\n          const keepGoing = await nextPollPromise;\n          nextPollPromise = undefined;\n          const change = harden({\n            // Make no warrant as to the values.\n            values: [],\n          });\n          return harden({\n            value: change,\n            done: !keepGoing,\n          });\n        },\n      });\n    },\n  });\n\n  return Far('polling change follower', {\n    getLatestIterable: async () => iterable,\n    getEachIterable: async () => iterable,\n    getReverseIterable: async () => {\n      throw Error('not implemented for polling change follower');\n    },\n  });\n};\n","// @ts-check\n/* global fetch */\nimport { makeRoundRobinLeader } from './leader.js';\nimport {\n  DEFAULT_BOOTSTRAP,\n  DEFAULT_JITTER,\n  DEFAULT_RETRY_CALLBACK,\n} from './defaults.js';\n\nconst { details: X } = assert;\n\n/**\n * @param {string[]} rpcAddrs\n * @param {import('./types.js').LeaderOptions} [leaderOptions]\n * @returns {import('./types.js').Leader}\n */\nexport const makeLeaderFromRpcAddresses = (rpcAddrs, leaderOptions) => {\n  assert(Array.isArray(rpcAddrs), X`rpcAddrs ${rpcAddrs} must be an array`);\n\n  const rpcHrefs = rpcAddrs.map(rpcAddr => {\n    assert.typeof(rpcAddr, 'string', X`rpcAddr ${rpcAddr} must be a string`);\n    // Don't remove explicit port numbers from the URL, because the Cosmos\n    // `--node=xxx` flag requires them (it doesn't just assume that\n    // `--node=https://testnet.rpc.agoric.net` is the same as\n    // `--node=https://testnet.rpc.agoric.net:443`)\n    return rpcAddr.includes('://') ? rpcAddr : `http://${rpcAddr}`;\n  });\n\n  return makeRoundRobinLeader(rpcHrefs, leaderOptions);\n};\n\n/**\n * @param {string} netconfigURL\n * @param {import('./types.js').LeaderOptions} [options]\n */\nexport const makeLeaderFromNetworkConfig = (netconfigURL, options = {}) => {\n  const { retryCallback = DEFAULT_RETRY_CALLBACK, jitter = DEFAULT_JITTER } =\n    options;\n  /** @type {import('./types.js').LeaderOptions['retryCallback']} */\n  const retry = async (where, err, attempt) => {\n    if (retryCallback) {\n      return retryCallback(where, err, attempt);\n    }\n    throw err;\n  };\n  let attempt = 0;\n  const where = 'Network config leader';\n  return new Promise((resolve, reject) => {\n    const makeLeader = async () => {\n      const response = await fetch(netconfigURL, {\n        headers: { accept: 'application/json' },\n      });\n      const { rpcAddrs } = await response.json();\n      // Our part succeeded, so reset the attempt counter.\n      attempt = 0;\n      return makeLeaderFromRpcAddresses(rpcAddrs, options);\n    };\n    const retryLeader = async err => {\n      retry(where, err, attempt)\n        .then(() => jitter(where))\n        .then(() => makeLeader().then(resolve, retryLeader))\n        .catch(reject);\n      attempt += 1;\n    };\n    makeLeader().then(resolve, retryLeader);\n  });\n};\n\n/**\n * @param {string} [bootstrap]\n * @param {import('./types.js').LeaderOptions} [options]\n * @returns {ERef<import('./types.js').Leader>}\n */\nexport const makeLeader = (bootstrap = DEFAULT_BOOTSTRAP, options) => {\n  if (bootstrap.includes('network-config')) {\n    return makeLeaderFromNetworkConfig(bootstrap, options);\n  }\n  return makeLeaderFromRpcAddresses([bootstrap], options);\n};\n/** @typedef {ReturnType<typeof makeLeader>} Leader */\n","// @ts-check\nimport { E, Far } from '@endo/far';\nimport { DEFAULT_RETRY_CALLBACK, DEFAULT_JITTER } from './defaults.js';\nimport { shuffle } from './shuffle.js';\nimport { makePollingChangeFollower } from './change-follower.js';\n\n/**\n * Create a chain leader that rotates through a list of endpoints.\n *\n * @param {string[]} endpoints\n * @param {import('./types.js').LeaderOptions} leaderOptions\n */\nexport const makeRoundRobinLeader = (endpoints, leaderOptions = {}) => {\n  const { retryCallback = DEFAULT_RETRY_CALLBACK, jitter = DEFAULT_JITTER } =\n    leaderOptions;\n\n  // Shuffle the RPC addresses, so that we don't always hit the same one as all\n  // our peers.\n  shuffle(endpoints);\n\n  let lastRespondingEndpointIndex = 0;\n  let thisAttempt = 0;\n  let retrying;\n\n  /** @type {import('./types.js').Leader} */\n  const leader = Far('round robin leader', {\n    getOptions: () => leaderOptions,\n    jitter: async where => jitter && jitter(where),\n    retry: async (where, err, attempt) => {\n      if (retryCallback) {\n        return retryCallback(where, err, attempt);\n      }\n      throw err;\n    },\n    // eslint-disable-next-line no-use-before-define\n    watchCasting: _castingSpecP => pollingChangeFollower,\n    /**\n     * @template T\n     * @param {string} where\n     * @param {(endpoint: string) => Promise<T>} callback\n     */\n    mapEndpoints: async (where, callback) => {\n      where = `${where} (round-robin endpoints)`;\n      /** @type {Promise<T[]>} */\n      const p = new Promise((resolve, reject) => {\n        let endpointIndex = lastRespondingEndpointIndex;\n\n        const retry = err => {\n          if (!retrying) {\n            const attempt = thisAttempt;\n            retrying = E(leader)\n              .retry(where, err, attempt)\n              .then(() => {\n                endpointIndex = (endpointIndex + 1) % endpoints.length;\n                retrying = null;\n              });\n          }\n\n          retrying\n            .then(() => jitter && jitter(where))\n            // eslint-disable-next-line no-use-before-define\n            .then(applyOne, reject);\n          thisAttempt += 1;\n        };\n\n        const applyOne = () => {\n          Promise.resolve()\n            .then(() => callback(endpoints[endpointIndex]))\n            .then(res => {\n              resolve(harden([res]));\n              lastRespondingEndpointIndex = endpointIndex;\n              thisAttempt = 0;\n            }, retry);\n\n          // Don't return to prevent a promise chain.\n        };\n\n        applyOne();\n      });\n      return p;\n    },\n  });\n\n  const pollingChangeFollower = makePollingChangeFollower(leader);\n  return leader;\n};\n","// @ts-check\nimport { E, Far } from '@endo/far';\nimport { makeNotifier } from '@agoric/notifier';\n\n/**\n * @template T\n * @param {ERef<Notifier<T>>} notifier\n * @returns {ConsistentAsyncIterable<T>}\n */\nexport const makeNotifierIterable = notifier =>\n  makeNotifier(E(notifier).getSharableNotifierInternals());\n\n/**\n * TODO: Remove this function when we have `makePublisherKit`.\n *\n * @template T\n * @param {ERef<PublicationRecord<T>>} tailP\n * @returns {AsyncIterator<T>}\n */\nconst makeSubscriptionIterator = tailP => {\n  // To understand the implementation, start with\n  // https://web.archive.org/web/20160404122250/http://wiki.ecmascript.org/doku.php?id=strawman:concurrency#infinite_queue\n  return Far('SubscriptionIterator', {\n    next: async () => {\n      const resultP = E.get(tailP).head;\n      tailP = E.get(tailP).tail;\n      return resultP;\n    },\n  });\n};\n\n/**\n * TODO: Remove this function when we have `makePublisherKit`.\n *\n * @template T\n * @param {ERef<Subscription<T>>} subscription\n * @returns {ConsistentAsyncIterable<T>}\n */\nexport const makeSubscriptionIterable = subscription =>\n  harden({\n    [Symbol.asyncIterator]: () =>\n      makeSubscriptionIterator(\n        E(subscription).getSharableSubscriptionInternals(),\n      ),\n  });\n\n/**\n * @template TIn\n * @template TOut\n * @param {AsyncIterable<TIn>} iterable\n * @param {(value: TIn) => TOut} transform\n * @returns {AsyncIterable<TOut>}\n */\nexport const mapAsyncIterable = (iterable, transform) => {\n  async function* transformGenerator() {\n    for await (const value of iterable) {\n      yield transform(value);\n    }\n  }\n  return transformGenerator();\n};\n\n/**\n * TODO: Remove this function when we have `makePublisherKit`.\n *\n * @template T\n * @param {ERef<import('./types').Follower<T>>} follower\n */\nexport const iterateLatest = follower =>\n  // For now, just pass through the iterable.\n  Far('iterateLatest iterable', {\n    /** @returns {AsyncIterator<T>} */\n    [Symbol.asyncIterator]: () => {\n      const latestIterable = E(follower).getLatestIterable();\n      const iterator = E(latestIterable)[Symbol.asyncIterator]();\n      return Far('iterateLatest iterator', {\n        next: () => E(iterator).next(),\n      });\n    },\n  });\n\n/**\n * TODO: Remove this function when we have `makePublisherKit`.\n *\n * @template T\n * @param {ERef<import('./types.js').Follower<T>>} follower\n * @param {import('./types.js').IterateEachOptions} [options]\n */\nexport const iterateEach = (follower, options) =>\n  // For now, just pass through the iterable.\n  Far('iterateEach iterable', {\n    /** @returns {AsyncIterator<T>} */\n    [Symbol.asyncIterator]: () => {\n      const eachIterable = E(follower).getEachIterable(options);\n      const iterator = E(eachIterable)[Symbol.asyncIterator]();\n      return Far('iterateEach iterator', {\n        next: () => E(iterator).next(),\n      });\n    },\n  });\n\n/**\n * @template T\n * @param {ERef<import('./types.js').Follower<T>>} follower\n * @param {import('./types.js').IterateEachOptions} [options]\n */\nexport const iterateReverse = (follower, options) =>\n  // For now, just pass through the iterable.\n  Far('iterateReverse iterable', {\n    /** @returns {AsyncIterator<T>} */\n    [Symbol.asyncIterator]: () => {\n      const eachIterable = E(follower).getReverseIterable(options);\n      const iterator = E(eachIterable)[Symbol.asyncIterator]();\n      return Far('iterateEach iterator', {\n        next: () => E(iterator).next(),\n      });\n    },\n  });\n","// @ts-check\nimport * as encodingStar from '@cosmjs/encoding';\nimport { E, getInterfaceOf } from '@endo/far';\n\nimport './types.js';\n\nconst { toAscii } = encodingStar;\n\n/**\n * @param {string} storagePath\n * @returns {import('./types').CastingSpec}\n */\nconst swingsetPathToCastingSpec = storagePath =>\n  harden({\n    storeName: 'swingset',\n    storeSubkey: toAscii(`swingset/data:${storagePath}`),\n  });\n\nconst PATH_SEPARATOR_BYTE = '.'.charCodeAt(0);\nconst DATA_PREFIX_BYTES = new Uint8Array([0]);\n\n/**\n * @param {string} storagePath\n * @param {string} [storeName]\n * @returns {import('./types').CastingSpec}\n */\nconst vstoragePathToCastingSpec = (storagePath, storeName = 'vstorage') => {\n  const elems = storagePath ? storagePath.split('.') : [];\n  const buf = toAscii(`${elems.length}.${storagePath}`);\n  return harden({\n    storeName,\n    storeSubkey: buf.map(b => (b === PATH_SEPARATOR_BYTE ? 0 : b)),\n    dataPrefixBytes: DATA_PREFIX_BYTES,\n  });\n};\n\nexport const DEFAULT_PATH_CONVERTER = vstoragePathToCastingSpec;\n\n/**\n * @type {Record<string, (path: string) => import('./types').CastingSpec>}\n */\nexport const pathPrefixToConverters = harden({\n  'swingset:': swingsetPathToCastingSpec,\n  'vstore:': vstoragePathToCastingSpec,\n  ':': DEFAULT_PATH_CONVERTER,\n});\n\n/**\n * @param {string} specString\n * @returns {import('./types').CastingSpec}\n */\nexport const makeCastingSpecFromString = specString => {\n  assert.typeof(specString, 'string');\n  const match = specString.match(/^([^:.]*:)(.*)/);\n  assert(\n    match,\n    `spec string ${specString} does not match 'PREFIX:PATH' or ':PATH'`,\n  );\n  const kind = match[1];\n  const storePath = match[2];\n  const converter = pathPrefixToConverters[kind];\n  assert(converter, `Unknown pathKind ${kind}`);\n  return converter(storePath);\n};\n\nconst te = new TextEncoder();\n\n/**\n * @param {any} specObj\n * @returns {import('./types').CastingSpec}\n */\nexport const makeCastingSpecFromObject = specObj => {\n  const { storeName, storeSubkey, dataPrefixBytes, subscription, notifier } =\n    specObj;\n  if (subscription || notifier) {\n    return harden({\n      subscription,\n      notifier,\n    });\n  }\n  let subkey = storeSubkey;\n  if (typeof storeSubkey === 'string') {\n    subkey = te.encode(storeSubkey);\n  }\n  let dataPrefix = dataPrefixBytes;\n  if (typeof dataPrefixBytes === 'string') {\n    dataPrefix = te.encode(dataPrefixBytes);\n  }\n  return harden({\n    storeName,\n    storeSubkey: subkey,\n    dataPrefixBytes: dataPrefix,\n  });\n};\n\n/**\n * @param {ERef<any>} specCap\n * @returns {Promise<import('./types').CastingSpec>}\n */\nexport const makeCastingSpecFromRef = async specCap => {\n  const specObj = await E(specCap).getStoreKey();\n  return makeCastingSpecFromObject(specObj);\n};\n\n/**\n * Create an abstract type from a given source representation\n *\n * @param {ERef<unknown>} sourceP\n * @returns {Promise<import('./types').CastingSpec>}\n */\nexport const makeCastingSpec = async sourceP => {\n  const spec = await sourceP;\n  if (typeof spec === 'string') {\n    return makeCastingSpecFromString(spec);\n  }\n  // @ts-expect-error type detection\n  const { storeName, subscription, notifier } = spec;\n  if (storeName || subscription || notifier) {\n    return makeCastingSpecFromObject(spec);\n  }\n  if (getInterfaceOf(spec)) {\n    return makeCastingSpecFromRef(spec);\n  }\n  assert.fail(`CastingSpec ${spec} is not a string, object, or ref`);\n};\n/** @typedef {ReturnType<typeof makeCastingSpec>} CastingSpec */\n","// @ts-check\n/// <reference types=\"ses\"/>\n/* eslint-disable no-await-in-loop, no-continue, @jessie.js/no-nested-await */\n\nimport { E, Far } from '@endo/far';\nimport * as tendermintRpcStar from '@cosmjs/tendermint-rpc';\nimport * as stargateStar from '@cosmjs/stargate';\n\nimport { MAKE_DEFAULT_DECODER, MAKE_DEFAULT_UNSERIALIZER } from './defaults.js';\nimport { makeCastingSpec } from './casting-spec.js';\nimport { makeLeader as defaultMakeLeader } from './leader-netconfig.js';\n\nconst { QueryClient } = stargateStar;\nconst { Tendermint34Client } = tendermintRpcStar;\nconst { details: X, quote: q } = assert;\nconst textDecoder = new TextDecoder();\n\n/** @template T @typedef {import('./types.js').StreamCell<T>} StreamCell */\n/** @template T @typedef {import('./types.js').FollowerElement<T>} FollowerElement */\n/** @template T @typedef {import('./types.js').Follower<T>} Follower */\n\n/**\n * This is an imperfect heuristic to navigate the migration from value cells to\n * stream cells.\n * At time of writing, no legacy cells have the same shape as a stream cell,\n * and we do not intend to create any more legacy value cells.\n *\n * @param {any} cell\n */\nconst isStreamCell = cell =>\n  cell &&\n  typeof cell === 'object' &&\n  Array.isArray(cell.values) &&\n  typeof cell.blockHeight === 'string' &&\n  /^0$|^[1-9][0-9]*$/.test(cell.blockHeight);\n\n/**\n * @param {Uint8Array} a\n * @param {Uint8Array} b\n */\nconst arrayEqual = (a, b) => {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i += 1) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst defaultDataPrefixBytes = new Uint8Array();\n\n/**\n * @template T\n * @param {Iterable<T>} values\n * @returns {T}\n */\nconst collectSingle = values => {\n  /** @type {T[]} */\n  const head = [];\n  let count = 0;\n  for (const value of values) {\n    count += 1;\n    if (count === 1) {\n      head.push(value);\n    } else {\n      assert.fail(`expected single value, got at least ${count}`);\n    }\n  }\n\n  assert.equal(head.length, 1, 'expected single value');\n  return head[0];\n};\n\n// Coordinate with switch/case of tryGetDataAtHeight.\nconst proofs = ['strict', 'none', 'optimistic'];\n\n/**\n * @template T\n * @param {any} sourceP\n * @param {import('./types').LeaderOrMaker} [leaderOrMaker]\n * @param {import('./types').FollowerOptions} [options]\n * @returns {Follower<FollowerElement<T>>}\n */\nexport const makeCosmjsFollower = (\n  sourceP,\n  leaderOrMaker = defaultMakeLeader,\n  options = {},\n) => {\n  const {\n    decode = MAKE_DEFAULT_DECODER(),\n    unserializer = MAKE_DEFAULT_UNSERIALIZER(),\n    proof = 'optimistic',\n    crasher = null,\n  } = options;\n\n  /**\n   * @param {any} err\n   */\n  const crash = err => {\n    if (crasher) {\n      E(crasher)\n        .crash(`PROOF VERIFICATION FAILURE; crashing follower`, err)\n        .catch(e => assert.fail(X`crashing follower failed: ${e}`));\n    }\n    throw err;\n  };\n\n  assert(proofs.includes(proof), X`unrecognized follower proof mode ${proof}`);\n\n  const where = 'CosmJS follower';\n  const castingSpecP = makeCastingSpec(sourceP);\n\n  const leader =\n    typeof leaderOrMaker === 'function' ? leaderOrMaker() : leaderOrMaker;\n\n  const tendermintClientPs = new Map();\n  /**\n   * @param {string} endpoint\n   * @returns {tendermintRpcStar.Tendermint34Client}\n   */\n  const provideTendermintClient = endpoint => {\n    let clientP = tendermintClientPs.get(endpoint);\n    if (!clientP) {\n      clientP = Tendermint34Client.connect(endpoint);\n      tendermintClientPs.set(endpoint, clientP);\n    }\n    return clientP;\n  };\n\n  const getBlockHeight = async () => {\n    const values = await E(leader).mapEndpoints(where, async endpoint => {\n      const client = await provideTendermintClient(endpoint);\n      const info = await client.abciInfo();\n      const { lastBlockHeight } = info;\n      assert.typeof(lastBlockHeight, 'number');\n      return lastBlockHeight;\n    });\n    return collectSingle(values);\n  };\n\n  /** @type {Map<string, import('@cosmjs/stargate').QueryClient>} */\n  const endpointToQueryClient = new Map();\n\n  /**\n   * @param {string} endpoint\n   */\n  const provideQueryClient = async endpoint => {\n    if (endpointToQueryClient.has(endpoint)) {\n      // Cache hit.\n      const queryClient = endpointToQueryClient.get(endpoint);\n      assert(queryClient);\n      return queryClient;\n    }\n    // Create a new client.  They retry automatically.\n    const rpcClient = await provideTendermintClient(endpoint);\n    const queryClient = QueryClient.withExtensions(rpcClient);\n    endpointToQueryClient.set(endpoint, queryClient);\n    return queryClient;\n  };\n\n  /**\n   * @param {(endpoint: string, storeName: string, storeSubkey: Uint8Array) => Promise<Uint8Array>} tryGetPrefixedData\n   */\n  const retryGetDataAndStripPrefix = async tryGetPrefixedData => {\n    const {\n      storeName,\n      storeSubkey,\n      dataPrefixBytes = defaultDataPrefixBytes,\n    } = await castingSpecP;\n\n    assert.typeof(\n      storeName,\n      'string',\n      X`storeName must be a string, got ${storeName}`,\n    );\n    assert(\n      storeSubkey,\n      X`storeSubkey must be a Uint8Array, got ${storeSubkey}`,\n    );\n\n    // mapEndpoints is our retry loop.\n    const values = await E(leader).mapEndpoints(where, async endpoint =>\n      tryGetPrefixedData(endpoint, storeName, storeSubkey).then(\n        result => {\n          return { result, error: null };\n        },\n        error => {\n          return { result: null, error };\n        },\n      ),\n    );\n\n    const { result, error } = collectSingle(values);\n    if (error !== null) {\n      throw error;\n    }\n    assert(result);\n\n    if (result.length === 0) {\n      // No data.\n      return result;\n    }\n\n    // Handle the data prefix if any.\n    assert(\n      result.length >= dataPrefixBytes.length,\n      X`result too short for data prefix ${dataPrefixBytes}`,\n    );\n    assert(\n      arrayEqual(result.subarray(0, dataPrefixBytes.length), dataPrefixBytes),\n      X`${result} doesn't start with data prefix ${dataPrefixBytes}`,\n    );\n    return result.slice(dataPrefixBytes.length);\n  };\n\n  /**\n   * @param {number} [height]\n   * @returns {Promise<Uint8Array>}\n   */\n  const getProvenDataAtHeight = async height => {\n    return retryGetDataAndStripPrefix(\n      async (endpoint, storeName, storeSubkey) => {\n        const queryClient = await provideQueryClient(endpoint);\n        return E(queryClient).queryVerified(storeName, storeSubkey, height);\n      },\n    );\n  };\n\n  /**\n   * @param {number} height\n   */\n  const getUnprovenDataAtHeight = async height => {\n    return retryGetDataAndStripPrefix(\n      async (endpoint, storeName, storeSubkey) => {\n        const client = await provideTendermintClient(endpoint);\n        const response = await client.abciQuery({\n          path: `store/${storeName}/key`,\n          data: storeSubkey,\n          height,\n          prove: false,\n        });\n        if (response.code !== 0) {\n          throw new Error(`Tendermint ABCI query failed: ${response.log}`);\n        }\n        const { value } = response;\n        return value;\n      },\n    );\n  };\n\n  /**\n   * @param {number} blockHeight\n   */\n  const tryGetDataAtHeight = async blockHeight => {\n    if (proof === 'strict') {\n      // Crash hard if we can't prove.\n      return getProvenDataAtHeight(blockHeight).catch(crash);\n    } else if (proof === 'none') {\n      // Fast and loose.\n      return getUnprovenDataAtHeight(blockHeight);\n    } else if (proof === 'optimistic') {\n      const allegedData = await getUnprovenDataAtHeight(blockHeight);\n\n      // Prove later, since it may take time we say we can't afford.\n      getProvenDataAtHeight(blockHeight).then(provenData => {\n        if (arrayEqual(provenData, allegedData)) {\n          return;\n        }\n        crash(\n          assert.error(\n            X`Alleged value ${allegedData} did not match proof ${provenData}`,\n          ),\n        );\n      }, crash);\n\n      // Speculate that we got the right value.\n      return allegedData;\n    }\n\n    assert.fail(\n      X`Unrecognized proof option ${q(\n        proof,\n      )}, must be one of strict, none, or optimistic`,\n    );\n  };\n\n  /**\n   * @param {number} blockHeight\n   */\n  const getDataAtHeight = async blockHeight => {\n    for (let attempt = 0; ; attempt += 1) {\n      try {\n        // AWAIT\n        return await tryGetDataAtHeight(blockHeight);\n      } catch (error) {\n        // We expect occasionally to see an error here if the chain has not\n        // reached the requested blockHeight.\n        await E(leader).retry(where, error, attempt);\n        continue;\n      }\n    }\n  };\n\n  /**\n   * @param {number} blockHeight\n   * @param {Uint8Array} data\n   */\n  const streamCellForData = (blockHeight, data) => {\n    const text = textDecoder.decode(data);\n    try {\n      const cell = JSON.parse(text);\n      if (isStreamCell(cell)) {\n        return harden({\n          blockHeight: Number(cell.blockHeight),\n          values: cell.values.map(decode),\n        });\n      }\n\n      // This is JSON but not the shape of a stream cell.\n      // Fall through...\n    } catch {\n      // This is not even JSON, so it must be a legacy value cell.\n      // Fall through...\n    }\n\n    // Coerce legacy value cells to stream cells at their given height.\n    // Since this is either the first iteration or the data varies bytewise\n    // from the data on the previous block, we can assume the blockHeight is\n    // the current block.\n    return harden({\n      blockHeight,\n      values: [decode(text)],\n    });\n  };\n\n  /**\n   * @param {any} data\n   * @param {number} blockHeight\n   * @param {number} currentBlockHeight\n   * @returns {Promise<FollowerElement<T>>}\n   */\n  const followerElementFromStreamCellValue = async (\n    data,\n    blockHeight,\n    currentBlockHeight,\n  ) => {\n    // AWAIT\n    const value = await /** @type {T} */ (\n      unserializer ? E(unserializer).unserialize(data) : data\n    );\n    return { value, blockHeight, currentBlockHeight };\n  };\n\n  /**\n   * @param {StreamCell<T>} streamCell\n   * @param {number} currentBlockHeight\n   * @yields {FollowerElement<T>}\n   */\n  function* allValuesFromCell(streamCell, currentBlockHeight) {\n    for (const data of streamCell.values) {\n      yield followerElementFromStreamCellValue(\n        data,\n        streamCell.blockHeight,\n        currentBlockHeight,\n      );\n    }\n  }\n\n  /**\n   * @param {StreamCell<T>} streamCell\n   * @param {number} currentBlockHeight\n   * @yields {FollowerElement<T>}\n   */\n  function* reverseValuesFromCell(streamCell, currentBlockHeight) {\n    for (let i = streamCell.values.length - 1; i >= 0; i -= 1) {\n      yield followerElementFromStreamCellValue(\n        streamCell.values[i],\n        streamCell.blockHeight,\n        currentBlockHeight,\n      );\n    }\n  }\n\n  /**\n   * @param {StreamCell<T>} streamCell\n   * @param {number} currentBlockHeight\n   * @yields {FollowerElement<T>}\n   */\n  function* lastValueFromCell(streamCell, currentBlockHeight) {\n    const { values } = streamCell;\n    if (values.length > 0) {\n      const last = values[values.length - 1];\n      yield followerElementFromStreamCellValue(\n        last,\n        streamCell.blockHeight,\n        currentBlockHeight,\n      );\n    }\n  }\n\n  /**\n   * @yields {FollowerElement<T>}\n   */\n  async function* getLatestIterable() {\n    let blockHeight;\n    let data;\n    for (;;) {\n      const currentBlockHeight = await getBlockHeight();\n      if (currentBlockHeight === blockHeight) {\n        // TODO Long-poll for next block\n        // https://github.com/Agoric/agoric-sdk/issues/6154\n        await E(leader).jitter(where);\n        continue;\n      }\n\n      const currentData = await getDataAtHeight(currentBlockHeight);\n      if (currentData.length === 0) {\n        // TODO Long-poll for block data change\n        // https://github.com/Agoric/agoric-sdk/issues/6154\n        await E(leader).jitter(where);\n        continue;\n      }\n      const currentStreamCell = streamCellForData(\n        currentBlockHeight,\n        currentData,\n      );\n\n      blockHeight = currentBlockHeight;\n\n      // Ignore adjacent duplicates.\n      // This can only occur for legacy cells.\n      // It is possible that the data changed from and back to the last\n      // sampled data, but ignoring intermediate changes is consistent with\n      // the semantics of getLatestIterable.\n      if (data !== undefined && arrayEqual(data, currentData)) {\n        continue;\n      }\n      // However, streamCells that vacillate will reemit, since each iteration\n      // at a unique block height is considered distinct.\n\n      yield* lastValueFromCell(currentStreamCell, currentBlockHeight);\n      data = currentData;\n    }\n  }\n\n  /**\n   * @param {number} cursorBlockHeight\n   * @yields {FollowerElement<T>}\n   */\n  async function* getEachIterableAtHeight(cursorBlockHeight) {\n    // Track the data for the last emitted cell (the cell at the\n    // cursorBlockHeight) so we know not to emit duplicates\n    // of that cell.\n    let cursorData;\n    // Initially yield *all* the values that were most recently stored in a\n    // block.\n    // If the block has no corresponding data, wait for the first block to\n    // contain data.\n    for (;;) {\n      cursorData = await getDataAtHeight(cursorBlockHeight);\n      if (cursorData.length !== 0) {\n        const cursorStreamCell = streamCellForData(\n          cursorBlockHeight,\n          cursorData,\n        );\n        yield* allValuesFromCell(cursorStreamCell, cursorBlockHeight);\n        break;\n      }\n      // TODO Long-poll for next block\n      // https://github.com/Agoric/agoric-sdk/issues/6154\n      await E(leader).jitter(where);\n      cursorBlockHeight = await getBlockHeight();\n    }\n\n    // For each subsequent iteration, yield every value that has been\n    // published since the last iteration and advance the cursor.\n    for (;;) {\n      const currentBlockHeight = await getBlockHeight();\n      // Wait until the chain has added at least one block.\n      if (currentBlockHeight <= cursorBlockHeight) {\n        // TODO Long-poll for next block\n        // https://github.com/Agoric/agoric-sdk/issues/6154\n        await E(leader).jitter(where);\n        continue;\n      }\n\n      // Scan backward for all changes since the last observed block and yield\n      // them in forward order.\n      // Stream cells allow us to skip blocks that did not change.\n      // We walk backward through all blocks with legacy cells, only yielding\n      // the value for cells that changed.\n      // This does imply accumulating a potentially large number of values if\n      // the eachIterable gets sampled infrequently.\n      let rightBlockHeight = currentBlockHeight;\n      let rightData = await getDataAtHeight(rightBlockHeight);\n      if (rightData.length === 0) {\n        // TODO Long-poll for next block\n        // https://github.com/Agoric/agoric-sdk/issues/6154\n        await E(leader).jitter(where);\n        continue;\n      }\n      let rightStreamCell = streamCellForData(rightBlockHeight, rightData);\n\n      // Compare block cell data pairwise (left, right) and accumulate\n      // a stack of each cell we encounter.\n      const currentData = rightData;\n      const cells = [];\n      while (rightBlockHeight > cursorBlockHeight) {\n        if (rightStreamCell.blockHeight > rightBlockHeight) {\n          const { storeName, storeSubkey } = await castingSpecP;\n          throw new Error(\n            `Corrupt storage cell for ${storeName} under key ${storeSubkey} at block-height ${rightBlockHeight} claims to being published at a later block height ${rightStreamCell.blockHeight}`,\n          );\n        }\n        const leftBlockHeight = rightStreamCell.blockHeight - 1;\n        // Do not scan behind the cusor.\n        if (leftBlockHeight <= cursorBlockHeight) {\n          break;\n        }\n        const leftData = await getDataAtHeight(leftBlockHeight);\n        // Do not scan behind a cell with no data.\n        // This should not happen but can be tolerated.\n        if (leftData.length === 0) {\n          break;\n        }\n        const leftStreamCell = streamCellForData(leftBlockHeight, leftData);\n\n        // Stream cells include a block height that is guaranteed to change\n        // between iterations even if the values are identical.\n        // We can rely on this difference to ensure that we yield\n        // every iteration, including duplicates.\n        // Legacy cells do not contain a block height to distingish versions,\n        // so we simply assume that the value must change between iterations\n        // for a cell to be worthy of notice.\n        if (!arrayEqual(leftData, rightData)) {\n          cells.push(rightStreamCell);\n        }\n\n        // Prepare for next iteration by moving left to right.\n        rightData = leftData;\n        rightStreamCell = leftStreamCell;\n        rightBlockHeight = leftBlockHeight;\n      }\n\n      // At the end of a sequence of identical value cells, we emit the value\n      // only if it differs from the last reported cell.\n      if (!arrayEqual(rightData, cursorData)) {\n        cells.push(rightStreamCell);\n      }\n\n      // Yield collected cells in forward order.\n      // They were collected by scanning blocks backward.\n      for (;;) {\n        const cell = cells.pop();\n        if (cell === undefined) {\n          break;\n        }\n        yield* allValuesFromCell(cell, currentBlockHeight);\n      }\n\n      // Advance the cursor.\n      cursorBlockHeight = currentBlockHeight;\n      cursorData = currentData;\n    }\n  }\n\n  /**\n   * @param {number} cursorBlockHeight\n   * @yields {FollowerElement<T>}\n   */\n  async function* getReverseIterableAtHeight(cursorBlockHeight) {\n    // Track the data for the last emitted cell (the cell at the\n    // cursorBlockHeight) so we know not to emit duplicates\n    // of that cell.\n    let cursorData;\n    while (cursorBlockHeight > 0) {\n      cursorData = await getDataAtHeight(cursorBlockHeight);\n      if (cursorData.length === 0) {\n        // No data at the cursor height, so signal beginning of stream.\n        return;\n      }\n      const cursorStreamCell = streamCellForData(cursorBlockHeight, cursorData);\n      yield* reverseValuesFromCell(cursorStreamCell, cursorBlockHeight);\n      cursorBlockHeight = cursorStreamCell.blockHeight - 1;\n    }\n  }\n\n  /** @type {Follower<FollowerElement<T>>} */\n  return Far('chain follower', {\n    async getLatestIterable() {\n      return getLatestIterable();\n    },\n    async getEachIterable({ height = undefined } = {}) {\n      if (height === undefined) {\n        height = await getBlockHeight();\n      }\n      return getEachIterableAtHeight(height);\n    },\n    async getReverseIterable({ height = undefined } = {}) {\n      if (height === undefined) {\n        height = await getBlockHeight();\n      }\n      return getReverseIterableAtHeight(height);\n    },\n  });\n};\n","// @ts-check\n\nimport { Far } from '@endo/far';\nimport {\n  mapAsyncIterable,\n  makeNotifierIterable,\n  makeSubscriptionIterable,\n} from './iterable.js';\nimport { makeCosmjsFollower } from './follower-cosmjs.js';\nimport { makeCastingSpec } from './casting-spec.js';\n\n/**\n * @template T\n * @param {ERef<import('./types').CastingSpec>} spec\n */\nconst makeSubscriptionFollower = spec => {\n  const transform = value =>\n    harden({ value, blockHeight: NaN, currentBlockHeight: NaN });\n  /** @type {import('./types').Follower<import('./types.js').FollowerElement<T>>} */\n  const follower = Far('subscription/notifier follower', {\n    getLatestIterable: async () => {\n      const { notifier, subscription } = await spec;\n      let ai;\n      if (notifier) {\n        ai = makeNotifierIterable(notifier);\n      } else {\n        assert(subscription);\n        ai = makeSubscriptionIterable(subscription);\n      }\n      return mapAsyncIterable(ai, transform);\n    },\n\n    getEachIterable: async () => {\n      const { notifier, subscription } = await spec;\n      let ai;\n      if (subscription) {\n        ai = makeSubscriptionIterable(subscription);\n      } else {\n        assert(notifier);\n        ai = makeNotifierIterable(notifier);\n      }\n      return mapAsyncIterable(ai, transform);\n    },\n\n    getReverseIterable: async () => {\n      throw Error(\n        'reverse iteration not implemented for subscription follower',\n      );\n    },\n  });\n  return follower;\n};\n\n/**\n * @template T\n * @param {ERef<import('./types').CastingSpec> | string} specP\n * @param {import('./types').LeaderOrMaker} [leaderOrMaker]\n * @param {import('./types').FollowerOptions} [options]\n * @returns {Promise<import('./types').Follower<import('./types').FollowerElement<T>>>}\n */\nexport const makeFollower = async (specP, leaderOrMaker, options) => {\n  const spec = await makeCastingSpec(specP);\n  const { storeName } = spec;\n  if (storeName) {\n    return makeCosmjsFollower(spec, leaderOrMaker, options);\n  }\n  return makeSubscriptionFollower(spec);\n};\n","// @ts-check\nimport { makeScalarMap } from '@agoric/store';\nimport { Far, makeMarshal, Remotable } from '@endo/marshal';\nimport { HandledPromise } from '@endo/eventual-send'; // TODO: convince tsc this isn't needed\n\nconst { details: X, quote: q } = assert;\n\n/**\n * For a value with a known id in the board, we can use\n * that board id as a slot to preserve identity when marshaling.\n *\n * @typedef {`board${Digits}`} BoardId\n */\n\n/**\n * @param {unknown} specimen\n * @returns {specimen is BoardId}\n */\nconst isBoardId = specimen => {\n  return typeof specimen === 'string' && !!specimen.match(/^board[^:]/);\n};\n\n/**\n * When marshaling a purse, payment, etc. we partition the slots\n * using prefixes.\n *\n * @template {Record<string, IdTable<*,*>>} T\n * @typedef {`${string & keyof T}:${Digits}`} WalletSlot<T>\n */\n/**\n * @template {string} K\n * @typedef {`${K}:${Digits}`} KindSlot<K>\n */\n\n/**\n * @template {Record<string, IdTable<*,*>>} T\n * @param {T} _tables\n * @param {string & keyof T} kind\n * @param {number} id\n * @returns {WalletSlot<T>}\n */\nconst makeWalletSlot = (_tables, kind, id) => {\n  const digits = /** @type {Digits} */ (`${id}`);\n  return `${kind}:${digits}`;\n};\n\n/**\n * @template {Record<string, IdTable<*,*>>} T\n * @param {T} record\n * @param {(value: string, index: number, obj: string[]) => boolean} predicate\n * @returns {string & keyof T | undefined}\n */\nconst findKey = (record, predicate) => {\n  const key = Object.keys(record).find(predicate);\n  return key;\n};\n\n/**\n * @template {Record<string, IdTable<*,*>>} T\n * @param {T} tables\n * @param {string} slot\n * @returns {{ kind: undefined | string & keyof T, id: number }}\n */\nconst parseWalletSlot = (tables, slot) => {\n  const kind = findKey(tables, k => slot.startsWith(`${k}:`));\n  const id = kind ? Number(slot.slice(kind.length + 1)) : NaN;\n  return { kind, id };\n};\n\n/**\n * Since KindSlots always include a colon and BoardIds never do,\n * we an mix them without confusion.\n *\n * @template {Record<string, IdTable<*,*>>} T\n * @typedef {WalletSlot<T> | BoardId} MixedSlot<T>\n */\n/**\n * @typedef {`1` | `12` | `123`} Digits - 1 or more digits.\n * NOTE: the typescript definition here is more restrictive than\n * actual usage.\n */\n\n/**\n * @template Slot\n * @template Val\n *\n * @typedef {{\n *   bySlot: MapStore<Slot, Val>,\n *   byVal: MapStore<Val, Slot>,\n * }} IdTable<Value>\n */\n\n/**\n * @template Slot\n * @template Val\n * @param {IdTable<Slot, Val>} table\n * @param {Slot} slot\n * @param {Val} val\n */\nconst initSlotVal = (table, slot, val) => {\n  table.bySlot.init(slot, val);\n  table.byVal.init(val, slot);\n};\n\n/**\n * Make context for exporting wallet data where brands etc. can be recognized by boardId.\n * Export for use outside the smart wallet.\n *\n * When serializing wallet state for, there's a tension between\n *\n *  - keeping purses etc. closely held\n *  - recognizing identity of brands also referenced in the state of contracts such as the AMM\n *\n * `makeMarshal()` is parameterized by the type of slots. Here we use a disjoint union of\n *   - board ids for widely shared objects\n *   - kind:seq ids for closely held objects; for example purse:123\n */\nexport const makeExportContext = () => {\n  const walletObjects = {\n    /** @type {IdTable<number, Purse>} */\n    purse: {\n      bySlot: makeScalarMap(),\n      byVal: makeScalarMap(),\n    },\n    /** @type {IdTable<number, Payment>} */\n    payment: {\n      bySlot: makeScalarMap(),\n      byVal: makeScalarMap(),\n    },\n    // TODO: offer, contact, dapp\n    /** @type {IdTable<number, unknown>} */\n    unknown: {\n      bySlot: makeScalarMap(),\n      byVal: makeScalarMap(),\n    },\n  };\n  /** @type {IdTable<BoardId, unknown>} */\n  const boardObjects = {\n    bySlot: makeScalarMap(),\n    byVal: makeScalarMap(),\n  };\n\n  /**\n   * Look up the slot in mappings from published data\n   * else try walletObjects that we have seen.\n   *\n   * @throws if not found (a slotToVal function typically\n   *         conjures a new identity)\n   *\n   * @param {MixedSlot<typeof walletObjects>} slot\n   * @param {string} _iface\n   */\n  const slotToVal = (slot, _iface) => {\n    if (isBoardId(slot) && boardObjects.bySlot.has(slot)) {\n      return boardObjects.bySlot.get(slot);\n    }\n    const { kind, id } = parseWalletSlot(walletObjects, slot);\n    assert(kind, X`bad slot kind: ${slot}`);\n    const val = walletObjects[kind].bySlot.get(id); // or throw\n    return val;\n  };\n\n  let unknownNonce = 0;\n\n  /**\n   * @param {unknown} val\n   * @returns {MixedSlot<typeof walletObjects>}\n   */\n  const valToSlot = val => {\n    if (boardObjects.byVal.has(val)) {\n      return boardObjects.byVal.get(val);\n    }\n    const kind = findKey(walletObjects, k => walletObjects[k].byVal.has(val));\n    if (kind) {\n      // @ts-expect-error has(val) above ensures val has the right type\n      const id = walletObjects[kind].byVal.get(val);\n      return makeWalletSlot(walletObjects, kind, id);\n    }\n    unknownNonce += 1;\n    const slot = makeWalletSlot(walletObjects, 'unknown', unknownNonce);\n    initSlotVal(walletObjects.unknown, unknownNonce, val);\n    return slot;\n  };\n\n  /**\n   * @template V\n   * @param {string & keyof typeof walletObjects} kind\n   * @param {IdTable<number, V>} table\n   */\n  const makeSaver = (kind, table) => {\n    let nonce = 0;\n    /** @param {V} val */\n    const saver = val => {\n      nonce += 1;\n      initSlotVal(table, nonce, val);\n    };\n    return saver;\n  };\n\n  return harden({\n    savePurseActions: makeSaver('purse', walletObjects.purse),\n    savePaymentActions: makeSaver('payment', walletObjects.payment),\n    /**\n     * @param {number} id\n     * @param {Purse} purse\n     */\n    initPurseId: (id, purse) => {\n      initSlotVal(walletObjects.purse, id, purse);\n    },\n    purseEntries: walletObjects.purse.bySlot.entries,\n    /**\n     * @param {BoardId} id\n     * @param {unknown} val\n     */\n    initBoardId: (id, val) => {\n      initSlotVal(boardObjects, id, val);\n    },\n    /**\n     * @param {BoardId} id\n     * @param {unknown} val\n     */\n    ensureBoardId: (id, val) => {\n      if (boardObjects.byVal.has(val)) {\n        assert.equal(boardObjects.byVal.get(val), id);\n        return;\n      }\n      initSlotVal(boardObjects, id, val);\n    },\n    ...makeMarshal(valToSlot, slotToVal),\n  });\n};\n\nconst defaultMakePresence = iface => {\n  const severed = `SEVERED: ${iface.replace(/^Alleged: /, '')}`;\n  return Far(severed, {});\n};\n\n/**\n * Make context for marshalling wallet or board data.\n * To be imported into the client, which never exports objects.\n *\n * @param {(iface: string) => unknown} [makePresence]\n */\nexport const makeImportContext = (makePresence = defaultMakePresence) => {\n  const walletObjects = {\n    /** @type {IdTable<number, unknown>} */\n    purse: {\n      bySlot: makeScalarMap(),\n      byVal: makeScalarMap(),\n    },\n    /** @type {IdTable<number, unknown>} */\n    payment: {\n      bySlot: makeScalarMap(),\n      byVal: makeScalarMap(),\n    },\n    /** @type {IdTable<number, unknown>} */\n    unknown: {\n      bySlot: makeScalarMap(),\n      byVal: makeScalarMap(),\n    },\n  };\n  /** @type {IdTable<BoardId, unknown>} */\n  const boardObjects = {\n    bySlot: makeScalarMap(),\n    byVal: makeScalarMap(),\n  };\n\n  /**\n   * @template Slot\n   * @template Val\n   * @param {IdTable<Slot, Val>} table\n   * @param {Slot} slot\n   * @param {string} iface\n   */\n  const provideVal = (table, slot, iface) => {\n    if (table.bySlot.has(slot)) {\n      return table.bySlot.get(slot);\n    }\n    const val = makePresence(iface);\n    initSlotVal(table, slot, val);\n    return val;\n  };\n\n  const slotToVal = {\n    /**\n     * @param {string} slot\n     * @param {string} iface\n     */\n    fromBoard: (slot, iface) => {\n      assert(isBoardId(slot), X`bad board slot ${q(slot)}`);\n      return provideVal(boardObjects, slot, iface);\n    },\n\n    /**\n     * @param {string} slot\n     * @param {string} iface\n     */\n    fromMyWallet: (slot, iface) => {\n      if (!slot) {\n        // Empty or null slots are neither in the wallet nor the board.\n        return makePresence(`${slot}`);\n      }\n      const { kind, id } = parseWalletSlot(walletObjects, slot);\n      return kind\n        ? provideVal(walletObjects[kind], id, iface)\n        : slotToVal.fromBoard(slot, iface);\n    },\n  };\n\n  const valToSlot = {\n    fromBoard: val => boardObjects.byVal.get(val),\n    /** @param {unknown} val */\n    fromMyWallet: val => {\n      const kind = findKey(walletObjects, k => walletObjects[k].byVal.has(val));\n      assert(kind, X`cannot serialize unregistered ${val}`);\n\n      const id = walletObjects[kind].byVal.get(val);\n      return makeWalletSlot(walletObjects, kind, id);\n    },\n  };\n\n  const marshal = {\n    fromBoard: makeMarshal(valToSlot.fromBoard, slotToVal.fromBoard, {\n      marshalName: 'fromBoard',\n    }),\n    fromMyWallet: makeMarshal(valToSlot.fromMyWallet, slotToVal.fromMyWallet, {\n      marshalName: 'fromMyWallet',\n    }),\n  };\n\n  return harden({\n    /**\n     * @param {BoardId} id\n     * @param {unknown} val\n     */\n    initBoardId: (id, val) => {\n      initSlotVal(boardObjects, id, val);\n    },\n    /**\n     * @param {BoardId} id\n     * @param {unknown} val\n     */\n    ensureBoardId: (id, val) => {\n      if (boardObjects.byVal.has(val)) {\n        assert.equal(boardObjects.byVal.get(val), id);\n        return;\n      }\n      initSlotVal(boardObjects, id, val);\n    },\n    fromMyWallet: Far('wallet marshaller', { ...marshal.fromMyWallet }),\n    fromBoard: Far('board marshaller', { ...marshal.fromBoard }),\n  });\n};\n\n/**\n * @param {string} iface\n * @param {{\n *   applyMethod: (target: unknown, method: string | symbol, args: unknown[]) => void,\n *   applyFunction: (target: unknown, args: unknown[]) => void,\n * }} handler\n */\nconst makePresence = (iface, handler) => {\n  let obj;\n  // eslint-disable-next-line no-new\n  new HandledPromise((resolve, reject, resolveWithPresence) => {\n    obj = resolveWithPresence(handler);\n  });\n  assert(obj);\n  return Remotable(iface, undefined, obj);\n};\n\n/**\n * @param {string} iface\n * @param {(parts: unknown[]) => void} log\n */\nexport const makeLoggingPresence = (iface, log) => {\n  /** @type {any} */ // TODO: solve types puzzle\n  const it = makePresence(iface, {\n    applyMethod: (target, method, args) => {\n      log(harden(['applyMethod', target, method, args]));\n    },\n    applyFunction: (target, args) => {\n      log(harden(['applyFunction', target, args]));\n    },\n  });\n  return it;\n};\n","import { Far } from '@endo/captp';\n\nexport const getScopedBridge = (origin, suggestedDappPetname, bridge) => {\n  const {\n    getPursesNotifier,\n    dappService,\n    offerService,\n    issuerService,\n    unserializer,\n    networkConfig,\n  } = bridge;\n\n  const { dapps, addDapp, setDappPetname, deleteDapp, enableDapp } =\n    dappService;\n\n  const setPetname = petname => setDappPetname(origin, petname);\n\n  let dapp = dapps.get(origin);\n  if (!dapp) {\n    let enableAction;\n    const approvedP = new Promise(res => {\n      enableAction = () => {\n        enableDapp(origin);\n        res();\n      };\n    });\n\n    dapp = {\n      id: origin,\n      meta: { id: origin },\n      petname: suggestedDappPetname,\n      origin,\n      enable: false,\n      actions: {\n        enable: enableAction,\n        setPetname,\n        delete: () => deleteDapp(origin),\n      },\n      approvedP,\n    };\n    addDapp(dapp);\n  }\n\n  return Far('scoped bridge', {\n    async addOffer(config) {\n      const currentTime = new Date().getTime();\n      const id = `${currentTime}`;\n      await dapp.approvedP;\n      offerService.addOffer({\n        id,\n        instancePetname: `instance@${config.instanceHandleBoardId}`,\n        requestContext: { dappOrigin: origin, origin },\n        meta: {\n          id: `${currentTime}`,\n          creationStamp: currentTime,\n        },\n        status: 'proposed',\n        ...config,\n      });\n      return id;\n    },\n    async suggestIssuer(petname, boardId) {\n      await dapp.approvedP;\n      issuerService.addSuggestion(petname, boardId);\n    },\n    async suggestInstallation(petname, boardId) {\n      await dapp.approvedP;\n      console.log('TODO: suggest installation', petname, boardId);\n    },\n    async suggestInstance(petname, boardId) {\n      await dapp.approvedP;\n      console.log('TODO: suggest instance', petname, boardId);\n    },\n    async getPursesNotifier() {\n      await dapp.approvedP;\n      // TODO: attenuate purses? maybe not needed if they're from follower\n      return getPursesNotifier();\n    },\n    async getOffersNotifier() {\n      await dapp.approvedP;\n      // TODO: filter offers by dapp origin\n      return offerService.notifier;\n    },\n    async getUnserializer() {\n      await dapp.approvedP;\n      return unserializer;\n    },\n    async getNetConfig() {\n      await dapp.approvedP;\n      return networkConfig;\n    },\n  });\n};\n","import { maybeLoad, maybeSave } from '../util/storage.js';\n\nconst DAPPS_KEY_PREFIX = 'DAPPS';\n\nexport const loadDapps = publicAddress =>\n  maybeLoad([DAPPS_KEY_PREFIX, publicAddress]) ?? [];\n\nexport const upsertDapp = (publicAddress, dapp) => {\n  const { origin, enable, petname } = dapp;\n\n  const dapps = loadDapps(publicAddress) ?? [];\n  maybeSave(\n    [DAPPS_KEY_PREFIX, publicAddress],\n    [\n      ...dapps.filter(d => d.origin !== origin),\n      { origin, enable, petname, id: origin, meta: { id: origin } },\n    ],\n  );\n};\n\nexport const removeDapp = (publicAddress, origin) => {\n  const dapps = loadDapps(publicAddress) ?? [];\n  maybeSave(\n    [DAPPS_KEY_PREFIX, publicAddress],\n    dapps.filter(d => d.origin !== origin),\n  );\n};\n","import { makeNotifierKit } from '@agoric/notifier';\nimport {\n  loadDapps as load,\n  removeDapp as remove,\n  upsertDapp as upsert,\n} from '../store/Dapps.js';\n\n/**\n * @param {string} publicAddress\n */\nexport const getDappService = publicAddress => {\n  const dapps = new Map();\n  const { notifier, updater } = makeNotifierKit();\n  const broadcastUpdates = () => updater.updateState([...dapps.values()]);\n\n  const upsertDapp = dapp => {\n    dapps.set(dapp.origin, dapp);\n    upsert(publicAddress, dapp);\n    broadcastUpdates();\n  };\n\n  const deleteDapp = origin => {\n    dapps.delete(origin);\n    remove(publicAddress, origin);\n    broadcastUpdates();\n  };\n\n  const setDappPetname = (origin, petname) => {\n    const dapp = dapps.get(origin);\n    assert(dapp, `Tried to set petname on undefined dapp ${origin}`);\n    upsertDapp({ ...dapp, petname });\n  };\n\n  const enableDapp = origin => {\n    const dapp = dapps.get(origin);\n    assert(dapp, `Tried to enable undefined dapp ${origin}`);\n    upsertDapp({ ...dapp, enable: true });\n  };\n\n  const storedDapps = load(publicAddress);\n  storedDapps.forEach(d => {\n    let enableAction;\n    const approvedP = new Promise(res => {\n      enableAction = () => {\n        enableDapp(d.origin);\n        res();\n      };\n    });\n\n    dapps.set(d.origin, {\n      ...d,\n      approvedP,\n      actions: {\n        enable: enableAction,\n        setPetname: petname => setDappPetname(d.origin, petname),\n        delete: () => deleteDapp(d.origin),\n      },\n    });\n\n    if (d.enable) {\n      enableAction();\n    }\n  });\n  broadcastUpdates();\n\n  return {\n    dapps,\n    notifier,\n    addDapp: upsertDapp,\n    setDappPetname,\n    deleteDapp,\n    enableDapp,\n  };\n};\n","import { maybeLoad, maybeSave } from '../util/storage.js';\n\nconst OFFERS_KEY_PREFIX = 'OFFERS';\n\nexport const loadOffers = publicAddress =>\n  maybeLoad([OFFERS_KEY_PREFIX, publicAddress]) ?? [];\n\nexport const addOffer = (publicAddress, offer) => {\n  const offers = loadOffers(publicAddress) ?? [];\n  maybeSave(\n    [OFFERS_KEY_PREFIX, publicAddress],\n    [...offers.filter(o => o.id !== offer.id), offer],\n  );\n};\n\nexport const removeOffer = (publicAddress, id) => {\n  const offers = loadOffers(publicAddress) ?? [];\n  maybeSave(\n    [OFFERS_KEY_PREFIX, publicAddress],\n    offers.filter(o => o.id !== id),\n  );\n};\n","import {\n  makeNotifierKit,\n  makeAsyncIterableFromNotifier,\n} from '@agoric/notifier';\nimport {\n  loadOffers as load,\n  removeOffer as remove,\n  addOffer as add,\n} from '../store/Offers.js';\n\n/**\n * @param {string} publicAddress\n * @param {(data: string) => Promise<any>} signSpendAction\n * @param {Notifier<any>} chainOffersNotifier\n */\nexport const getOfferService = (\n  publicAddress,\n  signSpendAction,\n  chainOffersNotifier,\n) => {\n  const offers = new Map();\n  let chainOffers = [];\n  const { notifier, updater } = makeNotifierKit();\n  const broadcastUpdates = () =>\n    updater.updateState([...offers.values(), ...chainOffers]);\n\n  const upsertOffer = offer => {\n    offers.set(offer.id, offer);\n    add(publicAddress, offer);\n    broadcastUpdates();\n  };\n\n  const declineOffer = id => {\n    const offer = offers.get(id);\n    assert(offer, `Tried to decline undefined offer ${id}`);\n    upsertOffer({ ...offer, status: 'decline' });\n    broadcastUpdates();\n  };\n\n  const acceptOffer = async id => {\n    const offer = offers.get(id);\n    assert(offer, `Tried to accept undefined offer ${id}`);\n    return signSpendAction(offer.spendAction);\n  };\n\n  const cancelOffer = _id => {\n    console.log('TODO: cancel offer');\n  };\n\n  const storedOffers = load(publicAddress);\n  storedOffers.forEach(o => {\n    if (o.status === 'decline') {\n      remove(publicAddress, o.id);\n    }\n    offers.set(o.id, {\n      ...o,\n    });\n  });\n  broadcastUpdates();\n\n  const watchChainOffers = async () => {\n    for await (const state of makeAsyncIterableFromNotifier(\n      chainOffersNotifier,\n    )) {\n      state?.forEach(offer => {\n        console.log('chain offer', offer);\n        const splitId = offer.id.split('#');\n        const rawId = splitId[splitId.length - 1];\n        if (offers.has(rawId)) {\n          offers.delete(rawId);\n          remove(publicAddress, rawId);\n        }\n        chainOffers = state;\n        broadcastUpdates();\n      });\n    }\n  };\n  watchChainOffers();\n\n  return {\n    offers,\n    notifier,\n    addOffer: upsertOffer,\n    acceptOffer,\n    cancelOffer,\n    declineOffer,\n  };\n};\n","import { makeNotifierKit } from '@agoric/notifier';\n\n/**\n * @param {(data: string) => Promise<any>} signSpendAction\n */\nexport const getIssuerService = signSpendAction => {\n  const suggestions = new Map();\n  // TODO: Upgrade to `makePublishKit`.\n  const { notifier, updater } = makeNotifierKit();\n  const broadcastUpdates = () => updater.updateState([...suggestions.values()]);\n\n  const deleteSuggestion = boardId => {\n    assert(\n      suggestions.has(boardId),\n      `Tried to delete undefined issuer suggestion ${boardId}`,\n    );\n    suggestions.delete(boardId);\n    broadcastUpdates();\n  };\n\n  const addSuggestion = (petname, boardId) => {\n    suggestions.set(boardId, {\n      boardId,\n      petname,\n      actions: {\n        delete: () => deleteSuggestion(boardId),\n        accept: async suggestedPetname => {\n          const action = JSON.stringify({\n            type: 'suggestIssuer',\n            data: { boardId, petname: suggestedPetname },\n          });\n          try {\n            await signSpendAction(action);\n            deleteSuggestion(boardId);\n          } catch (e) {\n            console.error('Sign spend action failed', action);\n          }\n        },\n      },\n    });\n    broadcastUpdates();\n  };\n\n  return {\n    notifier,\n    addSuggestion,\n  };\n};\n","import { E } from '@endo/eventual-send';\nimport { Far } from '@endo/marshal';\nimport {\n  makeAsyncIterableFromNotifier,\n  makeNotifierKit,\n} from '@agoric/notifier';\nimport { iterateEach, iterateReverse } from '@agoric/casting';\nimport { getScopedBridge } from '../service/ScopedBridge.js';\nimport { getDappService } from '../service/Dapps.js';\nimport { getOfferService } from '../service/Offers.js';\nimport { getIssuerService } from '../service/Issuers.js';\n\nconst newId = kind => `${kind}${Math.random()}`;\nexport const NO_SMART_WALLET_ERROR = 'no smart wallet';\n\n/** @typedef {{actions: object, issuerSuggestions: Promise<AsyncIterator>}} BackendSchema */\n\nexport const makeBackendFromWalletBridge = walletBridge => {\n  /**\n   * @template T\n   * @param {ERef<Notifier<T>>} notifier\n   */\n  const iterateNotifier = async notifier =>\n    makeAsyncIterableFromNotifier(notifier)[Symbol.asyncIterator]();\n\n  const { notifier: servicesNotifier } = makeNotifierKit(\n    harden({\n      board: E(walletBridge).getBoard(),\n    }),\n  );\n\n  /**\n   * @param {AsyncIterator<any[], any[], undefined>} offersMembers\n   */\n  const wrapOffersIterator = offersMembers =>\n    harden({\n      next: async () => {\n        const { done, value } = await E(offersMembers).next();\n        return harden({\n          done,\n          value:\n            value &&\n            value.map(({ id, ...rest }) =>\n              harden({\n                id,\n                ...rest,\n                actions: Far('offerActions', {\n                  // Provide these synthetic actions since offers don't have any yet.\n                  accept: () => E(walletBridge).acceptOffer(id),\n                  decline: () => E(walletBridge).declineOffer(id),\n                  cancel: () => E(walletBridge).cancelOffer(id),\n                }),\n              }),\n            ),\n        });\n      },\n      return: offersMembers.return,\n      throw: offersMembers.throw,\n    });\n\n  /** @type {BackendSchema} */\n  const firstSchema = harden({\n    actions: Far('schemaActions', {\n      createPurse: (issuer, id = newId('Purse')) =>\n        E(walletBridge).makeEmptyPurse(issuer?.issuerPetname, id),\n      createContact: (depositFacet, id = newId('Contact')) =>\n        E(walletBridge).addContact(id, depositFacet),\n      createIssuer: (issuer, id = newId('Issuer')) =>\n        E(walletBridge).addIssuer(id, issuer, true),\n    }),\n    services: iterateNotifier(servicesNotifier),\n    contacts: iterateNotifier(E(walletBridge).getContactsNotifier()),\n    dapps: iterateNotifier(E(walletBridge).getDappsNotifier()),\n    issuers: iterateNotifier(E(walletBridge).getIssuersNotifier()),\n    offers: wrapOffersIterator(\n      iterateNotifier(E(walletBridge).getOffersNotifier()),\n    ),\n    payments: iterateNotifier(E(walletBridge).getPaymentsNotifier()),\n    purses: iterateNotifier(E(walletBridge).getPursesNotifier()),\n    issuerSuggestions: iterateNotifier(\n      E(walletBridge).getIssuerSuggestionsNotifier(),\n    ),\n  });\n\n  // Just produce a single update for the initial backend.\n  // TODO: allow further updates.\n  /** @type {NotifierKit<BackendSchema>} */\n  const { notifier: backendNotifier, updater: backendUpdater } =\n    makeNotifierKit(firstSchema);\n\n  const backendIt = iterateNotifier(backendNotifier);\n\n  const cancel = e => {\n    backendUpdater.fail(e);\n  };\n\n  return { backendIt, cancel };\n};\n\n/**\n * @param {import('@agoric/casting').Follower<any>} follower\n * @param {import('@agoric/casting').Leader} leader\n * @param {ReturnType<import('@endo/marshal').makeMarshal>} marshaller\n * @param {string} publicAddress\n * @param {object} keplrConnection\n * @param {string} networkConfig\n * @param {(e: unknown) => void} [errorHandler]\n * @param {() => void} [firstCallback]\n */\nexport const makeWalletBridgeFromFollower = (\n  follower,\n  leader,\n  marshaller,\n  publicAddress,\n  keplrConnection,\n  networkConfig,\n  errorHandler = e => {\n    // Make an unhandled rejection.\n    throw e;\n  },\n  firstCallback = () => {},\n) => {\n  const notifiers = {\n    getPursesNotifier: 'purses',\n    getContactsNotifier: 'contacts',\n    getIssuersNotifier: 'issuers',\n    getOffersNotifier: 'offers',\n    getPaymentsNotifier: 'payments',\n  };\n\n  const notifierKits = Object.fromEntries(\n    Object.entries(notifiers).map(([_method, stateName]) => [\n      stateName,\n      makeNotifierKit(null),\n    ]),\n  );\n\n  // We assume just one cosmos purse per brand.\n  const offers = {};\n  const brandToPurse = new Map();\n  const pursePetnameToBrand = new Map();\n\n  const updatePurses = () => {\n    const purses = [];\n    for (const [brand, purse] of brandToPurse.entries()) {\n      if (purse.currentAmount && purse.brandPetname) {\n        pursePetnameToBrand.set(purse.pursePetname, brand);\n        purses.push(purse);\n      }\n    }\n    notifierKits.purses.updater.updateState(harden(purses));\n  };\n\n  const followLatest = async () => {\n    /** @type {number} */\n    let firstHeight;\n    for await (const { blockHeight } of iterateReverse(follower)) {\n      // TODO: Only set firstHeight and break if the value contains all our state.\n      firstHeight = blockHeight;\n    }\n    assert(firstHeight, NO_SMART_WALLET_ERROR);\n    for await (const { value } of iterateEach(follower, {\n      height: firstHeight,\n    })) {\n      /** @type {import('@agoric/smart-wallet/src/smartWallet').UpdateRecord} */\n      const updateRecord = value;\n      if (firstCallback) {\n        firstCallback();\n        Object.values(notifierKits).forEach(({ updater }) =>\n          updater.updateState([]),\n        );\n        firstCallback = undefined;\n      }\n      switch (updateRecord.updated) {\n        case 'brand': {\n          const { descriptor } = updateRecord;\n          const purseObj = {\n            ...brandToPurse.get(descriptor.brand),\n            brand: descriptor.brand,\n            brandPetname: descriptor.petname,\n            pursePetname: descriptor.petname,\n            displayInfo: descriptor.displayInfo,\n          };\n          brandToPurse.set(descriptor.brand, purseObj);\n          updatePurses();\n          break;\n        }\n        case 'balance': {\n          // TODO: Don't assume just one purse per brand.\n          // https://github.com/Agoric/agoric-sdk/issues/6126\n          const { currentAmount } = updateRecord;\n          const purseObj = {\n            ...brandToPurse.get(currentAmount.brand),\n            currentAmount,\n            value: currentAmount.value,\n          };\n          brandToPurse.set(currentAmount.brand, purseObj);\n          updatePurses();\n          break;\n        }\n        case 'offerStatus': {\n          const { status } = updateRecord;\n          console.log('offerStatus', { status, offers });\n          const oldOffer = offers[status.id];\n          if (!oldOffer) {\n            console.warn('Update for unknown offer, doing nothing.');\n            break;\n          }\n          if ('error' in status) {\n            offers[status.id] = {\n              ...oldOffer,\n              id: `${status.id}`,\n              status: 'rejected',\n              error: `${status.error}`,\n            };\n          } else if (\n            oldOffer.status !== 'accept' &&\n            'numWantsSatisfied' in status\n          ) {\n            offers[status.id] = {\n              ...oldOffer,\n              id: `${status.id}`,\n              status: 'accept',\n            };\n          }\n          notifierKits.offers.updater.updateState(\n            harden(Object.values(offers)),\n          );\n          break;\n        }\n        default: {\n          throw Error(`Unknown updateRecord ${updateRecord.updated}`);\n        }\n      }\n    }\n  };\n\n  const retry = () => {\n    followLatest().catch(e => {\n      if (e.message === NO_SMART_WALLET_ERROR) {\n        setTimeout(retry, 5000);\n      } else {\n        errorHandler(e);\n      }\n    });\n  };\n\n  followLatest().catch(e => {\n    errorHandler(e);\n    if (e.message === NO_SMART_WALLET_ERROR) {\n      setTimeout(retry, 5000);\n    }\n  });\n\n  const getNotifierMethods = Object.fromEntries(\n    Object.entries(notifiers).map(([method, stateName]) => {\n      const { notifier } = notifierKits[stateName];\n      return [method, () => notifier];\n    }),\n  );\n\n  const makeEmptyPurse = () => {\n    console.log('make empty purse');\n  };\n\n  const addContact = () => {\n    console.log('add contact');\n  };\n\n  const addIssuer = () => {\n    console.log('add issuer');\n  };\n\n  const signSpendAction = data => {\n    const {\n      signers: { interactiveSigner },\n    } = keplrConnection;\n    if (!interactiveSigner) {\n      throw new Error(\n        'Cannot sign a transaction in read only mode, connect to keplr.',\n      );\n    }\n    return interactiveSigner.submitSpendAction(data);\n  };\n\n  const issuerService = getIssuerService(signSpendAction);\n  const dappService = getDappService(publicAddress);\n  const offerService = getOfferService(\n    publicAddress,\n    signSpendAction,\n    getNotifierMethods.getOffersNotifier(),\n  );\n  const { acceptOffer, declineOffer, cancelOffer } = offerService;\n\n  // We override addOffer to adapt the old proposalTemplate format to the new\n  // smart-wallet format.\n  const addOfferPSMHack = async details => {\n    const {\n      id,\n      instanceHandleBoardId: instance, // This actually is the instance handle, not an ID.\n      invitationMaker: { method },\n      proposalTemplate: { give, want },\n    } = details;\n\n    const mapPurses = obj =>\n      Object.fromEntries(\n        Object.entries(obj).map(([kw, { brand, pursePetname, value }]) => [\n          kw,\n          {\n            brand: brand || pursePetnameToBrand.get(pursePetname),\n            value: BigInt(value),\n          },\n        ]),\n      );\n    const offer = {\n      id: new Date().getTime(),\n      invitationSpec: {\n        source: 'contract',\n        instance,\n        publicInvitationMaker: method,\n      },\n      proposal: {\n        give: mapPurses(give),\n        want: mapPurses(want),\n      },\n    };\n    const spendAction = await E(marshaller).serialize(\n      harden({\n        method: 'executeOffer',\n        offer,\n      }),\n    );\n\n    // Recover the instance's boardId.\n    const {\n      slots: [instanceBoardId],\n    } = await E(marshaller).serialize(instance);\n\n    const fullOffer = {\n      ...details,\n      instancePetname: `instance@${instanceBoardId}`,\n      spendAction: JSON.stringify(spendAction),\n    };\n    offerService.addOffer(fullOffer);\n    offers[id] = fullOffer;\n    return id;\n  };\n\n  const walletBridge = Far('follower wallet bridge', {\n    ...getNotifierMethods,\n    getDappsNotifier: () => dappService.notifier,\n    getOffersNotifier: () => offerService.notifier,\n    getIssuerSuggestionsNotifier: () => issuerService.notifier,\n    acceptOffer,\n    declineOffer,\n    cancelOffer,\n    makeEmptyPurse,\n    addContact,\n    addIssuer,\n    getScopedBridge: (origin, suggestedDappPetname) =>\n      getScopedBridge(origin, suggestedDappPetname, {\n        dappService,\n        offerService: { ...offerService, addOffer: addOfferPSMHack },\n        leader,\n        unserializer: marshaller,\n        publicAddress,\n        issuerService,\n        networkConfig,\n        ...getNotifierMethods,\n      }),\n  });\n\n  return walletBridge;\n};\n","import { makeCapTP } from '@endo/captp';\nimport { E } from '@endo/eventual-send';\n\nexport const bridgeStorageMessages = bridge => {\n  /** @type {Map<string,[ReturnType<typeof makeCapTP>, number]>} */\n  const dappToConn = new Map();\n\n  const handleStorageMessage = (key, newValue) => {\n    const keyParts = JSON.parse(key);\n    assert(Array.isArray(keyParts));\n    const [tag, origin, epoch, _ix] = /** @type {unknown[]} */ (keyParts);\n    const payload = JSON.parse(newValue);\n    if (tag !== 'out' || !payload || typeof payload.type !== 'string') {\n      return;\n    }\n\n    const obj = {\n      ...payload,\n      dappOrigin: origin,\n    };\n    const dappKey = JSON.stringify([origin, epoch]);\n    /** @type {ReturnType<typeof makeCapTP>}  */\n    let conn;\n    /** @type {number} */\n    let ix;\n    if (dappToConn.has(dappKey)) {\n      [conn, ix] = dappToConn.get(dappKey) || assert.fail();\n    } else {\n      /** @param {unknown} payloadOut */\n      const send = payloadOut => {\n        console.debug('WalletConnect: message -> storage', payloadOut);\n        window.localStorage.setItem(\n          JSON.stringify(['in', origin, epoch, ix]),\n          JSON.stringify(payloadOut),\n        );\n        ix += 1; // ISSUE: overflow?\n      };\n      const makeBoot = () => E(bridge).getScopedBridge(origin, origin);\n      console.debug('new capTP connection', { origin, epoch });\n      conn = makeCapTP(`from ${origin} at ${epoch}`, send, makeBoot);\n      ix = 0;\n    }\n    dappToConn.set(dappKey, [conn, ix + 1]);\n    console.debug('WalletConnect: storage -> dispatch', obj);\n    conn.dispatch(obj);\n    window.localStorage.removeItem(key);\n  };\n\n  const storageListener = ev => {\n    const { key, newValue } = ev;\n    // removeItem causes an event where newValue is null\n    if (key && newValue) {\n      handleStorageMessage(key, newValue);\n    }\n  };\n  window.addEventListener('storage', storageListener);\n\n  return () => {\n    window.removeEventListener('storage', storageListener);\n    for (const [conn, _ix] of dappToConn.values()) {\n      // @ts-expect-error capTP abort has wrong type?\n      conn.abort(Error('wallet connection cancelled'));\n    }\n  };\n};\n","import CircularProgress from '@mui/material/CircularProgress';\nimport Dialog from '@mui/material/Dialog';\nimport DialogTitle from '@mui/material/DialogTitle';\nimport DialogContent from '@mui/material/DialogContent';\nimport DialogContentText from '@mui/material/DialogContentText';\nimport DialogActions from '@mui/material/DialogActions';\nimport Button from '@mui/material/Button';\nimport Box from '@mui/material/Box';\nimport Link from '@mui/material/Link';\nimport { useState } from 'react';\n\nimport { withApplicationContext } from '../contexts/Application';\n\nconst steps = {\n  INITIAL: 0,\n  AWAITING_APPROVAL: 1,\n  IN_PROGRESS: 2,\n};\n\nconst errors = {\n  NO_SIGNER: 'Cannot sign a transaction in read only mode, connect to keplr.',\n};\n\n// TODO: Read this from the chain via rpc.\nconst CREATION_FEE = '10 BLD';\n\nconst ProvisionDialog = ({ onClose, open, address, href, keplrConnection }) => {\n  const [currentStep, setCurrentStep] = useState(steps.INITIAL);\n  const [error, setError] = useState(null);\n\n  const provisionWallet = async signer => {\n    setError(null);\n    setCurrentStep(steps.AWAITING_APPROVAL);\n    try {\n      await signer.submitProvision();\n    } catch (e) {\n      setCurrentStep(steps.INITIAL);\n      setError(e.message);\n      return;\n    }\n    setCurrentStep(steps.IN_PROGRESS);\n  };\n\n  const handleCreateButtonClicked = () => {\n    const {\n      signers: { interactiveSigner },\n    } = keplrConnection;\n    if (!interactiveSigner) {\n      setError(errors.NO_SIGNER);\n      return;\n    }\n\n    provisionWallet(interactiveSigner);\n  };\n\n  const progressIndicator = text => (\n    <Box>\n      <Box\n        sx={{\n          margin: 'auto',\n          display: 'flex',\n          flexDirection: 'row',\n          justifyContent: 'center',\n        }}\n      >\n        <CircularProgress />\n      </Box>\n      <DialogContentText sx={{ pt: 2 }}>{text}</DialogContentText>\n    </Box>\n  );\n\n  const content = (() => {\n    switch (currentStep) {\n      case steps.INITIAL:\n        return (\n          <div>\n            <DialogContentText>\n              <b>Network Config</b>:{' '}\n              <Link href={href} underline=\"none\" color=\"rgb(0, 176, 255)\">\n                {href}\n              </Link>\n            </DialogContentText>\n            <DialogContentText sx={{ pt: 2 }}>\n              <b>Wallet Address:</b> {address}\n            </DialogContentText>\n            <DialogContentText sx={{ pt: 2 }}>\n              There is no smart wallet provisioned for this address yet. A fee\n              of <b>{CREATION_FEE}</b> is required to create one.\n            </DialogContentText>\n          </div>\n        );\n      case steps.AWAITING_APPROVAL:\n        return progressIndicator('Please approve the transaction in Keplr.');\n      case steps.IN_PROGRESS:\n        return progressIndicator('Awaiting smart wallet creation...');\n      default:\n        return <></>;\n    }\n  })();\n\n  return (\n    <Dialog open={open}>\n      <DialogTitle>\n        {currentStep === steps.INITIAL ? 'Create a' : 'Creating'} Smart Wallet\n      </DialogTitle>\n      <DialogContent>\n        {content}\n        {error && (\n          <DialogContentText sx={{ pt: 2 }} color=\"primary\">\n            {error}\n          </DialogContentText>\n        )}\n      </DialogContent>\n      {currentStep === steps.INITIAL && (\n        <DialogActions>\n          <Button color=\"cancel\" onClick={onClose}>\n            Change Connection\n          </Button>\n          <Button onClick={handleCreateButtonClicked}>Create</Button>\n        </DialogActions>\n      )}\n    </Dialog>\n  );\n};\n\nexport default withApplicationContext(ProvisionDialog, context => ({\n  keplrConnection: context.keplrConnection,\n}));\n","import { makeFollower, makeLeader } from '@agoric/casting';\nimport React, { useEffect, useState } from 'react';\nimport Snackbar from '@mui/material/Snackbar';\nimport MuiAlert from '@mui/material/Alert';\nimport { observeIterator } from '@agoric/notifier';\nimport { makeImportContext } from '@agoric/wallet/api/src/marshal-contexts';\n\nimport {\n  withApplicationContext,\n  ConnectionStatus,\n} from '../contexts/Application';\nimport {\n  makeBackendFromWalletBridge,\n  makeWalletBridgeFromFollower,\n  NO_SMART_WALLET_ERROR,\n} from '../util/WalletBackendAdapter';\nimport { SmartConnectionMethod } from '../util/connections';\nimport { bridgeStorageMessages } from '../util/BridgeStorage';\nimport ProvisionDialog from './ProvisionDialog';\n\nconst Alert = React.forwardRef(function Alert({ children, ...props }, ref) {\n  return (\n    <MuiAlert elevation={6} ref={ref} variant=\"filled\" {...props}>\n      {children}\n    </MuiAlert>\n  );\n});\n\nconst SmartWalletConnection = ({\n  connectionConfig,\n  setConnectionStatus,\n  setBackend,\n  setBackendErrorHandler,\n  keplrConnection,\n}) => {\n  const [snackbarMessages, setSnackbarMessages] = useState([]);\n  const [provisionDialogOpen, setProvisionDialogOpen] = useState(false);\n\n  const onProvisionDialogClose = () => {\n    setProvisionDialogOpen(false);\n  };\n\n  const handleSnackbarClose = (_, reason) => {\n    if (reason === 'clickaway') {\n      return;\n    }\n\n    setSnackbarMessages(sm => sm.slice(1));\n  };\n\n  const showError = (message, e, severity = 'error') => {\n    if (e) {\n      console.error(`${message}:`, e);\n      message += `: ${e.message}`;\n    }\n    if (severity === 'error') {\n      setConnectionStatus(ConnectionStatus.Error);\n    }\n    setSnackbarMessages(sm => [...sm, { severity, message }]);\n  };\n\n  const { href, smartConnectionMethod } = connectionConfig;\n\n  const publicAddress = (() => {\n    if (\n      smartConnectionMethod === SmartConnectionMethod.KEPLR &&\n      keplrConnection\n    ) {\n      return keplrConnection.address;\n    } else if (smartConnectionMethod === SmartConnectionMethod.READ_ONLY) {\n      return connectionConfig.publicAddress;\n    }\n    return undefined;\n  })();\n\n  const backendError = e => {\n    if (e.message === NO_SMART_WALLET_ERROR) {\n      setProvisionDialogOpen(true);\n      setConnectionStatus(ConnectionStatus.Error);\n    } else {\n      setBackend(null);\n      showError('Error in wallet backend', e);\n    }\n  };\n\n  useEffect(() => {\n    if (\n      !connectionConfig ||\n      (connectionConfig.smartConnectionMethod === SmartConnectionMethod.KEPLR &&\n        !keplrConnection)\n    ) {\n      return undefined;\n    }\n\n    let cancelIterator;\n    let cleanupStorageBridge;\n\n    const follow = async () => {\n      const context = makeImportContext();\n      const leader = makeLeader(href);\n      const follower = makeFollower(\n        `:published.wallet.${publicAddress}`,\n        leader,\n        { unserializer: context.fromMyWallet },\n      );\n      // TODO try making a smart-wallet version of this\n      const bridge = makeWalletBridgeFromFollower(\n        follower,\n        leader,\n        context.fromBoard,\n        publicAddress,\n        keplrConnection,\n        href,\n        backendError,\n        () => {\n          setConnectionStatus(ConnectionStatus.Connected);\n          setProvisionDialogOpen(false);\n        },\n      );\n      const { backendIt, cancel } = makeBackendFromWalletBridge(bridge);\n      cleanupStorageBridge = bridgeStorageMessages(bridge);\n      cancelIterator = cancel;\n      // Need to thunk the error handler, or it gets called immediately.\n      setBackendErrorHandler(() => backendError);\n      return observeIterator(backendIt, {\n        updateState: be => {\n          cancelIterator && setBackend(be);\n        },\n        fail: e => {\n          cancelIterator && backendError(e);\n        },\n        finish: be => {\n          cancelIterator && setBackend(be);\n        },\n      });\n    };\n    follow().catch(e => showError('Cannot read Smart Wallet casting', e));\n\n    return () => {\n      cancelIterator && cancelIterator();\n      cancelIterator = undefined;\n      cleanupStorageBridge && cleanupStorageBridge();\n      cleanupStorageBridge = undefined;\n    };\n  }, [connectionConfig, keplrConnection]);\n\n  return (\n    <div>\n      <Snackbar open={snackbarMessages.length > 0}>\n        <Alert\n          onClose={handleSnackbarClose}\n          severity={snackbarMessages[0]?.severity}\n          sx={{ width: '100%' }}\n        >\n          {snackbarMessages[0]?.message}\n        </Alert>\n      </Snackbar>\n      <ProvisionDialog\n        open={provisionDialogOpen}\n        onClose={onProvisionDialogClose}\n        address={publicAddress}\n        href={href}\n      />\n    </div>\n  );\n};\n\nexport default withApplicationContext(SmartWalletConnection, context => ({\n  connectionConfig: context.connectionConfig,\n  setConnectionStatus: context.setConnectionStatus,\n  setBackend: context.setBackend,\n  setBackendErrorHandler: context.setBackendErrorHandler,\n  keplrConnection: context.keplrConnection,\n}));\n"],"names":["DEFAULT_BOOTSTRAP","delay","ms","Promise","resolve","setTimeout","randomBackoff","range","cap","Math","random","min","exponentialBackoff","attempt","base","DEFAULT_JITTER","where","jitter","DEFAULT_JITTER_SECONDS","console","debug","ceil","DEFAULT_RETRY_CALLBACK","err","backoff","log","DEFAULT_KEEP_POLLING","DEFAULT_KEEP_POLLING_SECONDS","then","MAKE_DEFAULT_DECODER","harden","str","JSON","parse","error","Error","message","MAKE_DEFAULT_UNSERIALIZER","ifaceAllegedPrefix","seen","Map","Far","unserialize","makeMarshal","undefined","slot","iface","has","get","startsWith","slice","length","obj","set","shuffle","a","i","j","floor","x","makePollingChangeFollower","async","keepPolling","E","leader","getOptions","iterable","Symbol","asyncIterator","nextPollPromise","next","cont","keepGoing","change","values","value","done","getLatestIterable","getEachIterable","getReverseIterable","details","X","assert","makeLeaderFromRpcAddresses","rpcAddrs","leaderOptions","Array","isArray","endpoints","retryCallback","retrying","lastRespondingEndpointIndex","thisAttempt","retry","watchCasting","_castingSpecP","pollingChangeFollower","mapEndpoints","callback","reject","endpointIndex","applyOne","res","makeRoundRobinLeader","map","rpcAddr","typeof","includes","makeLeaderFromNetworkConfig","netconfigURL","options","makeLeader","response","fetch","headers","accept","json","retryLeader","catch","bootstrap","makeNotifierIterable","notifier","makeNotifier","getSharableNotifierInternals","makeSubscriptionIterable","subscription","makeSubscriptionIterator","tailP","getSharableSubscriptionInternals","resultP","head","tail","mapAsyncIterable","transform","transformGenerator","iterateEach","follower","eachIterable","iterator","iterateReverse","toAscii","encodingStar","PATH_SEPARATOR_BYTE","charCodeAt","DATA_PREFIX_BYTES","Uint8Array","vstoragePathToCastingSpec","storagePath","storeName","elems","split","buf","storeSubkey","b","dataPrefixBytes","pathPrefixToConverters","te","TextEncoder","makeCastingSpecFromObject","specObj","subkey","encode","dataPrefix","makeCastingSpec","spec","sourceP","specString","match","kind","storePath","converter","makeCastingSpecFromString","getInterfaceOf","specCap","getStoreKey","makeCastingSpecFromRef","fail","QueryClient","stargateStar","Tendermint34Client","tendermintRpcStar","quote","q","textDecoder","TextDecoder","isStreamCell","cell","blockHeight","test","arrayEqual","defaultDataPrefixBytes","collectSingle","count","push","equal","proofs","makeFollower","specP","leaderOrMaker","defaultMakeLeader","decode","unserializer","proof","crasher","crash","e","castingSpecP","tendermintClientPs","provideTendermintClient","endpoint","clientP","connect","getBlockHeight","client","info","abciInfo","lastBlockHeight","endpointToQueryClient","provideQueryClient","queryClient","rpcClient","withExtensions","retryGetDataAndStripPrefix","tryGetPrefixedData","result","subarray","getProvenDataAtHeight","queryVerified","height","getUnprovenDataAtHeight","abciQuery","path","data","prove","code","tryGetDataAtHeight","allegedData","provenData","getDataAtHeight","streamCellForData","text","Number","followerElementFromStreamCellValue","currentBlockHeight","allValuesFromCell","streamCell","reverseValuesFromCell","lastValueFromCell","last","currentData","currentStreamCell","getEachIterableAtHeight","cursorBlockHeight","cursorData","cursorStreamCell","rightBlockHeight","rightData","rightStreamCell","cells","leftBlockHeight","leftData","leftStreamCell","pop","getReverseIterableAtHeight","makeCosmjsFollower","NaN","ai","makeSubscriptionFollower","isBoardId","specimen","makeWalletSlot","_tables","id","findKey","record","predicate","Object","keys","find","parseWalletSlot","tables","k","initSlotVal","table","val","bySlot","init","byVal","defaultMakePresence","severed","replace","getScopedBridge","origin","suggestedDappPetname","bridge","getPursesNotifier","dappService","offerService","issuerService","networkConfig","dapps","addDapp","setDappPetname","deleteDapp","enableDapp","setPetname","petname","dapp","enableAction","approvedP","meta","enable","actions","delete","config","currentTime","Date","getTime","addOffer","instancePetname","instanceHandleBoardId","requestContext","dappOrigin","creationStamp","status","boardId","addSuggestion","DAPPS_KEY_PREFIX","loadDapps","publicAddress","maybeLoad","getDappService","updater","makeNotifierKit","broadcastUpdates","updateState","upsertDapp","maybeSave","filter","d","upsert","remove","load","forEach","OFFERS_KEY_PREFIX","loadOffers","removeOffer","offers","o","getOfferService","signSpendAction","chainOffersNotifier","chainOffers","upsertOffer","offer","add","state","makeAsyncIterableFromNotifier","splitId","rawId","watchChainOffers","acceptOffer","spendAction","cancelOffer","_id","declineOffer","getIssuerService","suggestions","deleteSuggestion","action","stringify","type","suggestedPetname","newId","NO_SMART_WALLET_ERROR","bridgeStorageMessages","dappToConn","storageListener","ev","key","newValue","keyParts","tag","epoch","_ix","payload","dappKey","conn","ix","send","payloadOut","window","localStorage","setItem","makeBoot","makeCapTP","dispatch","removeItem","handleStorageMessage","addEventListener","removeEventListener","abort","steps","errors","withApplicationContext","onClose","open","address","href","keplrConnection","currentStep","setCurrentStep","useState","setError","progressIndicator","Box","sx","margin","display","flexDirection","justifyContent","CircularProgress","DialogContentText","pt","content","Link","underline","color","Dialog","DialogTitle","DialogContent","DialogActions","Button","onClick","signers","interactiveSigner","signer","submitProvision","provisionWallet","context","Alert","React","ref","children","props","elevation","variant","connectionConfig","setConnectionStatus","setBackend","setBackendErrorHandler","snackbarMessages","setSnackbarMessages","provisionDialogOpen","setProvisionDialogOpen","showError","severity","ConnectionStatus","sm","smartConnectionMethod","SmartConnectionMethod","backendError","useEffect","cancelIterator","cleanupStorageBridge","makePresence","walletObjects","purse","makeScalarMap","payment","unknown","boardObjects","provideVal","slotToVal","fromBoard","fromMyWallet","valToSlot","marshal","marshalName","initBoardId","ensureBoardId","makeImportContext","marshaller","errorHandler","firstCallback","notifiers","getContactsNotifier","getIssuersNotifier","getOffersNotifier","getPaymentsNotifier","notifierKits","fromEntries","entries","_method","stateName","brandToPurse","pursePetnameToBrand","updatePurses","purses","brand","currentAmount","brandPetname","pursePetname","followLatest","firstHeight","updateRecord","updated","descriptor","purseObj","displayInfo","oldOffer","warn","getNotifierMethods","method","makeEmptyPurse","addContact","addIssuer","submitSpendAction","addOfferPSMHack","instance","invitationMaker","proposalTemplate","give","want","mapPurses","kw","BigInt","invitationSpec","source","publicInvitationMaker","proposal","serialize","slots","instanceBoardId","fullOffer","getDappsNotifier","getIssuerSuggestionsNotifier","makeWalletBridgeFromFollower","backendIt","cancel","walletBridge","iterateNotifier","servicesNotifier","board","getBoard","firstSchema","createPurse","issuer","issuerPetname","createContact","depositFacet","createIssuer","services","contacts","issuers","offersMembers","rest","decline","return","throw","payments","issuerSuggestions","backendNotifier","backendUpdater","makeBackendFromWalletBridge","observeIterator","be","finish","follow","Snackbar","_","reason","width"],"sourceRoot":""}